[
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "mysql.connector",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mysql.connector",
        "description": "mysql.connector",
        "detail": "mysql.connector",
        "documentation": {}
    },
    {
        "label": "Error",
        "importPath": "mysql.connector",
        "description": "mysql.connector",
        "isExtraImport": true,
        "detail": "mysql.connector",
        "documentation": {}
    },
    {
        "label": "DatabaseConnection",
        "importPath": "database.base",
        "description": "database.base",
        "isExtraImport": true,
        "detail": "database.base",
        "documentation": {}
    },
    {
        "label": "DatabaseConnection",
        "importPath": "database.base",
        "description": "database.base",
        "isExtraImport": true,
        "detail": "database.base",
        "documentation": {}
    },
    {
        "label": "DatabaseConnection",
        "importPath": "database.base",
        "description": "database.base",
        "isExtraImport": true,
        "detail": "database.base",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "yt_dlp",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yt_dlp",
        "description": "yt_dlp",
        "detail": "yt_dlp",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "BaseDownloader",
        "importPath": "downloaders.base",
        "description": "downloaders.base",
        "isExtraImport": true,
        "detail": "downloaders.base",
        "documentation": {}
    },
    {
        "label": "BaseDownloader",
        "importPath": "downloaders.base",
        "description": "downloaders.base",
        "isExtraImport": true,
        "detail": "downloaders.base",
        "documentation": {}
    },
    {
        "label": "BaseDownloader",
        "importPath": "downloaders.base",
        "description": "downloaders.base",
        "isExtraImport": true,
        "detail": "downloaders.base",
        "documentation": {}
    },
    {
        "label": "BaseDownloader",
        "importPath": "downloaders.base",
        "description": "downloaders.base",
        "isExtraImport": true,
        "detail": "downloaders.base",
        "documentation": {}
    },
    {
        "label": "ConfigManager",
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "isExtraImport": true,
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "AppConfig",
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "isExtraImport": true,
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "ConfigManager",
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "isExtraImport": true,
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "ConfigManager",
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "isExtraImport": true,
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "ConfigManager",
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "isExtraImport": true,
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "AppConfig",
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "isExtraImport": true,
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "ConfigManager",
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "isExtraImport": true,
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "ConfigManager",
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "isExtraImport": true,
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "ConfigManager",
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "isExtraImport": true,
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "ConfigManager",
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "isExtraImport": true,
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "AppConfig",
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "isExtraImport": true,
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "StorageConfig",
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "isExtraImport": true,
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "ConfigManager",
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "isExtraImport": true,
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "ConfigManager",
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "isExtraImport": true,
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "ConfigManager",
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "isExtraImport": true,
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "ConfigManager",
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "isExtraImport": true,
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "ConfigManager",
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "isExtraImport": true,
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "ConfigManager",
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "isExtraImport": true,
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "ConfigManager",
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "isExtraImport": true,
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "ConfigManager",
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "isExtraImport": true,
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "ConfigManager",
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "isExtraImport": true,
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "StatsManager",
        "importPath": "managers.stats_manager",
        "description": "managers.stats_manager",
        "isExtraImport": true,
        "detail": "managers.stats_manager",
        "documentation": {}
    },
    {
        "label": "StatsManager",
        "importPath": "managers.stats_manager",
        "description": "managers.stats_manager",
        "isExtraImport": true,
        "detail": "managers.stats_manager",
        "documentation": {}
    },
    {
        "label": "StatsManager",
        "importPath": "managers.stats_manager",
        "description": "managers.stats_manager",
        "isExtraImport": true,
        "detail": "managers.stats_manager",
        "documentation": {}
    },
    {
        "label": "StatsManager",
        "importPath": "managers.stats_manager",
        "description": "managers.stats_manager",
        "isExtraImport": true,
        "detail": "managers.stats_manager",
        "documentation": {}
    },
    {
        "label": "StatsManager",
        "importPath": "managers.stats_manager",
        "description": "managers.stats_manager",
        "isExtraImport": true,
        "detail": "managers.stats_manager",
        "documentation": {}
    },
    {
        "label": "StatsManager",
        "importPath": "managers.stats_manager",
        "description": "managers.stats_manager",
        "isExtraImport": true,
        "detail": "managers.stats_manager",
        "documentation": {}
    },
    {
        "label": "StatsManager",
        "importPath": "managers.stats_manager",
        "description": "managers.stats_manager",
        "isExtraImport": true,
        "detail": "managers.stats_manager",
        "documentation": {}
    },
    {
        "label": "StatsManager",
        "importPath": "managers.stats_manager",
        "description": "managers.stats_manager",
        "isExtraImport": true,
        "detail": "managers.stats_manager",
        "documentation": {}
    },
    {
        "label": "StatsManager",
        "importPath": "managers.stats_manager",
        "description": "managers.stats_manager",
        "isExtraImport": true,
        "detail": "managers.stats_manager",
        "documentation": {}
    },
    {
        "label": "StatsManager",
        "importPath": "managers.stats_manager",
        "description": "managers.stats_manager",
        "isExtraImport": true,
        "detail": "managers.stats_manager",
        "documentation": {}
    },
    {
        "label": "NotificationManager",
        "importPath": "managers.notification_manager",
        "description": "managers.notification_manager",
        "isExtraImport": true,
        "detail": "managers.notification_manager",
        "documentation": {}
    },
    {
        "label": "NotificationManager",
        "importPath": "managers.notification_manager",
        "description": "managers.notification_manager",
        "isExtraImport": true,
        "detail": "managers.notification_manager",
        "documentation": {}
    },
    {
        "label": "NotificationManager",
        "importPath": "managers.notification_manager",
        "description": "managers.notification_manager",
        "isExtraImport": true,
        "detail": "managers.notification_manager",
        "documentation": {}
    },
    {
        "label": "NotificationManager",
        "importPath": "managers.notification_manager",
        "description": "managers.notification_manager",
        "isExtraImport": true,
        "detail": "managers.notification_manager",
        "documentation": {}
    },
    {
        "label": "NotificationManager",
        "importPath": "managers.notification_manager",
        "description": "managers.notification_manager",
        "isExtraImport": true,
        "detail": "managers.notification_manager",
        "documentation": {}
    },
    {
        "label": "NotificationManager",
        "importPath": "managers.notification_manager",
        "description": "managers.notification_manager",
        "isExtraImport": true,
        "detail": "managers.notification_manager",
        "documentation": {}
    },
    {
        "label": "NotificationManager",
        "importPath": "managers.notification_manager",
        "description": "managers.notification_manager",
        "isExtraImport": true,
        "detail": "managers.notification_manager",
        "documentation": {}
    },
    {
        "label": "NotificationManager",
        "importPath": "managers.notification_manager",
        "description": "managers.notification_manager",
        "isExtraImport": true,
        "detail": "managers.notification_manager",
        "documentation": {}
    },
    {
        "label": "NotificationManager",
        "importPath": "managers.notification_manager",
        "description": "managers.notification_manager",
        "isExtraImport": true,
        "detail": "managers.notification_manager",
        "documentation": {}
    },
    {
        "label": "DownloadItem",
        "importPath": "models.download_item",
        "description": "models.download_item",
        "isExtraImport": true,
        "detail": "models.download_item",
        "documentation": {}
    },
    {
        "label": "DownloadItem",
        "importPath": "models.download_item",
        "description": "models.download_item",
        "isExtraImport": true,
        "detail": "models.download_item",
        "documentation": {}
    },
    {
        "label": "DownloadItem",
        "importPath": "models.download_item",
        "description": "models.download_item",
        "isExtraImport": true,
        "detail": "models.download_item",
        "documentation": {}
    },
    {
        "label": "DownloadItem",
        "importPath": "models.download_item",
        "description": "models.download_item",
        "isExtraImport": true,
        "detail": "models.download_item",
        "documentation": {}
    },
    {
        "label": "DownloadItem",
        "importPath": "models.download_item",
        "description": "models.download_item",
        "isExtraImport": true,
        "detail": "models.download_item",
        "documentation": {}
    },
    {
        "label": "DownloadItem",
        "importPath": "models.download_item",
        "description": "models.download_item",
        "isExtraImport": true,
        "detail": "models.download_item",
        "documentation": {}
    },
    {
        "label": "DownloadItem",
        "importPath": "models.download_item",
        "description": "models.download_item",
        "isExtraImport": true,
        "detail": "models.download_item",
        "documentation": {}
    },
    {
        "label": "DownloadItem",
        "importPath": "models.download_item",
        "description": "models.download_item",
        "isExtraImport": true,
        "detail": "models.download_item",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "models.queue",
        "description": "models.queue",
        "isExtraImport": true,
        "detail": "models.queue",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "models.queue",
        "description": "models.queue",
        "isExtraImport": true,
        "detail": "models.queue",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "models.queue",
        "description": "models.queue",
        "isExtraImport": true,
        "detail": "models.queue",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "models.queue",
        "description": "models.queue",
        "isExtraImport": true,
        "detail": "models.queue",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "models.queue",
        "description": "models.queue",
        "isExtraImport": true,
        "detail": "models.queue",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "models.queue",
        "description": "models.queue",
        "isExtraImport": true,
        "detail": "models.queue",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "models.queue",
        "description": "models.queue",
        "isExtraImport": true,
        "detail": "models.queue",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "models.queue",
        "description": "models.queue",
        "isExtraImport": true,
        "detail": "models.queue",
        "documentation": {}
    },
    {
        "label": "DownloadStatus",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "DownloadStatus",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "DownloadStatus",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "DownloadStatus",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "DownloadStatus",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "DownloadStatus",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "DownloadStatus",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "DownloadFormat",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "DownloadStatus",
        "importPath": "enums",
        "description": "enums",
        "isExtraImport": true,
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "FileRenamer",
        "importPath": "utils.file_renamer",
        "description": "utils.file_renamer",
        "isExtraImport": true,
        "detail": "utils.file_renamer",
        "documentation": {}
    },
    {
        "label": "FileRenamer",
        "importPath": "utils.file_renamer",
        "description": "utils.file_renamer",
        "isExtraImport": true,
        "detail": "utils.file_renamer",
        "documentation": {}
    },
    {
        "label": "FileRenamer",
        "importPath": "utils.file_renamer",
        "description": "utils.file_renamer",
        "isExtraImport": true,
        "detail": "utils.file_renamer",
        "documentation": {}
    },
    {
        "label": "MetadataHandler",
        "importPath": "utils.metadata_handler",
        "description": "utils.metadata_handler",
        "isExtraImport": true,
        "detail": "utils.metadata_handler",
        "documentation": {}
    },
    {
        "label": "MetadataHandler",
        "importPath": "utils.metadata_handler",
        "description": "utils.metadata_handler",
        "isExtraImport": true,
        "detail": "utils.metadata_handler",
        "documentation": {}
    },
    {
        "label": "MetadataHandler",
        "importPath": "utils.metadata_handler",
        "description": "utils.metadata_handler",
        "isExtraImport": true,
        "detail": "utils.metadata_handler",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "RateLimiter",
        "importPath": "utils.rate_limiter",
        "description": "utils.rate_limiter",
        "isExtraImport": true,
        "detail": "utils.rate_limiter",
        "documentation": {}
    },
    {
        "label": "RateLimiter",
        "importPath": "utils.rate_limiter",
        "description": "utils.rate_limiter",
        "isExtraImport": true,
        "detail": "utils.rate_limiter",
        "documentation": {}
    },
    {
        "label": "keyboard_handler",
        "importPath": "utils.keyboard_handler",
        "description": "utils.keyboard_handler",
        "isExtraImport": true,
        "detail": "utils.keyboard_handler",
        "documentation": {}
    },
    {
        "label": "keyboard_handler",
        "importPath": "utils.keyboard_handler",
        "description": "utils.keyboard_handler",
        "isExtraImport": true,
        "detail": "utils.keyboard_handler",
        "documentation": {}
    },
    {
        "label": "LiveStreamRecorder",
        "importPath": "utils.live_stream_recorder",
        "description": "utils.live_stream_recorder",
        "isExtraImport": true,
        "detail": "utils.live_stream_recorder",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "Progress",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "SpinnerColumn",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "TextColumn",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "BarColumn",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "TaskProgressColumn",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "Progress",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "BarColumn",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "TextColumn",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "TimeRemainingColumn",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "Progress",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "TextColumn",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "BarColumn",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "DownloadColumn",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "TransferSpeedColumn",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "TimeRemainingColumn",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "Progress",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "SpinnerColumn",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "TextColumn",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "Panel",
        "importPath": "rich.panel",
        "description": "rich.panel",
        "isExtraImport": true,
        "detail": "rich.panel",
        "documentation": {}
    },
    {
        "label": "Panel",
        "importPath": "rich.panel",
        "description": "rich.panel",
        "isExtraImport": true,
        "detail": "rich.panel",
        "documentation": {}
    },
    {
        "label": "Panel",
        "importPath": "rich.panel",
        "description": "rich.panel",
        "isExtraImport": true,
        "detail": "rich.panel",
        "documentation": {}
    },
    {
        "label": "Panel",
        "importPath": "rich.panel",
        "description": "rich.panel",
        "isExtraImport": true,
        "detail": "rich.panel",
        "documentation": {}
    },
    {
        "label": "Panel",
        "importPath": "rich.panel",
        "description": "rich.panel",
        "isExtraImport": true,
        "detail": "rich.panel",
        "documentation": {}
    },
    {
        "label": "Panel",
        "importPath": "rich.panel",
        "description": "rich.panel",
        "isExtraImport": true,
        "detail": "rich.panel",
        "documentation": {}
    },
    {
        "label": "Panel",
        "importPath": "rich.panel",
        "description": "rich.panel",
        "isExtraImport": true,
        "detail": "rich.panel",
        "documentation": {}
    },
    {
        "label": "Panel",
        "importPath": "rich.panel",
        "description": "rich.panel",
        "isExtraImport": true,
        "detail": "rich.panel",
        "documentation": {}
    },
    {
        "label": "Panel",
        "importPath": "rich.panel",
        "description": "rich.panel",
        "isExtraImport": true,
        "detail": "rich.panel",
        "documentation": {}
    },
    {
        "label": "Panel",
        "importPath": "rich.panel",
        "description": "rich.panel",
        "isExtraImport": true,
        "detail": "rich.panel",
        "documentation": {}
    },
    {
        "label": "Panel",
        "importPath": "rich.panel",
        "description": "rich.panel",
        "isExtraImport": true,
        "detail": "rich.panel",
        "documentation": {}
    },
    {
        "label": "Panel",
        "importPath": "rich.panel",
        "description": "rich.panel",
        "isExtraImport": true,
        "detail": "rich.panel",
        "documentation": {}
    },
    {
        "label": "Panel",
        "importPath": "rich.panel",
        "description": "rich.panel",
        "isExtraImport": true,
        "detail": "rich.panel",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "rich.table",
        "description": "rich.table",
        "isExtraImport": true,
        "detail": "rich.table",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "rich.table",
        "description": "rich.table",
        "isExtraImport": true,
        "detail": "rich.table",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "rich.table",
        "description": "rich.table",
        "isExtraImport": true,
        "detail": "rich.table",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "rich.table",
        "description": "rich.table",
        "isExtraImport": true,
        "detail": "rich.table",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "rich.table",
        "description": "rich.table",
        "isExtraImport": true,
        "detail": "rich.table",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "rich.table",
        "description": "rich.table",
        "isExtraImport": true,
        "detail": "rich.table",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "rich.table",
        "description": "rich.table",
        "isExtraImport": true,
        "detail": "rich.table",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "rich.table",
        "description": "rich.table",
        "isExtraImport": true,
        "detail": "rich.table",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "rich.table",
        "description": "rich.table",
        "isExtraImport": true,
        "detail": "rich.table",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "rich.table",
        "description": "rich.table",
        "isExtraImport": true,
        "detail": "rich.table",
        "documentation": {}
    },
    {
        "label": "VideoDownloader",
        "importPath": "downloaders.video",
        "description": "downloaders.video",
        "isExtraImport": true,
        "detail": "downloaders.video",
        "documentation": {}
    },
    {
        "label": "AudioDownloader",
        "importPath": "downloaders.audio",
        "description": "downloaders.audio",
        "isExtraImport": true,
        "detail": "downloaders.audio",
        "documentation": {}
    },
    {
        "label": "LiveStreamDownloader",
        "importPath": "downloaders.livestream",
        "description": "downloaders.livestream",
        "isExtraImport": true,
        "detail": "downloaders.livestream",
        "documentation": {}
    },
    {
        "label": "QueueManager",
        "importPath": "managers.queue_manager",
        "description": "managers.queue_manager",
        "isExtraImport": true,
        "detail": "managers.queue_manager",
        "documentation": {}
    },
    {
        "label": "QueueManager",
        "importPath": "managers.queue_manager",
        "description": "managers.queue_manager",
        "isExtraImport": true,
        "detail": "managers.queue_manager",
        "documentation": {}
    },
    {
        "label": "QueueManager",
        "importPath": "managers.queue_manager",
        "description": "managers.queue_manager",
        "isExtraImport": true,
        "detail": "managers.queue_manager",
        "documentation": {}
    },
    {
        "label": "QueueManager",
        "importPath": "managers.queue_manager",
        "description": "managers.queue_manager",
        "isExtraImport": true,
        "detail": "managers.queue_manager",
        "documentation": {}
    },
    {
        "label": "QueueManager",
        "importPath": "managers.queue_manager",
        "description": "managers.queue_manager",
        "isExtraImport": true,
        "detail": "managers.queue_manager",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "Prompt",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "Confirm",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "IntPrompt",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "Prompt",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "Prompt",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "Prompt",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "Prompt",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "Confirm",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "IntPrompt",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "Prompt",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "Confirm",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "IntPrompt",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "Prompt",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "Confirm",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "IntPrompt",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "Prompt",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "Prompt",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "Confirm",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "IntPrompt",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "Prompt",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "Confirm",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "IntPrompt",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "Prompt",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "Prompt",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "Confirm",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "IntPrompt",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "Prompt",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "Confirm",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "Prompt",
        "importPath": "rich.prompt",
        "description": "rich.prompt",
        "isExtraImport": true,
        "detail": "rich.prompt",
        "documentation": {}
    },
    {
        "label": "get_database_connection",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Channel",
        "importPath": "models.channel",
        "description": "models.channel",
        "isExtraImport": true,
        "detail": "models.channel",
        "documentation": {}
    },
    {
        "label": "Channel",
        "importPath": "models.channel",
        "description": "models.channel",
        "isExtraImport": true,
        "detail": "models.channel",
        "documentation": {}
    },
    {
        "label": "Channel",
        "importPath": "models.channel",
        "description": "models.channel",
        "isExtraImport": true,
        "detail": "models.channel",
        "documentation": {}
    },
    {
        "label": "Channel",
        "importPath": "models.channel",
        "description": "models.channel",
        "isExtraImport": true,
        "detail": "models.channel",
        "documentation": {}
    },
    {
        "label": "Channel",
        "importPath": "models.channel",
        "description": "models.channel",
        "isExtraImport": true,
        "detail": "models.channel",
        "documentation": {}
    },
    {
        "label": "Channel",
        "importPath": "models.channel",
        "description": "models.channel",
        "isExtraImport": true,
        "detail": "models.channel",
        "documentation": {}
    },
    {
        "label": "SlackNotifier",
        "importPath": "notifiers.slack",
        "description": "notifiers.slack",
        "isExtraImport": true,
        "detail": "notifiers.slack",
        "documentation": {}
    },
    {
        "label": "EmailNotifier",
        "importPath": "notifiers.email",
        "description": "notifiers.email",
        "isExtraImport": true,
        "detail": "notifiers.email",
        "documentation": {}
    },
    {
        "label": "DailyStats",
        "importPath": "models.daily_stats",
        "description": "models.daily_stats",
        "isExtraImport": true,
        "detail": "models.daily_stats",
        "documentation": {}
    },
    {
        "label": "DailyStats",
        "importPath": "models.daily_stats",
        "description": "models.daily_stats",
        "isExtraImport": true,
        "detail": "models.daily_stats",
        "documentation": {}
    },
    {
        "label": "DailyStats",
        "importPath": "models.daily_stats",
        "description": "models.daily_stats",
        "isExtraImport": true,
        "detail": "models.daily_stats",
        "documentation": {}
    },
    {
        "label": "DownloadAlert",
        "importPath": "models.download_alert",
        "description": "models.download_alert",
        "isExtraImport": true,
        "detail": "models.download_alert",
        "documentation": {}
    },
    {
        "label": "DownloadAlert",
        "importPath": "models.download_alert",
        "description": "models.download_alert",
        "isExtraImport": true,
        "detail": "models.download_alert",
        "documentation": {}
    },
    {
        "label": "DatabaseManager",
        "importPath": "managers.database_manager",
        "description": "managers.database_manager",
        "isExtraImport": true,
        "detail": "managers.database_manager",
        "documentation": {}
    },
    {
        "label": "smtplib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "smtplib",
        "description": "smtplib",
        "detail": "smtplib",
        "documentation": {}
    },
    {
        "label": "MIMEText",
        "importPath": "email.mime.text",
        "description": "email.mime.text",
        "isExtraImport": true,
        "detail": "email.mime.text",
        "documentation": {}
    },
    {
        "label": "MIMEText",
        "importPath": "email.mime.text",
        "description": "email.mime.text",
        "isExtraImport": true,
        "detail": "email.mime.text",
        "documentation": {}
    },
    {
        "label": "MIMEMultipart",
        "importPath": "email.mime.multipart",
        "description": "email.mime.multipart",
        "isExtraImport": true,
        "detail": "email.mime.multipart",
        "documentation": {}
    },
    {
        "label": "Environment",
        "importPath": "jinja2",
        "description": "jinja2",
        "isExtraImport": true,
        "detail": "jinja2",
        "documentation": {}
    },
    {
        "label": "FileSystemLoader",
        "importPath": "jinja2",
        "description": "jinja2",
        "isExtraImport": true,
        "detail": "jinja2",
        "documentation": {}
    },
    {
        "label": "select_autoescape",
        "importPath": "jinja2",
        "description": "jinja2",
        "isExtraImport": true,
        "detail": "jinja2",
        "documentation": {}
    },
    {
        "label": "BaseNotifier",
        "importPath": "notifiers.base",
        "description": "notifiers.base",
        "isExtraImport": true,
        "detail": "notifiers.base",
        "documentation": {}
    },
    {
        "label": "BaseNotifier",
        "importPath": "notifiers.base",
        "description": "notifiers.base",
        "isExtraImport": true,
        "detail": "notifiers.base",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "MonitorManager",
        "importPath": "managers.monitor_manager",
        "description": "managers.monitor_manager",
        "isExtraImport": true,
        "detail": "managers.monitor_manager",
        "documentation": {}
    },
    {
        "label": "MonitorManager",
        "importPath": "managers.monitor_manager",
        "description": "managers.monitor_manager",
        "isExtraImport": true,
        "detail": "managers.monitor_manager",
        "documentation": {}
    },
    {
        "label": "MonitorManager",
        "importPath": "managers.monitor_manager",
        "description": "managers.monitor_manager",
        "isExtraImport": true,
        "detail": "managers.monitor_manager",
        "documentation": {}
    },
    {
        "label": "MonitorManager",
        "importPath": "managers.monitor_manager",
        "description": "managers.monitor_manager",
        "isExtraImport": true,
        "detail": "managers.monitor_manager",
        "documentation": {}
    },
    {
        "label": "PlaylistDownloader",
        "importPath": "downloaders.playlist",
        "description": "downloaders.playlist",
        "isExtraImport": true,
        "detail": "downloaders.playlist",
        "documentation": {}
    },
    {
        "label": "PlaylistDownloader",
        "importPath": "downloaders.playlist",
        "description": "downloaders.playlist",
        "isExtraImport": true,
        "detail": "downloaders.playlist",
        "documentation": {}
    },
    {
        "label": "PlaylistDownloader",
        "importPath": "downloaders.playlist",
        "description": "downloaders.playlist",
        "isExtraImport": true,
        "detail": "downloaders.playlist",
        "documentation": {}
    },
    {
        "label": "PlaylistDownloader",
        "importPath": "downloaders.playlist",
        "description": "downloaders.playlist",
        "isExtraImport": true,
        "detail": "downloaders.playlist",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "mock_open",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "mock_open",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "NonCallableMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "mock_open",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "NonCallableMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "ThreadPoolExecutor",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "as_completed",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "ThreadPoolExecutor",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "ProxyManager",
        "importPath": "proxy_manager",
        "description": "proxy_manager",
        "isExtraImport": true,
        "detail": "proxy_manager",
        "documentation": {}
    },
    {
        "label": "BaseNotifier",
        "importPath": "notifiers.base_notifier",
        "description": "notifiers.base_notifier",
        "isExtraImport": true,
        "detail": "notifiers.base_notifier",
        "documentation": {}
    },
    {
        "label": "ProgressDisplay",
        "importPath": "progress_display",
        "description": "progress_display",
        "isExtraImport": true,
        "detail": "progress_display",
        "documentation": {}
    },
    {
        "label": "Menu",
        "importPath": "menu",
        "description": "menu",
        "isExtraImport": true,
        "detail": "menu",
        "documentation": {}
    },
    {
        "label": "MonitoringMenu",
        "importPath": "monitoring_menu",
        "description": "monitoring_menu",
        "isExtraImport": true,
        "detail": "monitoring_menu",
        "documentation": {}
    },
    {
        "label": "SettingsMenu",
        "importPath": "settings_menu",
        "description": "settings_menu",
        "isExtraImport": true,
        "detail": "settings_menu",
        "documentation": {}
    },
    {
        "label": "SetupWizard",
        "importPath": "setup_wizard",
        "description": "setup_wizard",
        "isExtraImport": true,
        "detail": "setup_wizard",
        "documentation": {}
    },
    {
        "label": "StatsDisplay",
        "importPath": "stats_display",
        "description": "stats_display",
        "isExtraImport": true,
        "detail": "stats_display",
        "documentation": {}
    },
    {
        "label": "StorageMenu",
        "importPath": "storage_menu",
        "description": "storage_menu",
        "isExtraImport": true,
        "detail": "storage_menu",
        "documentation": {}
    },
    {
        "label": "OAuthHandler",
        "importPath": "utils.oauth_handler",
        "description": "utils.oauth_handler",
        "isExtraImport": true,
        "detail": "utils.oauth_handler",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "Live",
        "importPath": "rich.live",
        "description": "rich.live",
        "isExtraImport": true,
        "detail": "rich.live",
        "documentation": {}
    },
    {
        "label": "Text",
        "importPath": "rich.text",
        "description": "rich.text",
        "isExtraImport": true,
        "detail": "rich.text",
        "documentation": {}
    },
    {
        "label": "StorageManager",
        "importPath": "utils.storage_providers",
        "description": "utils.storage_providers",
        "isExtraImport": true,
        "detail": "utils.storage_providers",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "unicodedata",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unicodedata",
        "description": "unicodedata",
        "detail": "unicodedata",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Menu",
        "importPath": "ui.menu",
        "description": "ui.menu",
        "isExtraImport": true,
        "detail": "ui.menu",
        "documentation": {}
    },
    {
        "label": "SetupWizard",
        "importPath": "ui.setup_wizard",
        "description": "ui.setup_wizard",
        "isExtraImport": true,
        "detail": "ui.setup_wizard",
        "documentation": {}
    },
    {
        "label": "ProxyManager",
        "importPath": "managers.proxy_manager",
        "description": "managers.proxy_manager",
        "isExtraImport": true,
        "detail": "managers.proxy_manager",
        "documentation": {}
    },
    {
        "label": "DatabaseSeeder",
        "importPath": "utils.database_seeder",
        "description": "utils.database_seeder",
        "isExtraImport": true,
        "detail": "utils.database_seeder",
        "documentation": {}
    },
    {
        "label": "DatabaseConnection",
        "kind": 6,
        "importPath": "database.base",
        "description": "database.base",
        "peekOfCode": "class DatabaseConnection(ABC):\n    \"\"\"Abstract database connection\"\"\"\n    @abstractmethod\n    @contextmanager\n    def get_connection(self):\n        \"\"\"Get database connection context manager\"\"\"\n        pass\n    @abstractmethod\n    def execute(self, query: str, params: Tuple = ()) -> Any:\n        \"\"\"Execute query and return cursor\"\"\"",
        "detail": "database.base",
        "documentation": {}
    },
    {
        "label": "MySQLConnection",
        "kind": 6,
        "importPath": "database.mysql_connection",
        "description": "database.mysql_connection",
        "peekOfCode": "class MySQLConnection(DatabaseConnection):\n    \"\"\"MySQL database implementation\"\"\"\n    def __init__(self, host: str = \"localhost\", port: int = 3306,\n                 database: str = \"downloader\", user: str = \"root\", \n                 password: str = \"\"):\n        self.config = {\n            'host': host,\n            'port': port,\n            'database': database,\n            'user': user,",
        "detail": "database.mysql_connection",
        "documentation": {}
    },
    {
        "label": "SQLiteConnection",
        "kind": 6,
        "importPath": "database.sqlite_connection",
        "description": "database.sqlite_connection",
        "peekOfCode": "class SQLiteConnection(DatabaseConnection):\n    \"\"\"SQLite database implementation\"\"\"\n    def __init__(self, db_path: str = \"data/downloader.db\"):\n        self.db_path = Path(db_path)\n        self.db_path.parent.mkdir(parents=True, exist_ok=True)\n        self.init_schema()\n    @contextmanager\n    def get_connection(self):\n        \"\"\"Get database connection\"\"\"\n        conn = sqlite3.connect(self.db_path)",
        "detail": "database.sqlite_connection",
        "documentation": {}
    },
    {
        "label": "AudioDownloader",
        "kind": 6,
        "importPath": "downloaders.audio",
        "description": "downloaders.audio",
        "peekOfCode": "class AudioDownloader(BaseDownloader):\n    \"\"\"Handles audio/music downloads\"\"\"\n    def __init__(self):\n        # Get managers internally\n        config_manager = ConfigManager()\n        stats_manager = StatsManager()\n        notification_manager = NotificationManager(config_manager.config)\n        # Initialize base\n        super().__init__(\n            config_manager.config,",
        "detail": "downloaders.audio",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "downloaders.audio",
        "description": "downloaders.audio",
        "peekOfCode": "console = Console()\nclass AudioDownloader(BaseDownloader):\n    \"\"\"Handles audio/music downloads\"\"\"\n    def __init__(self):\n        # Get managers internally\n        config_manager = ConfigManager()\n        stats_manager = StatsManager()\n        notification_manager = NotificationManager(config_manager.config)\n        # Initialize base\n        super().__init__(",
        "detail": "downloaders.audio",
        "documentation": {}
    },
    {
        "label": "BaseDownloader",
        "kind": 6,
        "importPath": "downloaders.base",
        "description": "downloaders.base",
        "peekOfCode": "class BaseDownloader(ABC):\n    \"\"\"Base class for all downloaders\"\"\"\n    def __init__(self, config: AppConfig, stats_manager: StatsManager = None,\n                 notification_manager: NotificationManager = None):\n        self.config = config\n        self.stats_manager = stats_manager\n        self.notification_manager = notification_manager\n        # Initialize rate limiter\n        self.rate_limiter = RateLimiter(\n            max_downloads_per_hour=config.max_downloads_per_hour,",
        "detail": "downloaders.base",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "downloaders.base",
        "description": "downloaders.base",
        "peekOfCode": "console = Console()\nclass BaseDownloader(ABC):\n    \"\"\"Base class for all downloaders\"\"\"\n    def __init__(self, config: AppConfig, stats_manager: StatsManager = None,\n                 notification_manager: NotificationManager = None):\n        self.config = config\n        self.stats_manager = stats_manager\n        self.notification_manager = notification_manager\n        # Initialize rate limiter\n        self.rate_limiter = RateLimiter(",
        "detail": "downloaders.base",
        "documentation": {}
    },
    {
        "label": "LiveStreamDownloader",
        "kind": 6,
        "importPath": "downloaders.livestream",
        "description": "downloaders.livestream",
        "peekOfCode": "class LiveStreamDownloader(BaseDownloader):\n    \"\"\"Handles live stream recording\"\"\"\n    def __init__(self):\n        # Get managers internally\n        config_manager = ConfigManager()\n        stats_manager = StatsManager()\n        notification_manager = NotificationManager(config_manager.config)\n        # Initialize base\n        super().__init__(\n            config_manager.config,",
        "detail": "downloaders.livestream",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "downloaders.livestream",
        "description": "downloaders.livestream",
        "peekOfCode": "console = Console()\nclass LiveStreamDownloader(BaseDownloader):\n    \"\"\"Handles live stream recording\"\"\"\n    def __init__(self):\n        # Get managers internally\n        config_manager = ConfigManager()\n        stats_manager = StatsManager()\n        notification_manager = NotificationManager(config_manager.config)\n        # Initialize base\n        super().__init__(",
        "detail": "downloaders.livestream",
        "documentation": {}
    },
    {
        "label": "PlaylistDownloader",
        "kind": 6,
        "importPath": "downloaders.playlist",
        "description": "downloaders.playlist",
        "peekOfCode": "class PlaylistDownloader(BaseDownloader):\n    \"\"\"Orchestrates playlist downloads using specialized downloaders\"\"\"\n    def __init__(self):\n        # Get managers internally\n        config_manager = ConfigManager()\n        self.stats_manager = StatsManager()\n        self.notification_manager = NotificationManager(config_manager.config)\n        # Initialize base with config\n        super().__init__(\n            config_manager.config,",
        "detail": "downloaders.playlist",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "downloaders.playlist",
        "description": "downloaders.playlist",
        "peekOfCode": "console = Console()\nclass PlaylistDownloader(BaseDownloader):\n    \"\"\"Orchestrates playlist downloads using specialized downloaders\"\"\"\n    def __init__(self):\n        # Get managers internally\n        config_manager = ConfigManager()\n        self.stats_manager = StatsManager()\n        self.notification_manager = NotificationManager(config_manager.config)\n        # Initialize base with config\n        super().__init__(",
        "detail": "downloaders.playlist",
        "documentation": {}
    },
    {
        "label": "VideoDownloader",
        "kind": 6,
        "importPath": "downloaders.video",
        "description": "downloaders.video",
        "peekOfCode": "class VideoDownloader(BaseDownloader):\n    \"\"\"Handles video downloads\"\"\"\n    def __init__(self):\n        # Get managers internally\n        config_manager = ConfigManager()\n        stats_manager = StatsManager()\n        notification_manager = NotificationManager(config_manager.config)\n        # Initialize base\n        super().__init__(\n            config_manager.config,",
        "detail": "downloaders.video",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "downloaders.video",
        "description": "downloaders.video",
        "peekOfCode": "console = Console()\nclass VideoDownloader(BaseDownloader):\n    \"\"\"Handles video downloads\"\"\"\n    def __init__(self):\n        # Get managers internally\n        config_manager = ConfigManager()\n        stats_manager = StatsManager()\n        notification_manager = NotificationManager(config_manager.config)\n        # Initialize base\n        super().__init__(",
        "detail": "downloaders.video",
        "documentation": {}
    },
    {
        "label": "StorageConfig",
        "kind": 6,
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "peekOfCode": "class StorageConfig:\n    \"\"\"Storage provider configuration\"\"\"\n    provider_type: str  # 'ftp', 'sftp', 'gdrive', 'dropbox', 'onedrive'\n    enabled: bool = True\n    host: Optional[str] = None\n    port: Optional[int] = None\n    username: Optional[str] = None\n    password: Optional[str] = None\n    key_filename: Optional[str] = None\n    base_path: Optional[str] = None",
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "AppConfig",
        "kind": 6,
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "peekOfCode": "class AppConfig:\n    \"\"\"Application configuration\"\"\"\n    # Authentication\n    cookies_file: Optional[str] = None\n    oauth_token: Optional[str] = None\n    oauth_refresh_token: Optional[str] = None\n    # Download settings\n    max_workers: int = 3\n    default_video_quality: str = \"720p\"\n    default_audio_quality: str = \"192\"",
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "ConfigManager",
        "kind": 6,
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "peekOfCode": "class ConfigManager:\n    \"\"\"Manages application configuration\"\"\"\n    def __init__(self, config_file: str = \"downloader_config.json\"):\n        self.config_file = Path(config_file)\n        self.config = self.load_config()\n    def load_config(self) -> AppConfig:\n        \"\"\"Load configuration from file\"\"\"\n        if self.config_file.exists():\n            try:\n                with open(self.config_file, 'r') as f:",
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "managers.config_manager",
        "description": "managers.config_manager",
        "peekOfCode": "console = Console()\n@dataclass\nclass StorageConfig:\n    \"\"\"Storage provider configuration\"\"\"\n    provider_type: str  # 'ftp', 'sftp', 'gdrive', 'dropbox', 'onedrive'\n    enabled: bool = True\n    host: Optional[str] = None\n    port: Optional[int] = None\n    username: Optional[str] = None\n    password: Optional[str] = None",
        "detail": "managers.config_manager",
        "documentation": {}
    },
    {
        "label": "DatabaseManager",
        "kind": 6,
        "importPath": "managers.database_manager",
        "description": "managers.database_manager",
        "peekOfCode": "class DatabaseManager:\n    \"\"\"Manages SQLite database operations\"\"\"\n    _instance: Optional[DatabaseConnection] = None\n    _config: dict = {}\n    @classmethod\n    def initialize(cls, db_type: str = \"sqlite\", **kwargs):\n        \"\"\"Initialize database connection\"\"\"\n        if cls._instance is None:\n            cls._config = {'db_type': db_type, **kwargs}\n            cls._instance = get_database_connection(db_type, **kwargs)",
        "detail": "managers.database_manager",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "managers.database_manager",
        "description": "managers.database_manager",
        "peekOfCode": "console = Console()\nclass DatabaseManager:\n    \"\"\"Manages SQLite database operations\"\"\"\n    _instance: Optional[DatabaseConnection] = None\n    _config: dict = {}\n    @classmethod\n    def initialize(cls, db_type: str = \"sqlite\", **kwargs):\n        \"\"\"Initialize database connection\"\"\"\n        if cls._instance is None:\n            cls._config = {'db_type': db_type, **kwargs}",
        "detail": "managers.database_manager",
        "documentation": {}
    },
    {
        "label": "MonitorManager",
        "kind": 6,
        "importPath": "managers.monitor_manager",
        "description": "managers.monitor_manager",
        "peekOfCode": "class MonitorManager:\n    \"\"\"Manages channel monitoring\"\"\"\n    def __init__(self, db_path: str = \"downloads.db\"):\n        self.db_path = Path(db_path)\n        self.is_running = False\n        self.monitor_thread: Optional[threading.Thread] = None\n        self._init_database()\n    def _init_database(self):\n        \"\"\"Initialize monitoring database\"\"\"\n        with sqlite3.connect(self.db_path) as conn:",
        "detail": "managers.monitor_manager",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "managers.monitor_manager",
        "description": "managers.monitor_manager",
        "peekOfCode": "console = Console()\nclass MonitorManager:\n    \"\"\"Manages channel monitoring\"\"\"\n    def __init__(self, db_path: str = \"downloads.db\"):\n        self.db_path = Path(db_path)\n        self.is_running = False\n        self.monitor_thread: Optional[threading.Thread] = None\n        self._init_database()\n    def _init_database(self):\n        \"\"\"Initialize monitoring database\"\"\"",
        "detail": "managers.monitor_manager",
        "documentation": {}
    },
    {
        "label": "NotificationManager",
        "kind": 6,
        "importPath": "managers.notification_manager",
        "description": "managers.notification_manager",
        "peekOfCode": "class NotificationManager:\n    \"\"\"Manages all notification providers\"\"\"\n    def __init__(self, config: AppConfig):\n        self.config = config\n        self.slack = None\n        self.email = None\n        # Initialize enabled notifiers\n        self._initialize_notifiers()\n    def _initialize_notifiers(self):\n        \"\"\"Initialize all configured notifiers\"\"\"",
        "detail": "managers.notification_manager",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "managers.notification_manager",
        "description": "managers.notification_manager",
        "peekOfCode": "console = Console()\nclass NotificationManager:\n    \"\"\"Manages all notification providers\"\"\"\n    def __init__(self, config: AppConfig):\n        self.config = config\n        self.slack = None\n        self.email = None\n        # Initialize enabled notifiers\n        self._initialize_notifiers()\n    def _initialize_notifiers(self):",
        "detail": "managers.notification_manager",
        "documentation": {}
    },
    {
        "label": "ProxyManager",
        "kind": 6,
        "importPath": "managers.proxy_manager",
        "description": "managers.proxy_manager",
        "peekOfCode": "class ProxyManager:\n    \"\"\"Manages proxy rotation\"\"\"\n    def __init__(self):\n        # Get config internally\n        config_manager = ConfigManager()\n        self.proxies: List[str] = config_manager.config.proxies.copy()\n        self.current_index = 0\n    def get_next_proxy(self) -> Optional[str]:\n        \"\"\"Get next proxy in rotation\"\"\"\n        if not self.proxies:",
        "detail": "managers.proxy_manager",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "managers.proxy_manager",
        "description": "managers.proxy_manager",
        "peekOfCode": "console = Console()\nclass ProxyManager:\n    \"\"\"Manages proxy rotation\"\"\"\n    def __init__(self):\n        # Get config internally\n        config_manager = ConfigManager()\n        self.proxies: List[str] = config_manager.config.proxies.copy()\n        self.current_index = 0\n    def get_next_proxy(self) -> Optional[str]:\n        \"\"\"Get next proxy in rotation\"\"\"",
        "detail": "managers.proxy_manager",
        "documentation": {}
    },
    {
        "label": "QueueManager",
        "kind": 6,
        "importPath": "managers.queue_manager",
        "description": "managers.queue_manager",
        "peekOfCode": "class QueueManager:\n    \"\"\"Manages download queues with resume support\"\"\"\n    def __init__(self, db_path: str = \"data/downloads.db\"):\n        self.db_path = db_path\n        self.resume_file = Path(\"data/resume_info.json\")\n        self.resume_file.parent.mkdir(parents=True, exist_ok=True)\n        self._init_database()\n        self.resume_data = self._load_resume_data()\n    def _init_database(self):\n        \"\"\"Initialize database tables\"\"\"",
        "detail": "managers.queue_manager",
        "documentation": {}
    },
    {
        "label": "DownloadStats",
        "kind": 6,
        "importPath": "managers.stats_manager",
        "description": "managers.stats_manager",
        "peekOfCode": "class DownloadStats:\n    \"\"\"Download statistics data\"\"\"\n    date: str\n    total_downloads: int = 0\n    successful_downloads: int = 0\n    failed_downloads: int = 0\n    total_file_size_bytes: int = 0\n    total_duration_seconds: float = 0.0\n    queues_completed: int = 0\nclass StatsManager:",
        "detail": "managers.stats_manager",
        "documentation": {}
    },
    {
        "label": "StatsManager",
        "kind": 6,
        "importPath": "managers.stats_manager",
        "description": "managers.stats_manager",
        "peekOfCode": "class StatsManager:\n    \"\"\"Manages download statistics\"\"\"\n    def __init__(self, db_path: str = \"stats.db\"):\n        self.db_path = Path(db_path)\n        self._init_database()\n    def _init_database(self):\n        \"\"\"Initialize statistics database\"\"\"\n        with sqlite3.connect(self.db_path) as conn:\n            cursor = conn.cursor()\n            cursor.execute(\"\"\"",
        "detail": "managers.stats_manager",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "managers.stats_manager",
        "description": "managers.stats_manager",
        "peekOfCode": "console = Console()\n@dataclass\nclass DownloadStats:\n    \"\"\"Download statistics data\"\"\"\n    date: str\n    total_downloads: int = 0\n    successful_downloads: int = 0\n    failed_downloads: int = 0\n    total_file_size_bytes: int = 0\n    total_duration_seconds: float = 0.0",
        "detail": "managers.stats_manager",
        "documentation": {}
    },
    {
        "label": "Channel",
        "kind": 6,
        "importPath": "models.channel",
        "description": "models.channel",
        "peekOfCode": "class Channel:\n    \"\"\"Channel model\"\"\"\n    id: Optional[int]\n    url: str\n    title: str\n    description: Optional[str] = None\n    is_monitored: bool = False\n    check_interval_minutes: int = 1440  # 24 hours\n    last_checked_at: Optional[str] = None\n    format_type: str = \"video\"",
        "detail": "models.channel",
        "documentation": {}
    },
    {
        "label": "DailyStats",
        "kind": 6,
        "importPath": "models.daily_stats",
        "description": "models.daily_stats",
        "peekOfCode": "class DailyStats:\n    \"\"\"Statistics for a single day\"\"\"\n    id: Optional[int]\n    date: str\n    videos_downloaded: int = 0\n    videos_queued: int = 0\n    videos_failed: int = 0\n    total_download_time_seconds: float = 0\n    total_file_size_bytes: int = 0\n    queues_created: int = 0",
        "detail": "models.daily_stats",
        "documentation": {}
    },
    {
        "label": "DownloadAlert",
        "kind": 6,
        "importPath": "models.download_alert",
        "description": "models.download_alert",
        "peekOfCode": "class DownloadAlert:\n    \"\"\"Represents a download size alert threshold\"\"\"\n    id: Optional[int]\n    threshold_bytes: int\n    last_alert_date: Optional[str] = None\n    total_size_at_alert: int = 0\n    def to_dict(self):\n        \"\"\"Convert to dictionary\"\"\"\n        return asdict(self)\n    @classmethod",
        "detail": "models.download_alert",
        "documentation": {}
    },
    {
        "label": "DownloadItem",
        "kind": 6,
        "importPath": "models.download_item",
        "description": "models.download_item",
        "peekOfCode": "class DownloadItem:\n    \"\"\"Represents a single download item\"\"\"\n    id: Optional[int]\n    queue_id: str\n    url: str\n    title: str\n    status: str\n    file_path: Optional[str] = None\n    error: Optional[str] = None\n    file_hash: Optional[str] = None",
        "detail": "models.download_item",
        "documentation": {}
    },
    {
        "label": "Queue",
        "kind": 6,
        "importPath": "models.queue",
        "description": "models.queue",
        "peekOfCode": "class Queue:\n    \"\"\"Represents a download queue for a playlist\"\"\"\n    id: Optional[int]\n    playlist_url: str\n    playlist_title: str\n    format_type: str  # 'video' or 'audio'\n    quality: str\n    output_dir: str\n    download_order: str  # 'original', 'newest_first', 'oldest_first'\n    filename_template: Optional[str] = None",
        "detail": "models.queue",
        "documentation": {}
    },
    {
        "label": "BaseNotifier",
        "kind": 6,
        "importPath": "notifiers.base",
        "description": "notifiers.base",
        "peekOfCode": "class BaseNotifier(ABC):\n    \"\"\"Abstract base class for all notifiers\"\"\"\n    def __init__(self, enabled: bool = True):\n        self.enabled = enabled\n    def is_configured(self) -> bool:\n        \"\"\"Check if notifier is properly configured\"\"\"\n        return self.enabled\n    @abstractmethod\n    def send_notification(self, title: str, message: str, **kwargs) -> bool:\n        \"\"\"Send a basic notification - must be implemented by subclasses\"\"\"",
        "detail": "notifiers.base",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "notifiers.base",
        "description": "notifiers.base",
        "peekOfCode": "console = Console()\nclass BaseNotifier(ABC):\n    \"\"\"Abstract base class for all notifiers\"\"\"\n    def __init__(self, enabled: bool = True):\n        self.enabled = enabled\n    def is_configured(self) -> bool:\n        \"\"\"Check if notifier is properly configured\"\"\"\n        return self.enabled\n    @abstractmethod\n    def send_notification(self, title: str, message: str, **kwargs) -> bool:",
        "detail": "notifiers.base",
        "documentation": {}
    },
    {
        "label": "EmailNotifier",
        "kind": 6,
        "importPath": "notifiers.email",
        "description": "notifiers.email",
        "peekOfCode": "class EmailNotifier(BaseNotifier):\n    \"\"\"Sends email notifications via SMTP\"\"\"\n    def __init__(self, smtp_host: str = None, smtp_port: int = 587,\n                 smtp_username: str = None, smtp_password: str = None,\n                 from_email: str = None, to_emails: list = None,\n                 use_tls: bool = True):\n        super().__init__(enabled=bool(smtp_host and from_email and to_emails))\n        self.smtp_host = smtp_host\n        self.smtp_port = smtp_port\n        self.smtp_username = smtp_username",
        "detail": "notifiers.email",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "notifiers.email",
        "description": "notifiers.email",
        "peekOfCode": "console = Console()\nclass EmailNotifier(BaseNotifier):\n    \"\"\"Sends email notifications via SMTP\"\"\"\n    def __init__(self, smtp_host: str = None, smtp_port: int = 587,\n                 smtp_username: str = None, smtp_password: str = None,\n                 from_email: str = None, to_emails: list = None,\n                 use_tls: bool = True):\n        super().__init__(enabled=bool(smtp_host and from_email and to_emails))\n        self.smtp_host = smtp_host\n        self.smtp_port = smtp_port",
        "detail": "notifiers.email",
        "documentation": {}
    },
    {
        "label": "SlackNotifier",
        "kind": 6,
        "importPath": "notifiers.slack",
        "description": "notifiers.slack",
        "peekOfCode": "class SlackNotifier(BaseNotifier):\n    \"\"\"Sends notifications to Slack\"\"\"\n    def __init__(self, webhook_url: Optional[str] = None):\n        super().__init__(enabled=bool(webhook_url))\n        self.webhook_url = webhook_url\n    def is_configured(self) -> bool:\n        \"\"\"Check if Slack webhook is configured\"\"\"\n        return bool(self.webhook_url)\n    def send_notification(self, title: str, message: str, **kwargs) -> bool:\n        \"\"\"Send notification to Slack\"\"\"",
        "detail": "notifiers.slack",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "notifiers.slack",
        "description": "notifiers.slack",
        "peekOfCode": "console = Console()\nclass SlackNotifier(BaseNotifier):\n    \"\"\"Sends notifications to Slack\"\"\"\n    def __init__(self, webhook_url: Optional[str] = None):\n        super().__init__(enabled=bool(webhook_url))\n        self.webhook_url = webhook_url\n    def is_configured(self) -> bool:\n        \"\"\"Check if Slack webhook is configured\"\"\"\n        return bool(self.webhook_url)\n    def send_notification(self, title: str, message: str, **kwargs) -> bool:",
        "detail": "notifiers.slack",
        "documentation": {}
    },
    {
        "label": "CronJob",
        "kind": 6,
        "importPath": "scripts.cron",
        "description": "scripts.cron",
        "peekOfCode": "class CronJob:\n    \"\"\"Automated cron job handler\"\"\"\n    def __init__(self, log_file: str = \"logs/cron.log\"):\n        \"\"\"Initialize cron job\"\"\"\n        self.log_file = Path(log_file)\n        self.log_file.parent.mkdir(parents=True, exist_ok=True)\n        # Initialize managers\n        self.config_manager = ConfigManager()\n        self.monitor_manager = MonitorManager()\n        self.queue_manager = QueueManager()",
        "detail": "scripts.cron",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.cron",
        "description": "scripts.cron",
        "peekOfCode": "def main():\n    \"\"\"Main entry point\"\"\"\n    parser = argparse.ArgumentParser(\n        description='Automated cron job for YouTube Playlist Downloader'\n    )\n    parser.add_argument(\n        '--no-check',\n        action='store_true',\n        help='Skip checking monitored channels'\n    )",
        "detail": "scripts.cron",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "scripts.cron",
        "description": "scripts.cron",
        "peekOfCode": "console = Console()\nclass CronJob:\n    \"\"\"Automated cron job handler\"\"\"\n    def __init__(self, log_file: str = \"logs/cron.log\"):\n        \"\"\"Initialize cron job\"\"\"\n        self.log_file = Path(log_file)\n        self.log_file.parent.mkdir(parents=True, exist_ok=True)\n        # Initialize managers\n        self.config_manager = ConfigManager()\n        self.monitor_manager = MonitorManager()",
        "detail": "scripts.cron",
        "documentation": {}
    },
    {
        "label": "generate_daily_summary",
        "kind": 2,
        "importPath": "scripts.send_daily_summary",
        "description": "scripts.send_daily_summary",
        "peekOfCode": "def generate_daily_summary():\n    \"\"\"Generate and send daily summary\"\"\"\n    console.print(\"[cyan]Generating daily summary...[/cyan]\")\n    # Initialize managers\n    config_manager = ConfigManager()\n    stats_manager = StatsManager()\n    notification_manager = NotificationManager(config_manager.config)\n    if not notification_manager.email or not notification_manager.email.is_configured():\n        console.print(\"[yellow]Email notifications not configured[/yellow]\")\n        return",
        "detail": "scripts.send_daily_summary",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "scripts.send_daily_summary",
        "description": "scripts.send_daily_summary",
        "peekOfCode": "console = Console()\ndef generate_daily_summary():\n    \"\"\"Generate and send daily summary\"\"\"\n    console.print(\"[cyan]Generating daily summary...[/cyan]\")\n    # Initialize managers\n    config_manager = ConfigManager()\n    stats_manager = StatsManager()\n    notification_manager = NotificationManager(config_manager.config)\n    if not notification_manager.email or not notification_manager.email.is_configured():\n        console.print(\"[yellow]Email notifications not configured[/yellow]\")",
        "detail": "scripts.send_daily_summary",
        "documentation": {}
    },
    {
        "label": "generate_weekly_stats",
        "kind": 2,
        "importPath": "scripts.send_weekly_stats",
        "description": "scripts.send_weekly_stats",
        "peekOfCode": "def generate_weekly_stats():\n    \"\"\"Generate and send weekly statistics\"\"\"\n    console.print(\"[cyan]Generating weekly statistics...[/cyan]\")\n    # Initialize managers\n    config_manager = ConfigManager()\n    stats_manager = StatsManager()\n    notification_manager = NotificationManager(config_manager.config)\n    if not notification_manager.email or not notification_manager.email.is_configured():\n        console.print(\"[yellow]Email notifications not configured[/yellow]\")\n        return",
        "detail": "scripts.send_weekly_stats",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "scripts.send_weekly_stats",
        "description": "scripts.send_weekly_stats",
        "peekOfCode": "console = Console()\ndef generate_weekly_stats():\n    \"\"\"Generate and send weekly statistics\"\"\"\n    console.print(\"[cyan]Generating weekly statistics...[/cyan]\")\n    # Initialize managers\n    config_manager = ConfigManager()\n    stats_manager = StatsManager()\n    notification_manager = NotificationManager(config_manager.config)\n    if not notification_manager.email or not notification_manager.email.is_configured():\n        console.print(\"[yellow]Email notifications not configured[/yellow]\")",
        "detail": "scripts.send_weekly_stats",
        "documentation": {}
    },
    {
        "label": "mock_config",
        "kind": 2,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "def mock_config():\n    \"\"\"Mock configuration object.\"\"\"\n    config = MagicMock()\n    config.proxies = [\"http://proxy1.com\"]\n    config.cookies_file = \"/path/to/cookies.txt\"\n    config.download_timeout_minutes = 10\n    config.max_workers = 3\n    config.alert_thresholds_mb = [1024]\n    return config\n@pytest.fixture",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "mock_managers",
        "kind": 2,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "def mock_managers():\n    \"\"\"Mock dependency managers.\"\"\"\n    return {\n        'stats': MagicMock(spec=StatsManager),\n        'slack': MagicMock(spec=SlackNotifier),\n        'queue': MagicMock(spec=QueueManager)\n    }\n@pytest.fixture\ndef mock_downloader(mock_config, mock_managers):\n    \"\"\"Instantiate PlaylistDownloader with mocks.\"\"\"",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "mock_downloader",
        "kind": 2,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "def mock_downloader(mock_config, mock_managers):\n    \"\"\"Instantiate PlaylistDownloader with mocks.\"\"\"\n    downloader = PlaylistDownloader(\n        config=mock_config,\n        stats_manager=mock_managers['stats'],\n        slack_notifier=mock_managers['slack']\n    )\n    # Mock proxy manager methods used internally\n    downloader.proxy_manager = MagicMock(spec=ProxyManager)\n    downloader.proxy_manager.get_random_proxy.return_value = \"http://random:8080\"",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "mock_queue",
        "kind": 2,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "def mock_queue():\n    \"\"\"Mock Queue object.\"\"\"\n    return Queue(\n        id=1,\n        playlist_url=\"https://example.com/p\",\n        playlist_title=\"Test Playlist\",\n        format_type=\"video\",\n        quality=\"720p\",\n        output_dir=\"/tmp/downloads\",\n        download_order=\"original\",",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "mock_item",
        "kind": 2,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "def mock_item():\n    \"\"\"Mock DownloadItem object.\"\"\"\n    return DownloadItem(\n        id=101,\n        queue_id=\"1\",\n        url=\"https://example.com/v\",\n        title=\"Test Video\",\n        status=DownloadStatus.PENDING.value,\n        uploader=\"Uploader\",\n        upload_date=\"2025-01-01\",",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "mock_ydl_info_success",
        "kind": 2,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "def mock_ydl_info_success():\n    \"\"\"Mock yt-dlp successful info dictionary.\"\"\"\n    return {\n        'id': 'vid123',\n        'title': 'Test Video Title',\n        'uploader': 'Test Uploader',\n        'entries': [\n            {'title': 'Video 1', 'url': 'url1', '_type': 'url'},\n            {'title': 'Video 2', 'url': 'url2', '_type': 'url'},\n        ]",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "mock_ydl_download_info",
        "kind": 2,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "def mock_ydl_download_info(mock_item):\n    \"\"\"Mock yt-dlp info dict returned after a successful download.\"\"\"\n    return {\n        'filepath': f\"{mock_queue.output_dir}/001 - {mock_item.title}.mp4\",\n        'title': mock_item.title,\n        'id': mock_item.video_id,\n        'uploader': mock_item.uploader,\n        'upload_date': mock_item.upload_date,\n    }\n# --- Tests ---",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "test_check_ffmpeg_found",
        "kind": 2,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "def test_check_ffmpeg_found(mock_which, mock_downloader):\n    \"\"\"Test check_ffmpeg returns True if found.\"\"\"\n    assert mock_downloader.check_ffmpeg() is True\n    mock_which.assert_called_once_with('ffmpeg')\n@patch('shutil.which', return_value=None)\ndef test_check_ffmpeg_not_found(mock_which, mock_downloader, capsys):\n    \"\"\"Test check_ffmpeg returns False if not found and prints error.\"\"\"\n    assert mock_downloader.check_ffmpeg() is False\n    assert \"FFmpeg not found!\" in capsys.readouterr().out\ndef test_get_base_ydl_opts_no_proxy(mock_downloader, mock_config):",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "test_check_ffmpeg_not_found",
        "kind": 2,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "def test_check_ffmpeg_not_found(mock_which, mock_downloader, capsys):\n    \"\"\"Test check_ffmpeg returns False if not found and prints error.\"\"\"\n    assert mock_downloader.check_ffmpeg() is False\n    assert \"FFmpeg not found!\" in capsys.readouterr().out\ndef test_get_base_ydl_opts_no_proxy(mock_downloader, mock_config):\n    \"\"\"Test ydl options when proxy is disabled.\"\"\"\n    opts = mock_downloader.get_base_ydl_opts(use_proxy=False)\n    assert opts['cookiefile'] == mock_config.cookies_file\n    assert 'proxy' not in opts\n    assert opts['socket_timeout'] == 600 # 10 minutes",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "test_get_base_ydl_opts_no_proxy",
        "kind": 2,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "def test_get_base_ydl_opts_no_proxy(mock_downloader, mock_config):\n    \"\"\"Test ydl options when proxy is disabled.\"\"\"\n    opts = mock_downloader.get_base_ydl_opts(use_proxy=False)\n    assert opts['cookiefile'] == mock_config.cookies_file\n    assert 'proxy' not in opts\n    assert opts['socket_timeout'] == 600 # 10 minutes\ndef test_get_base_ydl_opts_with_proxy(mock_downloader):\n    \"\"\"Test ydl options when proxy is enabled and available.\"\"\"\n    opts = mock_downloader.get_base_ydl_opts(use_proxy=True)\n    mock_downloader.proxy_manager.get_random_proxy.assert_called_once()",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "test_get_base_ydl_opts_with_proxy",
        "kind": 2,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "def test_get_base_ydl_opts_with_proxy(mock_downloader):\n    \"\"\"Test ydl options when proxy is enabled and available.\"\"\"\n    opts = mock_downloader.get_base_ydl_opts(use_proxy=True)\n    mock_downloader.proxy_manager.get_random_proxy.assert_called_once()\n    assert opts['proxy'] == \"http://random:8080\"\n@patch('yt_dlp.YoutubeDL')\ndef test_get_playlist_info_success(mock_ydl_class, mock_downloader, mock_ydl_info_success):\n    \"\"\"Test successful playlist info extraction.\"\"\"\n    mock_ydl_instance = mock_ydl_class.return_value.__enter__.return_value\n    mock_ydl_instance.extract_info.return_value = mock_ydl_info_success",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "test_get_playlist_info_success",
        "kind": 2,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "def test_get_playlist_info_success(mock_ydl_class, mock_downloader, mock_ydl_info_success):\n    \"\"\"Test successful playlist info extraction.\"\"\"\n    mock_ydl_instance = mock_ydl_class.return_value.__enter__.return_value\n    mock_ydl_instance.extract_info.return_value = mock_ydl_info_success\n    info = mock_downloader.get_playlist_info(\"url\")\n    assert info['title'] == 'Test Video Title'\n@patch('yt_dlp.YoutubeDL')\ndef test_get_playlist_info_download_error(mock_ydl_class, mock_downloader, capsys):\n    \"\"\"Test handling of yt-dlp DownloadError.\"\"\"\n    mock_ydl_instance = mock_ydl_class.return_value.__enter__.return_value",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "test_get_playlist_info_download_error",
        "kind": 2,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "def test_get_playlist_info_download_error(mock_ydl_class, mock_downloader, capsys):\n    \"\"\"Test handling of yt-dlp DownloadError.\"\"\"\n    mock_ydl_instance = mock_ydl_class.return_value.__enter__.return_value\n    mock_ydl_instance.extract_info.side_effect = mock_yt_dlp.utils.DownloadError(\"Rate limit exceeded\")\n    info = mock_downloader.get_playlist_info(\"url\")\n    assert info is None\n    assert \"Download error: Rate limit exceeded\" in capsys.readouterr().out\n@patch.object(FileRenamer, 'apply_template', return_value=\"001_Test_Video_Title\")\n@patch.object(PlaylistDownloader, '_calculate_file_hash', return_value=\"test_hash\")\n@patch('pathlib.Path.exists', return_value=True)",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "test_download_item_success",
        "kind": 2,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "def test_download_item_success(mock_dt, mock_ydl_class, mock_path_stat, mock_path_exists, mock_hash, mock_renamer, mock_downloader, mock_item, mock_queue, mock_ydl_download_info):\n    \"\"\"Test successful download and stats/alert reporting.\"\"\"\n    # Setup time mocks\n    start_time = datetime(2025, 1, 1, 10, 0, 0)\n    end_time = datetime(2025, 1, 1, 10, 4, 0) # 240 seconds duration\n    mock_dt.now.side_effect = [start_time, end_time, end_time]\n    # Setup yt-dlp mock\n    mock_ydl_instance = mock_ydl_class.return_value.__enter__.return_value\n    mock_ydl_instance.extract_info.return_value = mock_ydl_download_info\n    mock_ydl_instance.prepare_filename.return_value = \"/tmp/downloads/001_Test_Video_Title.mp4\"",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "test_download_item_failure",
        "kind": 2,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "def test_download_item_failure(mock_dt, mock_ydl_class, mock_opts, mock_downloader, mock_item, mock_queue):\n    \"\"\"Test item download failure handling.\"\"\"\n    # Setup time mocks\n    start_time = datetime(2025, 1, 1, 10, 0, 0)\n    end_time = datetime(2025, 1, 1, 10, 1, 0) # 60 seconds duration\n    mock_dt.now.side_effect = [start_time, end_time]\n    # Setup yt-dlp mock to raise an error\n    mock_ydl_instance = mock_ydl_class.return_value.__enter__.return_value\n    mock_ydl_instance.extract_info.side_effect = Exception(\"Network timed out\")\n    # Execute",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "test_download_queue_execution",
        "kind": 2,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "def test_download_queue_execution(mock_executor, mock_download_item, mock_check_duplicates, mock_print_summary, mock_dt, mock_downloader, mock_queue, mock_managers):\n    \"\"\"Test the core queue execution flow.\"\"\"\n    # Setup time mocks\n    start_time = datetime(2025, 1, 1, 10, 0, 0)\n    end_time = datetime(2025, 1, 1, 10, 5, 0)\n    mock_dt.now.side_effect = [start_time, start_time, end_time, end_time] # start time, stuck item reset, complete time, summary time\n    # Setup items\n    item1 = DownloadItem(id=1, queue_id=\"1\", url=\"u1\", title=\"v1\", status=DownloadStatus.PENDING.value)\n    item2 = DownloadItem(id=2, queue_id=\"1\", url=\"u2\", title=\"v2\", status=DownloadStatus.DOWNLOADING.value) # stuck item\n    # Mock queue manager to return items",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "test_sort_items",
        "kind": 2,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "def test_sort_items(mock_downloader, order, expected_titles):\n    \"\"\"Test item sorting logic.\"\"\"\n    item1 = DownloadItem(id=1, queue_id=\"1\", url=\"u1\", title=\"v1\", status=\"P\")\n    item2 = DownloadItem(id=2, queue_id=\"1\", url=\"u2\", title=\"v2\", status=\"P\")\n    # original/oldest_first relies on the input list order\n    items = [item1, item2]\n    sorted_items = mock_downloader._sort_items(items, order)\n    titles = [item.title for item in sorted_items]\n    assert titles == expected_titles\n@pytest.mark.parametrize(\"size, expected_format\", [",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "test__format_size",
        "kind": 2,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "def test__format_size(mock_downloader, size, expected_format):\n    \"\"\"Test size formatting utility.\"\"\"\n    assert mock_downloader._format_size(size) == expected_format\n@pytest.mark.parametrize(\"duration, expected_format\", [\n    (None, \"N/A\"),\n    (59.9, \"59.9s\"),\n    (60.0, \"1m 0s\"),\n    (3599, \"59m 59s\"),\n    (3600, \"1h 0m\"),\n    (7290, \"2h 1m\"), # 2 hours 1 minute 30 seconds",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "test__format_duration",
        "kind": 2,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "def test__format_duration(mock_downloader, duration, expected_format):\n    \"\"\"Test duration formatting utility.\"\"\"\n    assert mock_downloader._format_duration(duration) == expected_format\n@patch.object(PlaylistDownloader, '_calculate_file_hash', side_effect=['hash1', 'hash2', 'hash1'])\n@patch('rich.prompt.Confirm.ask', return_value=True)\n@patch('pathlib.Path.unlink')\n@patch('pathlib.Path.exists', side_effect=[True, True, True])\ndef test__check_duplicates_and_remove(mock_exists, mock_unlink, mock_confirm, mock_hash, mock_downloader):\n    \"\"\"Test duplicate checking logic and removal of files.\"\"\"\n    # Three items, first and third are duplicates",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "test__check_duplicates_and_remove",
        "kind": 2,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "def test__check_duplicates_and_remove(mock_exists, mock_unlink, mock_confirm, mock_hash, mock_downloader):\n    \"\"\"Test duplicate checking logic and removal of files.\"\"\"\n    # Three items, first and third are duplicates\n    item1 = DownloadItem(id=1, queue_id=\"1\", title=\"v1\", status=DownloadStatus.COMPLETED.value, file_path=\"/f1.mp4\", file_hash='hash1')\n    item2 = DownloadItem(id=2, queue_id=\"1\", title=\"v2\", status=DownloadStatus.COMPLETED.value, file_path=\"/f2.mp4\", file_hash='hash2')\n    item3 = DownloadItem(id=3, queue_id=\"1\", title=\"v3\", status=DownloadStatus.COMPLETED.value, file_path=\"/f3.mp4\", file_hash='hash1')\n    # Manually set the hash on items, as mock_hash is only used in download_item\n    item1.file_hash = 'hash1'\n    item2.file_hash = 'hash2'\n    item3.file_hash = 'hash1'",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "mock_yt_dlp",
        "kind": 5,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "mock_yt_dlp = MagicMock()\nmock_yt_dlp.utils.DownloadError = Exception\nmock_yt_dlp.utils.ExtractorError = Exception\n# Patch the import before importing PlaylistDownloader\nwith patch.dict('sys.modules', {'yt_dlp': mock_yt_dlp}):\n    from managers.queue_manager import QueueManager\n    from managers.stats_manager import StatsManager\n    from managers.proxy_manager import ProxyManager\n    from notifiers.slack_notifier import SlackNotifier\n    from utils.file_renamer import FileRenamer",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "mock_yt_dlp.utils.DownloadError",
        "kind": 5,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "mock_yt_dlp.utils.DownloadError = Exception\nmock_yt_dlp.utils.ExtractorError = Exception\n# Patch the import before importing PlaylistDownloader\nwith patch.dict('sys.modules', {'yt_dlp': mock_yt_dlp}):\n    from managers.queue_manager import QueueManager\n    from managers.stats_manager import StatsManager\n    from managers.proxy_manager import ProxyManager\n    from notifiers.slack_notifier import SlackNotifier\n    from utils.file_renamer import FileRenamer\n    from models.download_item import DownloadItem",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "mock_yt_dlp.utils.ExtractorError",
        "kind": 5,
        "importPath": "tests.unit.downloaders.test_playlist_downloader",
        "description": "tests.unit.downloaders.test_playlist_downloader",
        "peekOfCode": "mock_yt_dlp.utils.ExtractorError = Exception\n# Patch the import before importing PlaylistDownloader\nwith patch.dict('sys.modules', {'yt_dlp': mock_yt_dlp}):\n    from managers.queue_manager import QueueManager\n    from managers.stats_manager import StatsManager\n    from managers.proxy_manager import ProxyManager\n    from notifiers.slack_notifier import SlackNotifier\n    from utils.file_renamer import FileRenamer\n    from models.download_item import DownloadItem\n    from models.queue import Queue",
        "detail": "tests.unit.downloaders.test_playlist_downloader",
        "documentation": {}
    },
    {
        "label": "MockConsole",
        "kind": 6,
        "importPath": "tests.unit.managers.test_config_manager",
        "description": "tests.unit.managers.test_config_manager",
        "peekOfCode": "class MockConsole:\n    def print(self, *args, **kwargs):\n        pass\n# --- Setup Fixtures ---\n@pytest.fixture(scope=\"module\", autouse=True)\ndef mock_rich_console():\n    \"\"\"Patches the rich console globally to prevent test output.\"\"\"\n    # Patch the console in the original module's namespace\n    with patch('config_manager.console', MockConsole()):\n        yield",
        "detail": "tests.unit.managers.test_config_manager",
        "documentation": {}
    },
    {
        "label": "mock_rich_console",
        "kind": 2,
        "importPath": "tests.unit.managers.test_config_manager",
        "description": "tests.unit.managers.test_config_manager",
        "peekOfCode": "def mock_rich_console():\n    \"\"\"Patches the rich console globally to prevent test output.\"\"\"\n    # Patch the console in the original module's namespace\n    with patch('config_manager.console', MockConsole()):\n        yield\n@pytest.fixture\ndef mock_path_exists():\n    \"\"\"Fixture to mock Path.exists() for controlling file presence.\"\"\"\n    with patch('pathlib.Path.exists') as mock_exists:\n        yield mock_exists",
        "detail": "tests.unit.managers.test_config_manager",
        "documentation": {}
    },
    {
        "label": "mock_path_exists",
        "kind": 2,
        "importPath": "tests.unit.managers.test_config_manager",
        "description": "tests.unit.managers.test_config_manager",
        "peekOfCode": "def mock_path_exists():\n    \"\"\"Fixture to mock Path.exists() for controlling file presence.\"\"\"\n    with patch('pathlib.Path.exists') as mock_exists:\n        yield mock_exists\n@pytest.fixture\ndef mock_open_json():\n    \"\"\"Fixture to mock the built-in open function and json operations.\"\"\"\n    m = mock_open()\n    with patch('builtins.open', m) as mock_file:\n        yield mock_file, m # Return the mock object and its handler",
        "detail": "tests.unit.managers.test_config_manager",
        "documentation": {}
    },
    {
        "label": "mock_open_json",
        "kind": 2,
        "importPath": "tests.unit.managers.test_config_manager",
        "description": "tests.unit.managers.test_config_manager",
        "peekOfCode": "def mock_open_json():\n    \"\"\"Fixture to mock the built-in open function and json operations.\"\"\"\n    m = mock_open()\n    with patch('builtins.open', m) as mock_file:\n        yield mock_file, m # Return the mock object and its handler\n@pytest.fixture\ndef manager(mock_path_exists, mock_rich_console):\n    \"\"\"Provides a fresh ConfigManager instance for each test.\"\"\"\n    # Ensure config file does not exist by default for a clean slate\n    mock_path_exists.return_value = False",
        "detail": "tests.unit.managers.test_config_manager",
        "documentation": {}
    },
    {
        "label": "manager",
        "kind": 2,
        "importPath": "tests.unit.managers.test_config_manager",
        "description": "tests.unit.managers.test_config_manager",
        "peekOfCode": "def manager(mock_path_exists, mock_rich_console):\n    \"\"\"Provides a fresh ConfigManager instance for each test.\"\"\"\n    # Ensure config file does not exist by default for a clean slate\n    mock_path_exists.return_value = False\n    # Import the real ConfigManager for testing\n    from config_manager import ConfigManager\n    return ConfigManager(config_file=\"test_config.json\")\n# --- Test Data Class Serialization ---\ndef test_storage_config_serialization():\n    from config_manager import StorageConfig",
        "detail": "tests.unit.managers.test_config_manager",
        "documentation": {}
    },
    {
        "label": "test_storage_config_serialization",
        "kind": 2,
        "importPath": "tests.unit.managers.test_config_manager",
        "description": "tests.unit.managers.test_config_manager",
        "peekOfCode": "def test_storage_config_serialization():\n    from config_manager import StorageConfig\n    config_data = {\n        \"enabled\": True, \n        \"provider_type\": \"sftp\", \n        \"host\": \"test.com\", \n        \"port\": 22,\n        \"key_filename\": \"/path/to/key\",\n        \"audio_quality\": \"320\"\n    }",
        "detail": "tests.unit.managers.test_config_manager",
        "documentation": {}
    },
    {
        "label": "test_app_config_serialization",
        "kind": 2,
        "importPath": "tests.unit.managers.test_config_manager",
        "description": "tests.unit.managers.test_config_manager",
        "peekOfCode": "def test_app_config_serialization():\n    from config_manager import AppConfig\n    config_data = {\n        \"cookies_file\": \"/tmp/cookies.txt\",\n        \"max_workers\": 5,\n        \"default_storage\": \"gdrive_backup\",\n        \"storage_providers\": {\"gdrive_backup\": {\"enabled\": True, \"provider_type\": \"gdrive\"}},\n        \"setup_completed\": True,\n        \"proxies\": [\"http://proxy.com\"],\n        \"min_delay_seconds\": 1.5,",
        "detail": "tests.unit.managers.test_config_manager",
        "documentation": {}
    },
    {
        "label": "test_load_config_file_exists",
        "kind": 2,
        "importPath": "tests.unit.managers.test_config_manager",
        "description": "tests.unit.managers.test_config_manager",
        "peekOfCode": "def test_load_config_file_exists(mock_json_load, manager, mock_path_exists, mock_open_json):\n    \"\"\"Test loading a valid config file.\"\"\"\n    mock_path_exists.return_value = True\n    # Mocking a basic dictionary that AppConfig can digest\n    mock_json_load.return_value = {\n        'cookies_file': '/test/cookies.txt', \n        'max_workers': 5, \n        'default_storage': 'local', \n        'storage_providers': {}, \n        'setup_completed': False,",
        "detail": "tests.unit.managers.test_config_manager",
        "documentation": {}
    },
    {
        "label": "test_load_config_file_missing",
        "kind": 2,
        "importPath": "tests.unit.managers.test_config_manager",
        "description": "tests.unit.managers.test_config_manager",
        "peekOfCode": "def test_load_config_file_missing(manager, mock_path_exists):\n    \"\"\"Test loading when no config file is present (should return defaults).\"\"\"\n    mock_path_exists.return_value = False\n    config = manager.load_config()\n    assert config.max_workers == 3  # Default value\n    assert config.default_storage == \"local\"\n    # Ensure the correct type is returned\n    from config_manager import AppConfig\n    assert isinstance(config, AppConfig)\n@patch('json.load')",
        "detail": "tests.unit.managers.test_config_manager",
        "documentation": {}
    },
    {
        "label": "test_load_config_file_corrupt",
        "kind": 2,
        "importPath": "tests.unit.managers.test_config_manager",
        "description": "tests.unit.managers.test_config_manager",
        "peekOfCode": "def test_load_config_file_corrupt(mock_json_load, manager, mock_path_exists, mock_open_json):\n    \"\"\"Test corrupted file loading (should fall back to default config).\"\"\"\n    mock_path_exists.return_value = True\n    # Simulate JSONDecodeError or other file read error\n    mock_json_load.side_effect = json.JSONDecodeError(\"Invalid JSON\", \"doc\", 0)\n    config = manager.load_config()\n    # Should fall back to default config\n    assert config.max_workers == 3\n    from config_manager import AppConfig\n    assert isinstance(config, AppConfig)",
        "detail": "tests.unit.managers.test_config_manager",
        "documentation": {}
    },
    {
        "label": "test_save_config",
        "kind": 2,
        "importPath": "tests.unit.managers.test_config_manager",
        "description": "tests.unit.managers.test_config_manager",
        "peekOfCode": "def test_save_config(mock_json_dump, manager, mock_open_json):\n    \"\"\"Test saving config ensures data is dumped to the correct file.\"\"\"\n    # Modify config\n    manager.config.max_workers = 10\n    manager.save_config()\n    # Verify that open and json.dump were called correctly\n    mock_open_json[1].assert_called_once_with(Path(\"test_config.json\"), 'w', encoding='utf-8')\n    mock_json_dump.assert_called_once()\n    # Check that max_workers was included in the data dumped\n    dump_args, _ = mock_json_dump.call_args",
        "detail": "tests.unit.managers.test_config_manager",
        "documentation": {}
    },
    {
        "label": "test_storage_provider_management",
        "kind": 2,
        "importPath": "tests.unit.managers.test_config_manager",
        "description": "tests.unit.managers.test_config_manager",
        "peekOfCode": "def test_storage_provider_management(manager, mock_open_json):\n    from config_manager import StorageConfig\n    # Setup: Create a mock storage config object\n    mock_storage = StorageConfig(\n        enabled=True, \n        provider_type=\"sftp\", \n        host=\"sftp.example.com\"\n    )\n    mock_storage_2 = StorageConfig(\n        enabled=False, ",
        "detail": "tests.unit.managers.test_config_manager",
        "documentation": {}
    },
    {
        "label": "MockConsole",
        "kind": 6,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "class MockConsole:\n    def print(self, *args, **kwargs):\n        pass\n# Mock the sqlite3.Row object behavior\nclass MockRow:\n    def __init__(self, data):\n        self._data = data\n    def __getitem__(self, key):\n        return self._data[key]\n    def keys(self):",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "MockRow",
        "kind": 6,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "class MockRow:\n    def __init__(self, data):\n        self._data = data\n    def __getitem__(self, key):\n        return self._data[key]\n    def keys(self):\n        return list(self._data.keys())\n# --- Fixtures ---\n@pytest.fixture(scope=\"module\", autouse=True)\ndef mock_rich_console():",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "mock_rich_console",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def mock_rich_console():\n    \"\"\"Patches the rich console globally to prevent test output.\"\"\"\n    # We need to import the class from the source file to patch it correctly\n    with patch('database_manager.console', MockConsole()):\n        yield\n@pytest.fixture\ndef mock_sqlite_cursor():\n    \"\"\"Returns a mock cursor object.\"\"\"\n    cursor = MagicMock(spec=sqlite3.Cursor)\n    # Mocking lastrowid for get_last_insert_id test",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "mock_sqlite_cursor",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def mock_sqlite_cursor():\n    \"\"\"Returns a mock cursor object.\"\"\"\n    cursor = MagicMock(spec=sqlite3.Cursor)\n    # Mocking lastrowid for get_last_insert_id test\n    cursor.lastrowid = 42 \n    return cursor\n@pytest.fixture\ndef mock_sqlite_connection(mock_sqlite_cursor):\n    \"\"\"Returns a mock connection object, linked to the mock cursor.\"\"\"\n    connection = MagicMock(spec=sqlite3.Connection)",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "mock_sqlite_connection",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def mock_sqlite_connection(mock_sqlite_cursor):\n    \"\"\"Returns a mock connection object, linked to the mock cursor.\"\"\"\n    connection = MagicMock(spec=sqlite3.Connection)\n    connection.cursor.return_value = mock_sqlite_cursor\n    return connection\n@pytest.fixture\ndef mock_sqlite3_connect(mock_sqlite_connection):\n    \"\"\"Patches sqlite3.connect to return the mock connection.\"\"\"\n    with patch('sqlite3.connect', return_value=mock_sqlite_connection) as mock_connect:\n        yield mock_connect",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "mock_sqlite3_connect",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def mock_sqlite3_connect(mock_sqlite_connection):\n    \"\"\"Patches sqlite3.connect to return the mock connection.\"\"\"\n    with patch('sqlite3.connect', return_value=mock_sqlite_connection) as mock_connect:\n        yield mock_connect\n@pytest.fixture\ndef db_manager():\n    \"\"\"Provides an uninitialized DatabaseManager instance.\"\"\"\n    from database_manager import DatabaseManager\n    # Use a dummy path for Path object creation\n    return DatabaseManager(db_path=\":memory:\")",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "db_manager",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def db_manager():\n    \"\"\"Provides an uninitialized DatabaseManager instance.\"\"\"\n    from database_manager import DatabaseManager\n    # Use a dummy path for Path object creation\n    return DatabaseManager(db_path=\":memory:\")\n@pytest.fixture\ndef connected_db_manager(db_manager, mock_sqlite3_connect):\n    \"\"\"Provides a DatabaseManager instance that has successfully called connect().\"\"\"\n    db_manager.connect()\n    # The internal connection object is the mock connection",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "connected_db_manager",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def connected_db_manager(db_manager, mock_sqlite3_connect):\n    \"\"\"Provides a DatabaseManager instance that has successfully called connect().\"\"\"\n    db_manager.connect()\n    # The internal connection object is the mock connection\n    return db_manager\n# --- Tests for Connection and Disconnection ---\ndef test_init_sets_db_path():\n    \"\"\"Test initialization sets the correct Path object.\"\"\"\n    from database_manager import DatabaseManager\n    manager = DatabaseManager(db_path=\"test.db\")",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "test_init_sets_db_path",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def test_init_sets_db_path():\n    \"\"\"Test initialization sets the correct Path object.\"\"\"\n    from database_manager import DatabaseManager\n    manager = DatabaseManager(db_path=\"test.db\")\n    assert manager.db_path == Path(\"test.db\")\n    assert manager.connection is None\ndef test_connect_success(db_manager, mock_sqlite3_connect, mock_sqlite_connection):\n    \"\"\"Test successful database connection.\"\"\"\n    result = db_manager.connect()\n    # Assert sqlite3.connect was called with the correct path",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "test_connect_success",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def test_connect_success(db_manager, mock_sqlite3_connect, mock_sqlite_connection):\n    \"\"\"Test successful database connection.\"\"\"\n    result = db_manager.connect()\n    # Assert sqlite3.connect was called with the correct path\n    mock_sqlite3_connect.assert_called_once_with(db_manager.db_path)\n    # Assert row_factory was set\n    assert db_manager.connection.row_factory == sqlite3.Row\n    assert result is True\n@patch('sqlite3.connect', side_effect=sqlite3.Error(\"Connection Failed\"))\ndef test_connect_failure(mock_connect, db_manager):",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "test_connect_failure",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def test_connect_failure(mock_connect, db_manager):\n    \"\"\"Test connection failure handling.\"\"\"\n    result = db_manager.connect()\n    assert db_manager.connection is None\n    assert result is False\ndef test_disconnect(connected_db_manager, mock_sqlite_connection):\n    \"\"\"Test disconnecting closes the connection.\"\"\"\n    connected_db_manager.disconnect()\n    mock_sqlite_connection.close.assert_called_once()\n    assert connected_db_manager.connection is None",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "test_disconnect",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def test_disconnect(connected_db_manager, mock_sqlite_connection):\n    \"\"\"Test disconnecting closes the connection.\"\"\"\n    connected_db_manager.disconnect()\n    mock_sqlite_connection.close.assert_called_once()\n    assert connected_db_manager.connection is None\ndef test_disconnect_when_not_connected(db_manager):\n    \"\"\"Test disconnecting when no connection is active does nothing.\"\"\"\n    # Should not raise an error\n    db_manager.disconnect()\n    assert db_manager.connection is None",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "test_disconnect_when_not_connected",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def test_disconnect_when_not_connected(db_manager):\n    \"\"\"Test disconnecting when no connection is active does nothing.\"\"\"\n    # Should not raise an error\n    db_manager.disconnect()\n    assert db_manager.connection is None\n# --- Tests for create_tables ---\ndef test_create_tables_success(connected_db_manager, mock_sqlite_cursor):\n    \"\"\"Test successful table creation.\"\"\"\n    result = connected_db_manager.create_tables()\n    # Check that execute was called for each table and index",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "test_create_tables_success",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def test_create_tables_success(connected_db_manager, mock_sqlite_cursor):\n    \"\"\"Test successful table creation.\"\"\"\n    result = connected_db_manager.create_tables()\n    # Check that execute was called for each table and index\n    # (Checking the exact number of calls is a good proxy for all DDL)\n    # 5 Tables + 5 Indexes = 10 total execute calls\n    assert mock_sqlite_cursor.execute.call_count == 10\n    # Check for a specific table creation query (sample check)\n    channel_query = mock_sqlite_cursor.execute.call_args_list[0][0][0].strip()\n    assert channel_query.startswith(\"CREATE TABLE IF NOT EXISTS channels\")",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "test_create_tables_calls_connect_if_not_connected",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def test_create_tables_calls_connect_if_not_connected(mock_connect_method, db_manager):\n    \"\"\"Test create_tables calls connect if connection is None.\"\"\"\n    db_manager.create_tables()\n    mock_connect_method.assert_called_once()\ndef test_create_tables_failure(connected_db_manager, mock_sqlite_cursor):\n    \"\"\"Test table creation failure handling.\"\"\"\n    # Simulate a failure on the first execute call\n    mock_sqlite_cursor.execute.side_effect = sqlite3.Error(\"DDL Failure\")\n    result = connected_db_manager.create_tables()\n    # Connection should try to rollback on error",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "test_create_tables_failure",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def test_create_tables_failure(connected_db_manager, mock_sqlite_cursor):\n    \"\"\"Test table creation failure handling.\"\"\"\n    # Simulate a failure on the first execute call\n    mock_sqlite_cursor.execute.side_effect = sqlite3.Error(\"DDL Failure\")\n    result = connected_db_manager.create_tables()\n    # Connection should try to rollback on error\n    connected_db_manager.connection.rollback.assert_called_once()\n    assert result is False\n# --- Tests for DML/DQL Operations ---\ndef test_execute_query_success(connected_db_manager, mock_sqlite_cursor):",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "test_execute_query_success",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def test_execute_query_success(connected_db_manager, mock_sqlite_cursor):\n    \"\"\"Test successful non-returning query execution.\"\"\"\n    query = \"INSERT INTO test VALUES (?, ?)\"\n    params = (\"val1\", 123)\n    result = connected_db_manager.execute_query(query, params)\n    mock_sqlite_cursor.execute.assert_called_once_with(query, params)\n    connected_db_manager.connection.commit.assert_called_once()\n    assert connected_db_manager.connection.rollback.call_count == 0\n    assert result is True\ndef test_execute_query_failure(connected_db_manager, mock_sqlite_cursor):",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "test_execute_query_failure",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def test_execute_query_failure(connected_db_manager, mock_sqlite_cursor):\n    \"\"\"Test query execution failure handling (should rollback).\"\"\"\n    mock_sqlite_cursor.execute.side_effect = sqlite3.Error(\"DML Failure\")\n    result = connected_db_manager.execute_query(\"DELETE FROM test\")\n    connected_db_manager.connection.rollback.assert_called_once()\n    connected_db_manager.connection.commit.call_count == 0\n    assert result is False\ndef test_fetch_one_success(connected_db_manager, mock_sqlite_cursor):\n    \"\"\"Test single row fetch success.\"\"\"\n    mock_sqlite_cursor.fetchone.return_value = MockRow({\"id\": 1, \"name\": \"test\"})",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "test_fetch_one_success",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def test_fetch_one_success(connected_db_manager, mock_sqlite_cursor):\n    \"\"\"Test single row fetch success.\"\"\"\n    mock_sqlite_cursor.fetchone.return_value = MockRow({\"id\": 1, \"name\": \"test\"})\n    query = \"SELECT * FROM test WHERE id=?\"\n    params = (1,)\n    result = connected_db_manager.fetch_one(query, params)\n    mock_sqlite_cursor.execute.assert_called_once_with(query, params)\n    assert result['id'] == 1\n    assert result['name'] == \"test\"\ndef test_fetch_one_failure(connected_db_manager, mock_sqlite_cursor):",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "test_fetch_one_failure",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def test_fetch_one_failure(connected_db_manager, mock_sqlite_cursor):\n    \"\"\"Test single row fetch failure.\"\"\"\n    mock_sqlite_cursor.execute.side_effect = sqlite3.Error(\"DQL Failure\")\n    result = connected_db_manager.fetch_one(\"SELECT * FROM test\")\n    assert result is None\ndef test_fetch_all_success(connected_db_manager, mock_sqlite_cursor):\n    \"\"\"Test multiple row fetch success.\"\"\"\n    mock_data = [\n        MockRow({\"id\": 1}), \n        MockRow({\"id\": 2})",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "test_fetch_all_success",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def test_fetch_all_success(connected_db_manager, mock_sqlite_cursor):\n    \"\"\"Test multiple row fetch success.\"\"\"\n    mock_data = [\n        MockRow({\"id\": 1}), \n        MockRow({\"id\": 2})\n    ]\n    mock_sqlite_cursor.fetchall.return_value = mock_data\n    query = \"SELECT * FROM test\"\n    result: List[MockRow] = connected_db_manager.fetch_all(query)\n    mock_sqlite_cursor.execute.assert_called_once_with(query, ())",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "test_fetch_all_failure",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def test_fetch_all_failure(connected_db_manager, mock_sqlite_cursor):\n    \"\"\"Test multiple row fetch failure.\"\"\"\n    mock_sqlite_cursor.execute.side_effect = sqlite3.Error(\"DQL Failure\")\n    result = connected_db_manager.fetch_all(\"SELECT * FROM test\")\n    assert result == []\ndef test_get_last_insert_id_success(connected_db_manager, mock_sqlite_cursor):\n    \"\"\"Test retrieving the last inserted row ID.\"\"\"\n    result = connected_db_manager.get_last_insert_id()\n    assert result == 42 # Mocked value\ndef test_get_last_insert_id_failure(connected_db_manager, mock_sqlite_cursor):",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "test_get_last_insert_id_success",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def test_get_last_insert_id_success(connected_db_manager, mock_sqlite_cursor):\n    \"\"\"Test retrieving the last inserted row ID.\"\"\"\n    result = connected_db_manager.get_last_insert_id()\n    assert result == 42 # Mocked value\ndef test_get_last_insert_id_failure(connected_db_manager, mock_sqlite_cursor):\n    \"\"\"Test error handling when getting last row ID.\"\"\"\n    # lastrowid raises an AttributeError if called at the wrong time, but we \n    # mock a sqlite3.Error here for testing the specific handler.\n    mock_sqlite_cursor.lastrowid = property(lambda self: (_ for _ in ()).throw(sqlite3.Error))\n    result = connected_db_manager.get_last_insert_id()",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "test_get_last_insert_id_failure",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def test_get_last_insert_id_failure(connected_db_manager, mock_sqlite_cursor):\n    \"\"\"Test error handling when getting last row ID.\"\"\"\n    # lastrowid raises an AttributeError if called at the wrong time, but we \n    # mock a sqlite3.Error here for testing the specific handler.\n    mock_sqlite_cursor.lastrowid = property(lambda self: (_ for _ in ()).throw(sqlite3.Error))\n    result = connected_db_manager.get_last_insert_id()\n    assert result is None\n# --- Tests for Transaction Management ---\ndef test_begin_transaction(connected_db_manager, mock_sqlite_connection):\n    \"\"\"Test begin_transaction executes the BEGIN command.\"\"\"",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "test_begin_transaction",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def test_begin_transaction(connected_db_manager, mock_sqlite_connection):\n    \"\"\"Test begin_transaction executes the BEGIN command.\"\"\"\n    connected_db_manager.begin_transaction()\n    mock_sqlite_connection.execute.assert_called_once_with(\"BEGIN\")\ndef test_commit(connected_db_manager, mock_sqlite_connection):\n    \"\"\"Test commit calls connection.commit().\"\"\"\n    connected_db_manager.commit()\n    mock_sqlite_connection.commit.assert_called_once()\ndef test_rollback(connected_db_manager, mock_sqlite_connection):\n    \"\"\"Test rollback calls connection.rollback().\"\"\"",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "test_commit",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def test_commit(connected_db_manager, mock_sqlite_connection):\n    \"\"\"Test commit calls connection.commit().\"\"\"\n    connected_db_manager.commit()\n    mock_sqlite_connection.commit.assert_called_once()\ndef test_rollback(connected_db_manager, mock_sqlite_connection):\n    \"\"\"Test rollback calls connection.rollback().\"\"\"\n    connected_db_manager.rollback()\n    mock_sqlite_connection.rollback.assert_called_once()\n# Test the safety net connection calls for CRUD when not connected\n@patch('database_manager.DatabaseManager.connect', return_value=True)",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "test_rollback",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def test_rollback(connected_db_manager, mock_sqlite_connection):\n    \"\"\"Test rollback calls connection.rollback().\"\"\"\n    connected_db_manager.rollback()\n    mock_sqlite_connection.rollback.assert_called_once()\n# Test the safety net connection calls for CRUD when not connected\n@patch('database_manager.DatabaseManager.connect', return_value=True)\ndef test_crud_calls_connect_if_not_connected(mock_connect_method, db_manager, mock_sqlite_cursor):\n    \"\"\"Test that DML/DQL methods call connect() if not already connected.\"\"\"\n    # Manager is not connected by default\n    db_manager.execute_query(\"DUMMY\")",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "test_crud_calls_connect_if_not_connected",
        "kind": 2,
        "importPath": "tests.unit.managers.test_database_manager",
        "description": "tests.unit.managers.test_database_manager",
        "peekOfCode": "def test_crud_calls_connect_if_not_connected(mock_connect_method, db_manager, mock_sqlite_cursor):\n    \"\"\"Test that DML/DQL methods call connect() if not already connected.\"\"\"\n    # Manager is not connected by default\n    db_manager.execute_query(\"DUMMY\")\n    db_manager.fetch_one(\"DUMMY\")\n    db_manager.fetch_all(\"DUMMY\")\n    # Connect should have been called three times\n    assert mock_connect_method.call_count == 3",
        "detail": "tests.unit.managers.test_database_manager",
        "documentation": {}
    },
    {
        "label": "MockChannel",
        "kind": 6,
        "importPath": "tests.unit.managers.test_monitor_manager",
        "description": "tests.unit.managers.test_monitor_manager",
        "peekOfCode": "class MockChannel:\n    \"\"\"Mock class to stand in for the models.channel.Channel dataclass.\"\"\"\n    def __init__(self, **kwargs):\n        self.__dict__.update(kwargs)\n        self.id = kwargs.get('id', None)\n        self.url = kwargs.get('url', 'http://test.url')\n        self.check_interval_minutes = kwargs.get('check_interval_minutes', 60)\n    @classmethod\n    def from_row(cls, row_tuple: Tuple[Any, ...]):\n        \"\"\"Mock method for converting a database row into a Channel object.\"\"\"",
        "detail": "tests.unit.managers.test_monitor_manager",
        "documentation": {}
    },
    {
        "label": "MockConsole",
        "kind": 6,
        "importPath": "tests.unit.managers.test_monitor_manager",
        "description": "tests.unit.managers.test_monitor_manager",
        "peekOfCode": "class MockConsole:\n    def print(self, *args, **kwargs):\n        pass\n# --- Fixtures ---\n@pytest.fixture(scope=\"module\", autouse=True)\ndef mock_rich_console():\n    \"\"\"Patches the rich console globally to prevent test output.\"\"\"\n    with patch('monitor_manager.console', MockConsole()):\n        yield\n@pytest.fixture",
        "detail": "tests.unit.managers.test_monitor_manager",
        "documentation": {}
    },
    {
        "label": "mock_rich_console",
        "kind": 2,
        "importPath": "tests.unit.managers.test_monitor_manager",
        "description": "tests.unit.managers.test_monitor_manager",
        "peekOfCode": "def mock_rich_console():\n    \"\"\"Patches the rich console globally to prevent test output.\"\"\"\n    with patch('monitor_manager.console', MockConsole()):\n        yield\n@pytest.fixture\ndef mock_db_manager():\n    \"\"\"Provides a mock DatabaseManager instance.\"\"\"\n    # We use a NonCallableMock to ensure methods are not accidentally called\n    db_manager = NonCallableMock(spec_set=['fetch_one', 'fetch_all', 'execute_query', 'get_last_insert_id'])\n    # Configure defaults for fetch methods",
        "detail": "tests.unit.managers.test_monitor_manager",
        "documentation": {}
    },
    {
        "label": "mock_db_manager",
        "kind": 2,
        "importPath": "tests.unit.managers.test_monitor_manager",
        "description": "tests.unit.managers.test_monitor_manager",
        "peekOfCode": "def mock_db_manager():\n    \"\"\"Provides a mock DatabaseManager instance.\"\"\"\n    # We use a NonCallableMock to ensure methods are not accidentally called\n    db_manager = NonCallableMock(spec_set=['fetch_one', 'fetch_all', 'execute_query', 'get_last_insert_id'])\n    # Configure defaults for fetch methods\n    db_manager.fetch_one.return_value = None\n    db_manager.fetch_all.return_value = []\n    db_manager.get_last_insert_id.return_value = 1\n    return db_manager\n@pytest.fixture",
        "detail": "tests.unit.managers.test_monitor_manager",
        "documentation": {}
    },
    {
        "label": "monitor_manager",
        "kind": 2,
        "importPath": "tests.unit.managers.test_monitor_manager",
        "description": "tests.unit.managers.test_monitor_manager",
        "peekOfCode": "def monitor_manager(mock_db_manager):\n    \"\"\"Provides a MonitorManager instance initialized with the mock DB.\"\"\"\n    # Patch the Channel import\n    with patch('monitor_manager.Channel', new=MockChannel):\n        from monitor_manager import MonitorManager\n        return MonitorManager(db_manager=mock_db_manager)\n# --- Tests for Basic CRUD Operations ---\ndef test_init(monitor_manager, mock_db_manager):\n    \"\"\"Test initialization.\"\"\"\n    assert monitor_manager.db is mock_db_manager",
        "detail": "tests.unit.managers.test_monitor_manager",
        "documentation": {}
    },
    {
        "label": "test_init",
        "kind": 2,
        "importPath": "tests.unit.managers.test_monitor_manager",
        "description": "tests.unit.managers.test_monitor_manager",
        "peekOfCode": "def test_init(monitor_manager, mock_db_manager):\n    \"\"\"Test initialization.\"\"\"\n    assert monitor_manager.db is mock_db_manager\n    assert monitor_manager.is_running is False\n    assert monitor_manager.monitor_thread is None\n# --- Test add_channel (Update Path) ---\ndef test_add_channel_updates_existing(monitor_manager, mock_db_manager):\n    \"\"\"Test adding a channel that already exists should trigger an UPDATE.\"\"\"\n    # Setup mock to simulate existing channel\n    mock_db_manager.fetch_one.return_value = (50,)",
        "detail": "tests.unit.managers.test_monitor_manager",
        "documentation": {}
    },
    {
        "label": "test_add_channel_updates_existing",
        "kind": 2,
        "importPath": "tests.unit.managers.test_monitor_manager",
        "description": "tests.unit.managers.test_monitor_manager",
        "peekOfCode": "def test_add_channel_updates_existing(monitor_manager, mock_db_manager):\n    \"\"\"Test adding a channel that already exists should trigger an UPDATE.\"\"\"\n    # Setup mock to simulate existing channel\n    mock_db_manager.fetch_one.return_value = (50,)\n    channel = MockChannel(id=50)\n    result_id = monitor_manager.add_channel(channel)\n    # 1. Verify check for existing channel was called\n    mock_db_manager.fetch_one.assert_called_once_with(\n        \"SELECT id FROM channels WHERE url = ?\", \n        (channel.url,)",
        "detail": "tests.unit.managers.test_monitor_manager",
        "documentation": {}
    },
    {
        "label": "test_add_channel_inserts_new",
        "kind": 2,
        "importPath": "tests.unit.managers.test_monitor_manager",
        "description": "tests.unit.managers.test_monitor_manager",
        "peekOfCode": "def test_add_channel_inserts_new(monitor_manager, mock_db_manager):\n    \"\"\"Test adding a new channel should trigger an INSERT and return the new ID.\"\"\"\n    # Setup mock to simulate new channel (fetch_one returns None by default)\n    channel = MockChannel(id=None)\n    mock_db_manager.get_last_insert_id.return_value = 101\n    result_id = monitor_manager.add_channel(channel)\n    # 1. Verify check for existing channel was called\n    mock_db_manager.fetch_one.assert_called_once()\n    # 2. Verify INSERT query was executed\n    mock_db_manager.execute_query.assert_called_once()",
        "detail": "tests.unit.managers.test_monitor_manager",
        "documentation": {}
    },
    {
        "label": "test_remove_channel",
        "kind": 2,
        "importPath": "tests.unit.managers.test_monitor_manager",
        "description": "tests.unit.managers.test_monitor_manager",
        "peekOfCode": "def test_remove_channel(monitor_manager, mock_db_manager):\n    \"\"\"Test removing a channel calls the correct DELETE query.\"\"\"\n    channel_id = 99\n    monitor_manager.remove_channel(channel_id)\n    mock_db_manager.execute_query.assert_called_once_with(\n        \"DELETE FROM channels WHERE id = ?\",\n        (channel_id,)\n    )\n# --- Test update_channel ---\ndef test_update_channel(monitor_manager, mock_db_manager):",
        "detail": "tests.unit.managers.test_monitor_manager",
        "documentation": {}
    },
    {
        "label": "test_update_channel",
        "kind": 2,
        "importPath": "tests.unit.managers.test_monitor_manager",
        "description": "tests.unit.managers.test_monitor_manager",
        "peekOfCode": "def test_update_channel(monitor_manager, mock_db_manager):\n    \"\"\"Test updating a channel calls the correct UPDATE query.\"\"\"\n    channel = MockChannel(id=12)\n    monitor_manager.update_channel(channel)\n    mock_db_manager.execute_query.assert_called_once()\n    assert mock_db_manager.execute_query.call_args[0][0].strip().startswith(\"UPDATE channels SET\")\n    assert mock_db_manager.execute_query.call_args[0][1] == channel.prepare_for_update()\n# --- Test Getters ---\ndef test_get_monitored_channels(monitor_manager, mock_db_manager):\n    \"\"\"Test retrieving only monitored and enabled channels.\"\"\"",
        "detail": "tests.unit.managers.test_monitor_manager",
        "documentation": {}
    },
    {
        "label": "test_get_monitored_channels",
        "kind": 2,
        "importPath": "tests.unit.managers.test_monitor_manager",
        "description": "tests.unit.managers.test_monitor_manager",
        "peekOfCode": "def test_get_monitored_channels(monitor_manager, mock_db_manager):\n    \"\"\"Test retrieving only monitored and enabled channels.\"\"\"\n    mock_db_manager.fetch_all.return_value = [(1,), (2,)] # Mock two rows\n    channels = monitor_manager.get_monitored_channels()\n    mock_db_manager.fetch_all.assert_called_once_with(\n        \"SELECT * FROM channels WHERE is_monitored = 1 AND enabled = 1\"\n    )\n    assert len(channels) == 2\n    assert isinstance(channels[0], MockChannel)\n    assert channels[0].id == 1",
        "detail": "tests.unit.managers.test_monitor_manager",
        "documentation": {}
    },
    {
        "label": "test_get_all_channels",
        "kind": 2,
        "importPath": "tests.unit.managers.test_monitor_manager",
        "description": "tests.unit.managers.test_monitor_manager",
        "peekOfCode": "def test_get_all_channels(monitor_manager, mock_db_manager):\n    \"\"\"Test retrieving all channels.\"\"\"\n    mock_db_manager.fetch_all.return_value = [(10,), (11,)]\n    channels = monitor_manager.get_all_channels()\n    mock_db_manager.fetch_all.assert_called_once_with(\n        \"SELECT * FROM channels ORDER BY created_at DESC\"\n    )\n    assert len(channels) == 2\ndef test_get_channel_by_url_found(monitor_manager, mock_db_manager):\n    \"\"\"Test retrieving a channel by URL when found.\"\"\"",
        "detail": "tests.unit.managers.test_monitor_manager",
        "documentation": {}
    },
    {
        "label": "test_get_channel_by_url_found",
        "kind": 2,
        "importPath": "tests.unit.managers.test_monitor_manager",
        "description": "tests.unit.managers.test_monitor_manager",
        "peekOfCode": "def test_get_channel_by_url_found(monitor_manager, mock_db_manager):\n    \"\"\"Test retrieving a channel by URL when found.\"\"\"\n    mock_db_manager.fetch_one.return_value = (33,)\n    test_url = \"http://channel.xyz\"\n    channel = monitor_manager.get_channel_by_url(test_url)\n    mock_db_manager.fetch_one.assert_called_once_with(\n        \"SELECT * FROM channels WHERE url = ?\",\n        (test_url,)\n    )\n    assert isinstance(channel, MockChannel)",
        "detail": "tests.unit.managers.test_monitor_manager",
        "documentation": {}
    },
    {
        "label": "test_get_channel_by_url_not_found",
        "kind": 2,
        "importPath": "tests.unit.managers.test_monitor_manager",
        "description": "tests.unit.managers.test_monitor_manager",
        "peekOfCode": "def test_get_channel_by_url_not_found(monitor_manager, mock_db_manager):\n    \"\"\"Test retrieving a channel by URL when not found.\"\"\"\n    mock_db_manager.fetch_one.return_value = None\n    channel = monitor_manager.get_channel_by_url(\"missing_url\")\n    assert channel is None\n# --- Tests for Monitoring Logic (Threading/Time) ---\n@patch('monitor_manager.threading.Thread')\n@patch('monitor_manager.time.sleep')\ndef test_start_monitoring_starts_thread(mock_sleep, mock_thread, monitor_manager):\n    \"\"\"Test start_monitoring initializes and starts the thread.\"\"\"",
        "detail": "tests.unit.managers.test_monitor_manager",
        "documentation": {}
    },
    {
        "label": "test_start_monitoring_starts_thread",
        "kind": 2,
        "importPath": "tests.unit.managers.test_monitor_manager",
        "description": "tests.unit.managers.test_monitor_manager",
        "peekOfCode": "def test_start_monitoring_starts_thread(mock_sleep, mock_thread, monitor_manager):\n    \"\"\"Test start_monitoring initializes and starts the thread.\"\"\"\n    mock_callback = MagicMock()\n    monitor_manager.start_monitoring(mock_callback)\n    # Verify is_running is set\n    assert monitor_manager.is_running is True\n    # Verify Thread was created with the monitor_loop target and started\n    mock_thread.assert_called_once()\n    assert mock_thread.call_args[1]['daemon'] is True\n    assert monitor_manager.monitor_thread is not None",
        "detail": "tests.unit.managers.test_monitor_manager",
        "documentation": {}
    },
    {
        "label": "test_start_monitoring_already_running",
        "kind": 2,
        "importPath": "tests.unit.managers.test_monitor_manager",
        "description": "tests.unit.managers.test_monitor_manager",
        "peekOfCode": "def test_start_monitoring_already_running(mock_sleep, monitor_manager):\n    \"\"\"Test calling start_monitoring when already running does nothing.\"\"\"\n    mock_callback = MagicMock()\n    monitor_manager.is_running = True\n    monitor_manager.start_monitoring(mock_callback)\n    # Thread should not be created if is_running is True\n    assert monitor_manager.monitor_thread is None\ndef test_stop_monitoring(monitor_manager):\n    \"\"\"Test stop_monitoring sets flag and joins thread.\"\"\"\n    # Simulate a running thread",
        "detail": "tests.unit.managers.test_monitor_manager",
        "documentation": {}
    },
    {
        "label": "test_stop_monitoring",
        "kind": 2,
        "importPath": "tests.unit.managers.test_monitor_manager",
        "description": "tests.unit.managers.test_monitor_manager",
        "peekOfCode": "def test_stop_monitoring(monitor_manager):\n    \"\"\"Test stop_monitoring sets flag and joins thread.\"\"\"\n    # Simulate a running thread\n    mock_thread = MagicMock(spec=threading.Thread)\n    monitor_manager.monitor_thread = mock_thread\n    monitor_manager.is_running = True\n    monitor_manager.stop_monitoring()\n    assert monitor_manager.is_running is False\n    mock_thread.join.assert_called_once_with(timeout=5)\n# --- Test the monitor_loop internal logic ---",
        "detail": "tests.unit.managers.test_monitor_manager",
        "documentation": {}
    },
    {
        "label": "test_monitor_loop_with_channels",
        "kind": 2,
        "importPath": "tests.unit.managers.test_monitor_manager",
        "description": "tests.unit.managers.test_monitor_manager",
        "peekOfCode": "def test_monitor_loop_with_channels(mock_datetime, mock_sleep, mock_get_channels, monitor_manager):\n    \"\"\"Test monitor_loop execution with channels, checking callback and sleep time.\"\"\"\n    # Setup: 2 channels with different check intervals\n    channel_c = MockChannel(check_interval_minutes=10)\n    channel_a = MockChannel(check_interval_minutes=5)\n    mock_get_channels.return_value = [channel_a, channel_c]\n    mock_callback = MagicMock()\n    monitor_manager.is_running = True\n    # Simulate one iteration of the loop by using side_effect to stop it\n    def stop_loop_after_one_run(*args, **kwargs):",
        "detail": "tests.unit.managers.test_monitor_manager",
        "documentation": {}
    },
    {
        "label": "test_monitor_loop_no_channels",
        "kind": 2,
        "importPath": "tests.unit.managers.test_monitor_manager",
        "description": "tests.unit.managers.test_monitor_manager",
        "peekOfCode": "def test_monitor_loop_no_channels(mock_sleep, mock_get_channels, monitor_manager):\n    \"\"\"Test monitor_loop sleep time when no channels are returned.\"\"\"\n    mock_get_channels.return_value = [] # No channels\n    mock_callback = MagicMock()\n    monitor_manager.is_running = True\n    # Simulate one iteration of the loop by using side_effect to stop it\n    def stop_loop_after_one_run(*args, **kwargs):\n        monitor_manager.is_running = False\n    mock_sleep.side_effect = stop_loop_after_one_run\n    # Execute the internal loop function directly",
        "detail": "tests.unit.managers.test_monitor_manager",
        "documentation": {}
    },
    {
        "label": "test_monitor_loop_exception_handling",
        "kind": 2,
        "importPath": "tests.unit.managers.test_monitor_manager",
        "description": "tests.unit.managers.test_monitor_manager",
        "peekOfCode": "def test_monitor_loop_exception_handling(mock_sleep, mock_get_channels, monitor_manager):\n    \"\"\"Test monitor_loop handles exceptions and sleeps for 60s.\"\"\"\n    # Setup: make get_monitored_channels raise an exception\n    mock_get_channels.side_effect = Exception(\"DB Error\")\n    mock_callback = MagicMock()\n    monitor_manager.is_running = True\n    # Simulate one iteration of the loop by using side_effect to stop it\n    def stop_loop_after_one_run(*args, **kwargs):\n        monitor_manager.is_running = False\n    mock_sleep.side_effect = stop_loop_after_one_run",
        "detail": "tests.unit.managers.test_monitor_manager",
        "documentation": {}
    },
    {
        "label": "MockConsole",
        "kind": 6,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "class MockConsole:\n    def print(self, *args, **kwargs):\n        pass\n@pytest.fixture(scope=\"module\", autouse=True)\ndef mock_rich_console():\n    \"\"\"Patches the rich console globally to prevent test output.\"\"\"\n    with patch('proxy_manager.console', MockConsole()):\n        yield\n# Mock the external file paths\n@pytest.fixture",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "mock_rich_console",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def mock_rich_console():\n    \"\"\"Patches the rich console globally to prevent test output.\"\"\"\n    with patch('proxy_manager.console', MockConsole()):\n        yield\n# Mock the external file paths\n@pytest.fixture\ndef mock_path_exists():\n    \"\"\"Patches Path.exists to control which file is 'found'.\"\"\"\n    with patch('proxy_manager.Path.exists') as mock_exists:\n        # Default to False unless explicitly set in a test",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "mock_path_exists",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def mock_path_exists():\n    \"\"\"Patches Path.exists to control which file is 'found'.\"\"\"\n    with patch('proxy_manager.Path.exists') as mock_exists:\n        # Default to False unless explicitly set in a test\n        mock_exists.return_value = False\n        yield mock_exists\n# Mock the Confirmation Prompt for interactive methods\n@pytest.fixture\ndef mock_confirm():\n    \"\"\"Patches rich.prompt.Confirm.ask to provide a default answer.\"\"\"",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "mock_confirm",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def mock_confirm():\n    \"\"\"Patches rich.prompt.Confirm.ask to provide a default answer.\"\"\"\n    with patch('proxy_manager.Confirm.ask') as mock_confirm:\n        yield mock_confirm\n# --- Fixtures ---\n@pytest.fixture\ndef proxy_manager_instance():\n    \"\"\"Provides a fresh ProxyManager instance.\"\"\"\n    return ProxyManager()\n@pytest.fixture",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "proxy_manager_instance",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def proxy_manager_instance():\n    \"\"\"Provides a fresh ProxyManager instance.\"\"\"\n    return ProxyManager()\n@pytest.fixture\ndef initialized_manager():\n    \"\"\"Provides a ProxyManager initialized with a list of proxies.\"\"\"\n    return ProxyManager(proxies=[\"http://1.1.1.1:80\", \"http://2.2.2.2:8080\", \"https://3.3.3.3:443\"])\n# --- Tests for Initialization and Rotation ---\ndef test_init_with_no_proxies():\n    manager = ProxyManager()",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "initialized_manager",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def initialized_manager():\n    \"\"\"Provides a ProxyManager initialized with a list of proxies.\"\"\"\n    return ProxyManager(proxies=[\"http://1.1.1.1:80\", \"http://2.2.2.2:8080\", \"https://3.3.3.3:443\"])\n# --- Tests for Initialization and Rotation ---\ndef test_init_with_no_proxies():\n    manager = ProxyManager()\n    assert manager.proxies == []\n    assert manager.current_index == 0\ndef test_init_with_proxies():\n    proxies = [\"p1\", \"p2\"]",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "test_init_with_no_proxies",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def test_init_with_no_proxies():\n    manager = ProxyManager()\n    assert manager.proxies == []\n    assert manager.current_index == 0\ndef test_init_with_proxies():\n    proxies = [\"p1\", \"p2\"]\n    manager = ProxyManager(proxies=proxies)\n    assert manager.proxies == proxies\n    assert manager.current_index == 0\n# --- Rotation Tests ---",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "test_init_with_proxies",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def test_init_with_proxies():\n    proxies = [\"p1\", \"p2\"]\n    manager = ProxyManager(proxies=proxies)\n    assert manager.proxies == proxies\n    assert manager.current_index == 0\n# --- Rotation Tests ---\ndef test_get_next_proxy_rotation(initialized_manager):\n    assert initialized_manager.get_next_proxy() == \"http://1.1.1.1:80\"\n    assert initialized_manager.get_next_proxy() == \"http://2.2.2.2:8080\"\n    assert initialized_manager.get_next_proxy() == \"https://3.3.3.3:443\"",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "test_get_next_proxy_rotation",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def test_get_next_proxy_rotation(initialized_manager):\n    assert initialized_manager.get_next_proxy() == \"http://1.1.1.1:80\"\n    assert initialized_manager.get_next_proxy() == \"http://2.2.2.2:8080\"\n    assert initialized_manager.get_next_proxy() == \"https://3.3.3.3:443\"\n    # Wrap around\n    assert initialized_manager.get_next_proxy() == \"http://1.1.1.1:80\"\n    assert initialized_manager.current_index == 1\ndef test_get_next_proxy_empty(proxy_manager_instance):\n    assert proxy_manager_instance.get_next_proxy() is None\n@patch('random.choice')",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "test_get_next_proxy_empty",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def test_get_next_proxy_empty(proxy_manager_instance):\n    assert proxy_manager_instance.get_next_proxy() is None\n@patch('random.choice')\ndef test_get_random_proxy(mock_random_choice, initialized_manager):\n    mock_random_choice.return_value = \"https://3.3.3.3:443\"\n    assert initialized_manager.get_random_proxy() == \"https://3.3.3.3:443\"\n    mock_random_choice.assert_called_once_with(initialized_manager.proxies)\ndef test_get_random_proxy_empty(proxy_manager_instance):\n    assert proxy_manager_instance.get_random_proxy() is None\n# --- Tests for Loading Proxies from File (.txt) ---",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "test_get_random_proxy",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def test_get_random_proxy(mock_random_choice, initialized_manager):\n    mock_random_choice.return_value = \"https://3.3.3.3:443\"\n    assert initialized_manager.get_random_proxy() == \"https://3.3.3.3:443\"\n    mock_random_choice.assert_called_once_with(initialized_manager.proxies)\ndef test_get_random_proxy_empty(proxy_manager_instance):\n    assert proxy_manager_instance.get_random_proxy() is None\n# --- Tests for Loading Proxies from File (.txt) ---\ndef test_load_proxies_from_txt_success(proxy_manager_instance, mock_path_exists):\n    mock_path_exists.side_effect = lambda x: x == Path(\"proxies.txt\") # Only proxies.txt exists\n    mock_file_content = \"http://1.1.1.1:80\\n# comment\\n  \\nhttps://2.2.2.2:443\\n\"",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "test_get_random_proxy_empty",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def test_get_random_proxy_empty(proxy_manager_instance):\n    assert proxy_manager_instance.get_random_proxy() is None\n# --- Tests for Loading Proxies from File (.txt) ---\ndef test_load_proxies_from_txt_success(proxy_manager_instance, mock_path_exists):\n    mock_path_exists.side_effect = lambda x: x == Path(\"proxies.txt\") # Only proxies.txt exists\n    mock_file_content = \"http://1.1.1.1:80\\n# comment\\n  \\nhttps://2.2.2.2:443\\n\"\n    with patch(\"builtins.open\", mock_open(read_data=mock_file_content)):\n        result = proxy_manager_instance.load_proxies_from_file()\n    assert result is True\n    assert proxy_manager_instance.proxies == [\"http://1.1.1.1:80\", \"https://2.2.2.2:443\"]",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "test_load_proxies_from_txt_success",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def test_load_proxies_from_txt_success(proxy_manager_instance, mock_path_exists):\n    mock_path_exists.side_effect = lambda x: x == Path(\"proxies.txt\") # Only proxies.txt exists\n    mock_file_content = \"http://1.1.1.1:80\\n# comment\\n  \\nhttps://2.2.2.2:443\\n\"\n    with patch(\"builtins.open\", mock_open(read_data=mock_file_content)):\n        result = proxy_manager_instance.load_proxies_from_file()\n    assert result is True\n    assert proxy_manager_instance.proxies == [\"http://1.1.1.1:80\", \"https://2.2.2.2:443\"]\ndef test_load_proxies_from_txt_file_not_found(proxy_manager_instance, mock_path_exists):\n    # Both files default to not existing\n    result = proxy_manager_instance.load_proxies_from_file()",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "test_load_proxies_from_txt_file_not_found",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def test_load_proxies_from_txt_file_not_found(proxy_manager_instance, mock_path_exists):\n    # Both files default to not existing\n    result = proxy_manager_instance.load_proxies_from_file()\n    assert result is False\n    assert proxy_manager_instance.proxies == []\n@patch(\"builtins.open\", side_effect=IOError(\"Permission denied\"))\ndef test_load_proxies_from_txt_io_error(mock_open_func, proxy_manager_instance, mock_path_exists):\n    mock_path_exists.side_effect = lambda x: x == Path(\"proxies.txt\")\n    result = proxy_manager_instance.load_proxies_from_file()\n    assert result is False",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "test_load_proxies_from_txt_io_error",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def test_load_proxies_from_txt_io_error(mock_open_func, proxy_manager_instance, mock_path_exists):\n    mock_path_exists.side_effect = lambda x: x == Path(\"proxies.txt\")\n    result = proxy_manager_instance.load_proxies_from_file()\n    assert result is False\n    assert proxy_manager_instance.proxies == []\n# --- Tests for Loading Proxies from File (.csv) ---\ndef create_mock_csv_content(data: List[List[str]]) -> str:\n    \"\"\"Helper to create a CSV string from a list of rows.\"\"\"\n    from io import StringIO\n    output = StringIO()",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "create_mock_csv_content",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def create_mock_csv_content(data: List[List[str]]) -> str:\n    \"\"\"Helper to create a CSV string from a list of rows.\"\"\"\n    from io import StringIO\n    output = StringIO()\n    writer = csv.writer(output)\n    writer.writerows(data)\n    return output.getvalue()\ndef test_load_proxies_from_csv_standard_format(proxy_manager_instance, mock_path_exists):\n    mock_path_exists.side_effect = lambda x: x == Path(\"proxies.csv\")\n    csv_data = [",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "test_load_proxies_from_csv_standard_format",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def test_load_proxies_from_csv_standard_format(proxy_manager_instance, mock_path_exists):\n    mock_path_exists.side_effect = lambda x: x == Path(\"proxies.csv\")\n    csv_data = [\n        ['ip', 'port', 'https'],\n        ['4.4.4.4', '8081', 'False'],\n        ['5.5.5.5', '443', 'True'],\n        ['6.6.6.6', '80', '1'], # Test '1' for True\n        ['#7.7.7.7', '90', 'False'] # Should be skipped\n    ]\n    mock_content = create_mock_csv_content(csv_data)",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "test_load_proxies_from_csv_simple_format_fallback",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def test_load_proxies_from_csv_simple_format_fallback(proxy_manager_instance, mock_path_exists):\n    mock_path_exists.side_effect = lambda x: x == Path(\"proxies.csv\")\n    # Simple CSV where header is missing or non-standard, triggering fallback\n    csv_data = [\n        ['http://8.8.8.8:8888'],\n        ['9.9.9.9:9999'], # Should auto-add http://\n        ['socks5://10.10.10.10:1010']\n    ]\n    mock_content = create_mock_csv_content(csv_data)\n    with patch(\"builtins.open\", mock_open(read_data=mock_content)):",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "test_load_proxies_from_csv_removes_duplicates",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def test_load_proxies_from_csv_removes_duplicates(proxy_manager_instance, mock_path_exists):\n    mock_path_exists.side_effect = lambda x: x == Path(\"proxies.csv\")\n    csv_data = [\n        ['ip', 'port', 'https'],\n        ['11.11.11.11', '80', 'False'],\n        ['11.11.11.11', '80', 'False'], # Duplicate\n        ['12.12.12.12', '443', 'True'],\n    ]\n    mock_content = create_mock_csv_content(csv_data)\n    with patch(\"builtins.open\", mock_open(read_data=mock_content)):",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "mock_requests_get",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def mock_requests_get():\n    \"\"\"Patches requests.get and returns the mock object.\"\"\"\n    with patch('requests.get') as mock_get:\n        yield mock_get\ndef create_mock_response(status_code: int) -> MagicMock:\n    \"\"\"Helper to create a mock response object.\"\"\"\n    mock_response = MagicMock()\n    mock_response.status_code = status_code\n    return mock_response\ndef test_validate_proxy_success(proxy_manager_instance, mock_requests_get):",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "create_mock_response",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def create_mock_response(status_code: int) -> MagicMock:\n    \"\"\"Helper to create a mock response object.\"\"\"\n    mock_response = MagicMock()\n    mock_response.status_code = status_code\n    return mock_response\ndef test_validate_proxy_success(proxy_manager_instance, mock_requests_get):\n    mock_requests_get.return_value = create_mock_response(200)\n    proxy = \"http://valid.proxy:8080\"\n    result = proxy_manager_instance.validate_proxy(proxy, timeout=5)\n    assert result is True",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "test_validate_proxy_success",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def test_validate_proxy_success(proxy_manager_instance, mock_requests_get):\n    mock_requests_get.return_value = create_mock_response(200)\n    proxy = \"http://valid.proxy:8080\"\n    result = proxy_manager_instance.validate_proxy(proxy, timeout=5)\n    assert result is True\n    mock_requests_get.assert_called_once()\n    assert mock_requests_get.call_args[1]['proxies'] == {'http': proxy, 'https': proxy}\ndef test_validate_proxy_failure_status_code(proxy_manager_instance, mock_requests_get):\n    mock_requests_get.return_value = create_mock_response(404)\n    result = proxy_manager_instance.validate_proxy(\"http://bad.status:80\")",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "test_validate_proxy_failure_status_code",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def test_validate_proxy_failure_status_code(proxy_manager_instance, mock_requests_get):\n    mock_requests_get.return_value = create_mock_response(404)\n    result = proxy_manager_instance.validate_proxy(\"http://bad.status:80\")\n    assert result is False\ndef test_validate_proxy_connection_error(proxy_manager_instance, mock_requests_get):\n    mock_requests_get.side_effect = requests.exceptions.ConnectionError\n    result = proxy_manager_instance.validate_proxy(\"http://no.connect:80\")\n    assert result is False\ndef test_validate_proxy_timeout_error(proxy_manager_instance, mock_requests_get):\n    mock_requests_get.side_effect = requests.exceptions.Timeout",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "test_validate_proxy_connection_error",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def test_validate_proxy_connection_error(proxy_manager_instance, mock_requests_get):\n    mock_requests_get.side_effect = requests.exceptions.ConnectionError\n    result = proxy_manager_instance.validate_proxy(\"http://no.connect:80\")\n    assert result is False\ndef test_validate_proxy_timeout_error(proxy_manager_instance, mock_requests_get):\n    mock_requests_get.side_effect = requests.exceptions.Timeout\n    result = proxy_manager_instance.validate_proxy(\"http://slow.proxy:80\")\n    assert result is False\n# --- Tests for Concurrent Validation (validate_all_proxies) ---\n@patch('proxy_manager.ThreadPoolExecutor')",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "test_validate_proxy_timeout_error",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def test_validate_proxy_timeout_error(proxy_manager_instance, mock_requests_get):\n    mock_requests_get.side_effect = requests.exceptions.Timeout\n    result = proxy_manager_instance.validate_proxy(\"http://slow.proxy:80\")\n    assert result is False\n# --- Tests for Concurrent Validation (validate_all_proxies) ---\n@patch('proxy_manager.ThreadPoolExecutor')\n@patch('proxy_manager.Progress')\n@patch('urllib3.disable_warnings')\ndef test_validate_all_proxies_logic(mock_disable_warnings, mock_progress, mock_executor, initialized_manager, mock_requests_get, mock_confirm):\n    # 1. Setup Mock for concurrent execution environment",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "test_validate_all_proxies_logic",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def test_validate_all_proxies_logic(mock_disable_warnings, mock_progress, mock_executor, initialized_manager, mock_requests_get, mock_confirm):\n    # 1. Setup Mock for concurrent execution environment\n    # Mock Future results: 1st is success, 2nd is failure (404), 3rd is exception\n    mock_future1 = MagicMock()\n    mock_future1.result.return_value = True # Working\n    mock_future2 = MagicMock()\n    mock_future2.result.return_value = False # Failed (404)\n    mock_future3 = MagicMock()\n    mock_future3.result.side_effect = requests.exceptions.ProxyError # Failed (Exception)\n    # Link futures back to their original proxies",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "test_get_summary",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def test_get_summary(initialized_manager):\n    # Manually populate working/failed proxies for test\n    initialized_manager.working_proxies = [\"p1\", \"p3\"]\n    initialized_manager.failed_proxies = [\"p2\"]\n    summary = initialized_manager.get_summary()\n    assert summary['total_proxies'] == 3\n    assert summary['working_proxies'] == 2\n    assert summary['failed_proxies'] == 1\n    assert summary['success_rate'] == pytest.approx(66.666, 0.001)\n@patch('proxy_manager.ProxyManager._save_proxies_to_file')",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "test_remove_dead_proxies_success",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def test_remove_dead_proxies_success(mock_save_to_file, initialized_manager):\n    initial_proxies = [\"p1\", \"p2\", \"p3\", \"p4\"]\n    initialized_manager.proxies = initial_proxies.copy()\n    initialized_manager.working_proxies = [\"p1\", \"p4\"]\n    initialized_manager.failed_proxies = [\"p2\", \"p3\"]\n    initialized_manager.remove_dead_proxies()\n    assert initialized_manager.proxies == [\"p1\", \"p4\"]\n    mock_save_to_file.assert_called_once()\n# --- Tests for Saving Proxies to File ---\ndef test_save_proxies_to_txt_file(initialized_manager, mock_path_exists):",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "test_save_proxies_to_txt_file",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def test_save_proxies_to_txt_file(initialized_manager, mock_path_exists):\n    mock_path_exists.side_effect = lambda x: x == Path(\"proxies.txt\")\n    initialized_manager.proxies = [\"http://a:1\", \"https://b:2\"]\n    m = mock_open()\n    with patch(\"builtins.open\", m):\n        initialized_manager._save_proxies_to_file()\n    m.assert_called_once_with(Path(\"proxies.txt\"), 'w', encoding='utf-8')\n    handle = m()\n    handle.write.assert_has_calls([\n        call(\"http://a:1\\n\"), ",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "test_save_proxies_to_csv_file",
        "kind": 2,
        "importPath": "tests.unit.managers.test_proxy_manager",
        "description": "tests.unit.managers.test_proxy_manager",
        "peekOfCode": "def test_save_proxies_to_csv_file(initialized_manager, mock_path_exists):\n    mock_path_exists.side_effect = lambda x: x == Path(\"proxies.csv\")\n    initialized_manager.proxies = [\"http://a:1\", \"https://b:2\", \"socks5://c:3\"]\n    m = mock_open()\n    with patch(\"builtins.open\", m):\n        initialized_manager._save_proxies_to_file()\n    m.assert_called_once_with(Path(\"proxies.csv\"), 'w', encoding='utf-8', newline='')\n    # Check what was written to the file (requires checking the CSV writer)\n    handle = m()\n    written_data = \"\".join(c for c in handle.write.call_args_list[0][0][0] if c != '\\r').split('\\n')",
        "detail": "tests.unit.managers.test_proxy_manager",
        "documentation": {}
    },
    {
        "label": "mock_datetime_now",
        "kind": 2,
        "importPath": "tests.unit.models.test_channel",
        "description": "tests.unit.models.test_channel",
        "peekOfCode": "def mock_datetime_now():\n    \"\"\"Patches datetime.now() for deterministic timestamp testing.\"\"\"\n    test_time = datetime(2025, 11, 11, 10, 30, 0)\n    test_iso = test_time.isoformat()\n    # Patch datetime.now() within the Channel module\n    with patch('models.channel.datetime') as mock_dt: \n        mock_dt.now.return_value = test_time\n        mock_dt.now.return_value.isoformat.return_value = test_iso\n        yield test_iso\n@pytest.fixture",
        "detail": "tests.unit.models.test_channel",
        "documentation": {}
    },
    {
        "label": "base_channel_row",
        "kind": 2,
        "importPath": "tests.unit.models.test_channel",
        "description": "tests.unit.models.test_channel",
        "peekOfCode": "def base_channel_row() -> Tuple[Any, ...]:\n    \"\"\"Mock database row for Channel (15 fields).\"\"\"\n    return (\n        1,  # id\n        \"https://example.com/channel/abc\",  # url\n        \"Test Channel Title\",  # title\n        1,  # is_monitored (True)\n        60,  # check_interval_minutes\n        \"2025-11-10T10:00:00\",  # last_checked\n        \"2025-11-09\",  # last_video_date",
        "detail": "tests.unit.models.test_channel",
        "documentation": {}
    },
    {
        "label": "test_channel_instantiation",
        "kind": 2,
        "importPath": "tests.unit.models.test_channel",
        "description": "tests.unit.models.test_channel",
        "peekOfCode": "def test_channel_instantiation():\n    \"\"\"Test basic instantiation with required fields.\"\"\"\n    channel = Channel(id=5, url=\"test_url\", title=\"Test Title\")\n    assert channel.id == 5\n    assert channel.is_monitored is False\n    assert channel.enabled is True\n    assert channel.quality == \"best\"\ndef test_channel_from_row_mapping(base_channel_row):\n    \"\"\"Test Channel.from_row correctly maps and converts types (especially bools).\"\"\"\n    channel = Channel.from_row(base_channel_row)",
        "detail": "tests.unit.models.test_channel",
        "documentation": {}
    },
    {
        "label": "test_channel_from_row_mapping",
        "kind": 2,
        "importPath": "tests.unit.models.test_channel",
        "description": "tests.unit.models.test_channel",
        "peekOfCode": "def test_channel_from_row_mapping(base_channel_row):\n    \"\"\"Test Channel.from_row correctly maps and converts types (especially bools).\"\"\"\n    channel = Channel.from_row(base_channel_row)\n    assert channel.id == 1\n    assert channel.title == \"Test Channel Title\"\n    assert channel.is_monitored is True  # Check boolean conversion (1 -> True)\n    assert channel.enabled is False      # Check boolean conversion (0 -> False)\n    assert channel.check_interval_minutes == 60\n    assert channel.format_type == \"audio\"\n    assert channel.created_at == \"2025-01-01T00:00:00\"",
        "detail": "tests.unit.models.test_channel",
        "documentation": {}
    },
    {
        "label": "test_channel_prepare_for_insert",
        "kind": 2,
        "importPath": "tests.unit.models.test_channel",
        "description": "tests.unit.models.test_channel",
        "peekOfCode": "def test_channel_prepare_for_insert(mock_datetime_now):\n    \"\"\"Test Channel.prepare_for_insert returns correct tuple order and sets timestamps.\"\"\"\n    channel = Channel(\n        id=None, url=\"url\", title=\"Title\", is_monitored=True,\n        output_dir=\".\", created_at=None\n    )\n    insert_tuple = channel.prepare_for_insert()\n    # Expected order: url, title, is_monitored(int), check_interval, last_checked, last_video, enabled(int), format, quality, output_dir, filename_template, download_order, created_at, updated_at\n    assert len(insert_tuple) == 14\n    assert insert_tuple[2] == 1  # is_monitored (True -> 1)",
        "detail": "tests.unit.models.test_channel",
        "documentation": {}
    },
    {
        "label": "test_channel_prepare_for_update",
        "kind": 2,
        "importPath": "tests.unit.models.test_channel",
        "description": "tests.unit.models.test_channel",
        "peekOfCode": "def test_channel_prepare_for_update(mock_datetime_now):\n    \"\"\"Test Channel.prepare_for_update returns correct tuple order and sets updated_at.\"\"\"\n    channel = Channel(\n        id=50, url=\"url\", title=\"New Title\", is_monitored=False,\n        output_dir=\"/new\", created_at=\"old_time\"\n    )\n    update_tuple = channel.prepare_for_update()\n    # Expected order: title, is_monitored(int), check_interval, last_checked, last_video, enabled(int), format, quality, output_dir, filename_template, download_order, updated_at, id\n    assert len(update_tuple) == 13\n    assert update_tuple[0] == \"New Title\"",
        "detail": "tests.unit.models.test_channel",
        "documentation": {}
    },
    {
        "label": "base_stats_row",
        "kind": 2,
        "importPath": "tests.unit.models.test_daily_stats",
        "description": "tests.unit.models.test_daily_stats",
        "peekOfCode": "def base_stats_row() -> Tuple[Any, ...]:\n    \"\"\"Mock database row for DailyStats (9 fields).\"\"\"\n    return (\n        5,  # id\n        \"2025-11-11\",  # date\n        10,  # videos_downloaded\n        20,  # videos_queued\n        1,  # videos_failed\n        3600.0,  # total_download_time_seconds\n        5368709120,  # total_file_size_bytes (5GB)",
        "detail": "tests.unit.models.test_daily_stats",
        "documentation": {}
    },
    {
        "label": "test_stats_instantiation",
        "kind": 2,
        "importPath": "tests.unit.models.test_daily_stats",
        "description": "tests.unit.models.test_daily_stats",
        "peekOfCode": "def test_stats_instantiation():\n    \"\"\"Test basic instantiation with required fields and defaults.\"\"\"\n    stats = DailyStats(id=1, date=\"2025-01-01\")\n    assert stats.id == 1\n    assert stats.videos_downloaded == 0\n    assert stats.total_download_time_seconds == 0.0\ndef test_stats_from_row_mapping(base_stats_row):\n    \"\"\"Test DailyStats.from_row correctly maps all fields.\"\"\"\n    stats = DailyStats.from_row(base_stats_row)\n    assert stats.id == 5",
        "detail": "tests.unit.models.test_daily_stats",
        "documentation": {}
    },
    {
        "label": "test_stats_from_row_mapping",
        "kind": 2,
        "importPath": "tests.unit.models.test_daily_stats",
        "description": "tests.unit.models.test_daily_stats",
        "peekOfCode": "def test_stats_from_row_mapping(base_stats_row):\n    \"\"\"Test DailyStats.from_row correctly maps all fields.\"\"\"\n    stats = DailyStats.from_row(base_stats_row)\n    assert stats.id == 5\n    assert stats.date == \"2025-11-11\"\n    assert stats.videos_downloaded == 10\n    assert stats.total_file_size_bytes == 5368709120\n    assert stats.queues_created == 2\n    assert stats.videos_failed == 1\n    assert stats.total_download_time_seconds == 3600.0",
        "detail": "tests.unit.models.test_daily_stats",
        "documentation": {}
    },
    {
        "label": "test_stats_prepare_for_insert",
        "kind": 2,
        "importPath": "tests.unit.models.test_daily_stats",
        "description": "tests.unit.models.test_daily_stats",
        "peekOfCode": "def test_stats_prepare_for_insert():\n    \"\"\"Test DailyStats.prepare_for_insert returns correct tuple order.\"\"\"\n    stats = DailyStats(id=None, date=\"2025-12-25\", videos_downloaded=5)\n    insert_tuple = stats.prepare_for_insert()\n    # Expected: date, downloaded, queued, failed, time, size, created, completed (8 fields)\n    assert len(insert_tuple) == 8\n    assert insert_tuple[0] == \"2025-12-25\" # date\n    assert insert_tuple[1] == 5          # videos_downloaded\n    assert insert_tuple[5] == 0          # total_file_size_bytes (default)\ndef test_stats_prepare_for_update():",
        "detail": "tests.unit.models.test_daily_stats",
        "documentation": {}
    },
    {
        "label": "test_stats_prepare_for_update",
        "kind": 2,
        "importPath": "tests.unit.models.test_daily_stats",
        "description": "tests.unit.models.test_daily_stats",
        "peekOfCode": "def test_stats_prepare_for_update():\n    \"\"\"Test DailyStats.prepare_for_update returns correct tuple order (date is last).\"\"\"\n    stats = DailyStats(id=10, date=\"2025-12-25\", videos_downloaded=50, queues_created=3)\n    update_tuple = stats.prepare_for_update()\n    # Expected: downloaded, queued, failed, time, size, created, completed, date (8 fields)\n    assert len(update_tuple) == 8\n    assert update_tuple[0] == 50  # videos_downloaded\n    assert update_tuple[5] == 3   # queues_created\n    assert update_tuple[7] == \"2025-12-25\" # date is last",
        "detail": "tests.unit.models.test_daily_stats",
        "documentation": {}
    },
    {
        "label": "base_alert_row",
        "kind": 2,
        "importPath": "tests.unit.models.test_download_alert",
        "description": "tests.unit.models.test_download_alert",
        "peekOfCode": "def base_alert_row() -> Tuple[Any, ...]:\n    \"\"\"Mock database row for DownloadAlert (4 fields).\"\"\"\n    return (\n        8,  # id\n        1073741824,  # threshold_bytes (1GB)\n        \"2025-11-10\",  # last_alert_date\n        500000000  # total_size_at_alert\n    )\n# --- Tests ---\ndef test_alert_instantiation():",
        "detail": "tests.unit.models.test_download_alert",
        "documentation": {}
    },
    {
        "label": "test_alert_instantiation",
        "kind": 2,
        "importPath": "tests.unit.models.test_download_alert",
        "description": "tests.unit.models.test_download_alert",
        "peekOfCode": "def test_alert_instantiation():\n    \"\"\"Test basic instantiation with required fields and defaults.\"\"\"\n    alert = DownloadAlert(id=1, threshold_bytes=1000)\n    assert alert.id == 1\n    assert alert.threshold_bytes == 1000\n    assert alert.last_alert_date is None\n    assert alert.total_size_at_alert == 0\ndef test_alert_from_row_mapping(base_alert_row):\n    \"\"\"Test DownloadAlert.from_row correctly maps all fields.\"\"\"\n    alert = DownloadAlert.from_row(base_alert_row)",
        "detail": "tests.unit.models.test_download_alert",
        "documentation": {}
    },
    {
        "label": "test_alert_from_row_mapping",
        "kind": 2,
        "importPath": "tests.unit.models.test_download_alert",
        "description": "tests.unit.models.test_download_alert",
        "peekOfCode": "def test_alert_from_row_mapping(base_alert_row):\n    \"\"\"Test DownloadAlert.from_row correctly maps all fields.\"\"\"\n    alert = DownloadAlert.from_row(base_alert_row)\n    assert alert.id == 8\n    assert alert.threshold_bytes == 1073741824\n    assert alert.last_alert_date == \"2025-11-10\"\n    assert alert.total_size_at_alert == 500000000\ndef test_alert_prepare_for_insert():\n    \"\"\"Test DownloadAlert.prepare_for_insert returns correct tuple order.\"\"\"\n    alert = DownloadAlert(id=None, threshold_bytes=100)",
        "detail": "tests.unit.models.test_download_alert",
        "documentation": {}
    },
    {
        "label": "test_alert_prepare_for_insert",
        "kind": 2,
        "importPath": "tests.unit.models.test_download_alert",
        "description": "tests.unit.models.test_download_alert",
        "peekOfCode": "def test_alert_prepare_for_insert():\n    \"\"\"Test DownloadAlert.prepare_for_insert returns correct tuple order.\"\"\"\n    alert = DownloadAlert(id=None, threshold_bytes=100)\n    insert_tuple = alert.prepare_for_insert()\n    # Expected: threshold_bytes, last_alert_date, total_size_at_alert (3 fields)\n    assert len(insert_tuple) == 3\n    assert insert_tuple[0] == 100\n    assert insert_tuple[1] is None\n    assert insert_tuple[2] == 0\ndef test_alert_prepare_for_update():",
        "detail": "tests.unit.models.test_download_alert",
        "documentation": {}
    },
    {
        "label": "test_alert_prepare_for_update",
        "kind": 2,
        "importPath": "tests.unit.models.test_download_alert",
        "description": "tests.unit.models.test_download_alert",
        "peekOfCode": "def test_alert_prepare_for_update():\n    \"\"\"Test DownloadAlert.prepare_for_update returns correct tuple order (threshold is last).\"\"\"\n    alert = DownloadAlert(id=1, threshold_bytes=200, last_alert_date=\"today\", total_size_at_alert=50)\n    update_tuple = alert.prepare_for_update()\n    # Expected: last_alert_date, total_size_at_alert, threshold_bytes (3 fields)\n    assert len(update_tuple) == 3\n    assert update_tuple[0] == \"today\"\n    assert update_tuple[2] == 200 # threshold_bytes is last",
        "detail": "tests.unit.models.test_download_alert",
        "documentation": {}
    },
    {
        "label": "base_item_row",
        "kind": 2,
        "importPath": "tests.unit.models.test_download_item",
        "description": "tests.unit.models.test_download_item",
        "peekOfCode": "def base_item_row() -> Tuple[Any, ...]:\n    \"\"\"Mock database row for DownloadItem (15 fields).\"\"\"\n    return (\n        202,  # id\n        \"101\",  # queue_id\n        \"https://example.com/video/123\",  # url\n        \"Video Title 1\",  # title\n        \"COMPLETED\",  # status\n        \"/path/to/file.mp4\",  # file_path\n        None,  # error",
        "detail": "tests.unit.models.test_download_item",
        "documentation": {}
    },
    {
        "label": "test_item_instantiation",
        "kind": 2,
        "importPath": "tests.unit.models.test_download_item",
        "description": "tests.unit.models.test_download_item",
        "peekOfCode": "def test_item_instantiation():\n    \"\"\"Test basic instantiation with required fields.\"\"\"\n    item = DownloadItem(id=1, queue_id=\"1\", url=\"u\", title=\"t\", status=\"P\")\n    assert item.id == 1\n    assert item.status == \"P\"\n    assert item.file_size_bytes is None\ndef test_item_from_row_mapping(base_item_row):\n    \"\"\"Test DownloadItem.from_row correctly maps all fields.\"\"\"\n    item = DownloadItem.from_row(base_item_row)\n    assert item.id == 202",
        "detail": "tests.unit.models.test_download_item",
        "documentation": {}
    },
    {
        "label": "test_item_from_row_mapping",
        "kind": 2,
        "importPath": "tests.unit.models.test_download_item",
        "description": "tests.unit.models.test_download_item",
        "peekOfCode": "def test_item_from_row_mapping(base_item_row):\n    \"\"\"Test DownloadItem.from_row correctly maps all fields.\"\"\"\n    item = DownloadItem.from_row(base_item_row)\n    assert item.id == 202\n    assert item.title == \"Video Title 1\"\n    assert item.status == \"COMPLETED\"\n    assert item.file_size_bytes == 104857600\n    assert item.download_duration_seconds == 240.5\n    assert item.uploader == \"Uploader Name\"\n    assert item.error is None",
        "detail": "tests.unit.models.test_download_item",
        "documentation": {}
    },
    {
        "label": "test_item_prepare_for_insert",
        "kind": 2,
        "importPath": "tests.unit.models.test_download_item",
        "description": "tests.unit.models.test_download_item",
        "peekOfCode": "def test_item_prepare_for_insert():\n    \"\"\"Test DownloadItem.prepare_for_insert returns correct tuple order.\"\"\"\n    item = DownloadItem(\n        id=None, queue_id=\"101\", url=\"u\", title=\"t\", status=\"P\",\n        upload_date=\"d\", uploader=\"up\", video_id=\"v\", file_path=\"p\"\n    )\n    insert_tuple = item.prepare_for_insert()\n    # Expected: queue_id, url, title, status, file_path, error, file_hash, started, completed, duration, upload_date, uploader, video_id, file_size\n    assert len(insert_tuple) == 14\n    assert insert_tuple[0] == \"101\" # queue_id",
        "detail": "tests.unit.models.test_download_item",
        "documentation": {}
    },
    {
        "label": "test_item_prepare_for_update",
        "kind": 2,
        "importPath": "tests.unit.models.test_download_item",
        "description": "tests.unit.models.test_download_item",
        "peekOfCode": "def test_item_prepare_for_update():\n    \"\"\"Test DownloadItem.prepare_for_update returns correct tuple order.\"\"\"\n    item = DownloadItem(\n        id=300, queue_id=\"1\", url=\"u\", title=\"t\", status=\"COMPLETED\",\n        file_path=\"/final\", file_size_bytes=50, upload_date=\"d\",\n        uploader=\"up\", video_id=\"v\"\n    )\n    update_tuple = item.prepare_for_update()\n    # Expected: status, file_path, error, file_hash, started, completed, duration, file_size_bytes, id (9 fields)\n    assert len(update_tuple) == 9",
        "detail": "tests.unit.models.test_download_item",
        "documentation": {}
    },
    {
        "label": "base_queue_row",
        "kind": 2,
        "importPath": "tests.unit.models.test_queue",
        "description": "tests.unit.models.test_queue",
        "peekOfCode": "def base_queue_row() -> Tuple[Any, ...]:\n    \"\"\"Mock database row for Queue (13 fields, including storage).\"\"\"\n    return (\n        101,  # id\n        \"https://example.com/playlist/xyz\",  # playlist_url\n        \"My Test Playlist\",  # playlist_title\n        \"video\",  # format_type\n        \"1080p\",  # quality\n        \"/output/queue\",  # output_dir\n        \"oldest_first\",  # download_order",
        "detail": "tests.unit.models.test_queue",
        "documentation": {}
    },
    {
        "label": "test_queue_instantiation",
        "kind": 2,
        "importPath": "tests.unit.models.test_queue",
        "description": "tests.unit.models.test_queue",
        "peekOfCode": "def test_queue_instantiation():\n    \"\"\"Test basic instantiation with required fields.\"\"\"\n    queue = Queue(id=1, playlist_url=\"url\", playlist_title=\"title\", \n                  format_type=\"video\", quality=\"720p\", output_dir=\".\", \n                  download_order=\"original\")\n    assert queue.id == 1\n    assert queue.storage_provider == \"local\"\n    assert queue.storage_video_quality is None\ndef test_queue_from_row_full_mapping(base_queue_row):\n    \"\"\"Test Queue.from_row with all fields present (including storage).\"\"\"",
        "detail": "tests.unit.models.test_queue",
        "documentation": {}
    },
    {
        "label": "test_queue_from_row_full_mapping",
        "kind": 2,
        "importPath": "tests.unit.models.test_queue",
        "description": "tests.unit.models.test_queue",
        "peekOfCode": "def test_queue_from_row_full_mapping(base_queue_row):\n    \"\"\"Test Queue.from_row with all fields present (including storage).\"\"\"\n    queue = Queue.from_row(base_queue_row)\n    assert queue.id == 101\n    assert queue.playlist_title == \"My Test Playlist\"\n    assert queue.quality == \"1080p\"\n    assert queue.storage_provider == \"dropbox\"\n    assert queue.storage_video_quality == \"720p\"\n    assert queue.storage_audio_quality == \"128\"\ndef test_queue_from_row_legacy_mapping():",
        "detail": "tests.unit.models.test_queue",
        "documentation": {}
    },
    {
        "label": "test_queue_from_row_legacy_mapping",
        "kind": 2,
        "importPath": "tests.unit.models.test_queue",
        "description": "tests.unit.models.test_queue",
        "peekOfCode": "def test_queue_from_row_legacy_mapping():\n    \"\"\"Test Queue.from_row with a legacy row (missing storage fields).\"\"\"\n    # A row with only the first 10 mandatory fields\n    legacy_row = (101, \"url\", \"Title\", \"video\", \"1080p\", \"dir\", \"order\", \"template\", \"c_at\", \"comp_at\")\n    queue = Queue.from_row(legacy_row)\n    # Check that defaults/None are applied for missing fields\n    assert queue.playlist_url == \"url\"\n    assert queue.completed_at == \"comp_at\"\n    assert queue.storage_provider == \"local\"\n    assert queue.storage_video_quality is None",
        "detail": "tests.unit.models.test_queue",
        "documentation": {}
    },
    {
        "label": "test_queue_to_dict",
        "kind": 2,
        "importPath": "tests.unit.models.test_queue",
        "description": "tests.unit.models.test_queue",
        "peekOfCode": "def test_queue_to_dict():\n    \"\"\"Test to_dict conversion.\"\"\"\n    queue = Queue(id=1, playlist_url=\"u\", playlist_title=\"t\", \n                  format_type=\"a\", quality=\"q\", output_dir=\"d\", \n                  download_order=\"o\", completed_at=\"now\")\n    d = queue.to_dict()\n    assert d['id'] == 1\n    assert d['completed_at'] == \"now\"\n    assert 'storage_provider' in d",
        "detail": "tests.unit.models.test_queue",
        "documentation": {}
    },
    {
        "label": "test_base_notifier_is_abstract",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_base_notifier",
        "description": "tests.unit.notifiers.test_base_notifier",
        "peekOfCode": "def test_base_notifier_is_abstract():\n    \"\"\"Verify that BaseNotifier cannot be instantiated directly.\"\"\"\n    with pytest.raises(TypeError) as excinfo:\n        BaseNotifier()\n    assert \"Can't instantiate abstract class BaseNotifier\" in str(excinfo.value)\ndef test_derived_class_raises_notimplemented():\n    \"\"\"Verify that an incomplete derived class raises NotImplementedError.\"\"\"\n    # Define a concrete class that inherits but implements nothing\n    class IncompleteNotifier(BaseNotifier):\n        # We need to explicitly implement 'is_configured' to get past the",
        "detail": "tests.unit.notifiers.test_base_notifier",
        "documentation": {}
    },
    {
        "label": "test_derived_class_raises_notimplemented",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_base_notifier",
        "description": "tests.unit.notifiers.test_base_notifier",
        "peekOfCode": "def test_derived_class_raises_notimplemented():\n    \"\"\"Verify that an incomplete derived class raises NotImplementedError.\"\"\"\n    # Define a concrete class that inherits but implements nothing\n    class IncompleteNotifier(BaseNotifier):\n        # We need to explicitly implement 'is_configured' to get past the\n        # ABC check during instantiation, but leave other methods unimplemented\n        # to test the error on call.\n        def is_configured(self) -> bool:\n            return True\n        pass",
        "detail": "tests.unit.notifiers.test_base_notifier",
        "documentation": {}
    },
    {
        "label": "mock_slack_response",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_slack_notifier",
        "description": "tests.unit.notifiers.test_slack_notifier",
        "peekOfCode": "def mock_slack_response():\n    \"\"\"Mock a successful HTTP response from Slack.\"\"\"\n    response = MagicMock()\n    response.status_code = 200\n    return response\n@pytest.fixture\ndef configured_notifier(mock_slack_response):\n    \"\"\"Notifier configured with a mock URL.\"\"\"\n    notifier = SlackNotifier(webhook_url=\"http://mock.slack.webhook/123\")\n    mock_requests.post.return_value = mock_slack_response",
        "detail": "tests.unit.notifiers.test_slack_notifier",
        "documentation": {}
    },
    {
        "label": "configured_notifier",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_slack_notifier",
        "description": "tests.unit.notifiers.test_slack_notifier",
        "peekOfCode": "def configured_notifier(mock_slack_response):\n    \"\"\"Notifier configured with a mock URL.\"\"\"\n    notifier = SlackNotifier(webhook_url=\"http://mock.slack.webhook/123\")\n    mock_requests.post.return_value = mock_slack_response\n    return notifier\n@pytest.fixture\ndef unconfigured_notifier():\n    \"\"\"Notifier with no webhook URL.\"\"\"\n    return SlackNotifier(webhook_url=None)\n# --- General Tests ---",
        "detail": "tests.unit.notifiers.test_slack_notifier",
        "documentation": {}
    },
    {
        "label": "unconfigured_notifier",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_slack_notifier",
        "description": "tests.unit.notifiers.test_slack_notifier",
        "peekOfCode": "def unconfigured_notifier():\n    \"\"\"Notifier with no webhook URL.\"\"\"\n    return SlackNotifier(webhook_url=None)\n# --- General Tests ---\ndef test_is_configured(configured_notifier, unconfigured_notifier):\n    \"\"\"Test is_configured returns correctly based on webhook_url.\"\"\"\n    assert configured_notifier.is_configured() is True\n    assert unconfigured_notifier.is_configured() is False\n# --- send_notification Tests ---\ndef test_send_notification_unconfigured(unconfigured_notifier):",
        "detail": "tests.unit.notifiers.test_slack_notifier",
        "documentation": {}
    },
    {
        "label": "test_is_configured",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_slack_notifier",
        "description": "tests.unit.notifiers.test_slack_notifier",
        "peekOfCode": "def test_is_configured(configured_notifier, unconfigured_notifier):\n    \"\"\"Test is_configured returns correctly based on webhook_url.\"\"\"\n    assert configured_notifier.is_configured() is True\n    assert unconfigured_notifier.is_configured() is False\n# --- send_notification Tests ---\ndef test_send_notification_unconfigured(unconfigured_notifier):\n    \"\"\"Unconfigured notifier should return False and not call requests.post.\"\"\"\n    assert unconfigured_notifier.send_notification(\"T\", \"M\") is False\n    mock_requests.post.assert_not_called()\ndef test_send_notification_success(configured_notifier, mock_slack_response):",
        "detail": "tests.unit.notifiers.test_slack_notifier",
        "documentation": {}
    },
    {
        "label": "test_send_notification_unconfigured",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_slack_notifier",
        "description": "tests.unit.notifiers.test_slack_notifier",
        "peekOfCode": "def test_send_notification_unconfigured(unconfigured_notifier):\n    \"\"\"Unconfigured notifier should return False and not call requests.post.\"\"\"\n    assert unconfigured_notifier.send_notification(\"T\", \"M\") is False\n    mock_requests.post.assert_not_called()\ndef test_send_notification_success(configured_notifier, mock_slack_response):\n    \"\"\"Test successful API call.\"\"\"\n    mock_time.time.return_value = 1678886400  # Mock timestamp\n    result = configured_notifier.send_notification(\"My Title\", \"My Message\", color=\"danger\")\n    assert result is True\n    # Verify requests.post was called with the correct payload structure",
        "detail": "tests.unit.notifiers.test_slack_notifier",
        "documentation": {}
    },
    {
        "label": "test_send_notification_success",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_slack_notifier",
        "description": "tests.unit.notifiers.test_slack_notifier",
        "peekOfCode": "def test_send_notification_success(configured_notifier, mock_slack_response):\n    \"\"\"Test successful API call.\"\"\"\n    mock_time.time.return_value = 1678886400  # Mock timestamp\n    result = configured_notifier.send_notification(\"My Title\", \"My Message\", color=\"danger\")\n    assert result is True\n    # Verify requests.post was called with the correct payload structure\n    mock_requests.post.assert_called_once()\n    # Extract the payload argument\n    _, kwargs = mock_requests.post.call_args\n    payload = kwargs['json']",
        "detail": "tests.unit.notifiers.test_slack_notifier",
        "documentation": {}
    },
    {
        "label": "test_send_notification_failure_status_code",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_slack_notifier",
        "description": "tests.unit.notifiers.test_slack_notifier",
        "peekOfCode": "def test_send_notification_failure_status_code(configured_notifier):\n    \"\"\"Test failure due to non-200 status code.\"\"\"\n    mock_response = MagicMock()\n    mock_response.status_code = 500\n    mock_requests.post.return_value = mock_response\n    assert configured_notifier.send_notification(\"T\", \"M\") is False\ndef test_send_notification_exception(configured_notifier):\n    \"\"\"Test failure due to network exception.\"\"\"\n    mock_requests.post.side_effect = Exception(\"Network Down\")\n    with patch('notifiers.slack_notifier.console') as mock_console:",
        "detail": "tests.unit.notifiers.test_slack_notifier",
        "documentation": {}
    },
    {
        "label": "test_send_notification_exception",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_slack_notifier",
        "description": "tests.unit.notifiers.test_slack_notifier",
        "peekOfCode": "def test_send_notification_exception(configured_notifier):\n    \"\"\"Test failure due to network exception.\"\"\"\n    mock_requests.post.side_effect = Exception(\"Network Down\")\n    with patch('notifiers.slack_notifier.console') as mock_console:\n        result = configured_notifier.send_notification(\"T\", \"M\")\n    assert result is False\n    mock_console.print.assert_called()\n# --- Specific Notifier Methods Tests ---\n@pytest.mark.parametrize(\"failed, color, status_title\", [\n    (0, \"good\", \"Queue Completed successfully\"),",
        "detail": "tests.unit.notifiers.test_slack_notifier",
        "documentation": {}
    },
    {
        "label": "test_notify_queue_completed",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_slack_notifier",
        "description": "tests.unit.notifiers.test_slack_notifier",
        "peekOfCode": "def test_notify_queue_completed(configured_notifier, failed, color, status_title):\n    \"\"\"Test notify_queue_completed formats message correctly.\"\"\"\n    configured_notifier.send_notification = MagicMock(return_value=True)\n    result = configured_notifier.notify_queue_completed(\"List A\", 5, failed, 6, \"1h 30m\")\n    assert result is True\n    configured_notifier.send_notification.assert_called_once()\n    title_arg, message_arg, color_arg = configured_notifier.send_notification.call_args[0]\n    assert title_arg == status_title\n    assert color_arg == color\n    assert \"*Playlist:* List A\" in message_arg",
        "detail": "tests.unit.notifiers.test_slack_notifier",
        "documentation": {}
    },
    {
        "label": "test_notify_monitoring_update",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_slack_notifier",
        "description": "tests.unit.notifiers.test_slack_notifier",
        "peekOfCode": "def test_notify_monitoring_update(configured_notifier):\n    \"\"\"Test notify_monitoring_update formats message correctly.\"\"\"\n    configured_notifier.send_notification = MagicMock(return_value=True)\n    configured_notifier.notify_monitoring_update(\"Channel B\", 12)\n    title_arg, message_arg, color_arg = configured_notifier.send_notification.call_args[0]\n    assert title_arg == \"New Videos Detected\"\n    assert color_arg == \"#36a64f\"\n    assert \"*Playlist:* Channel B\" in message_arg\n    assert \"*New Videos:* 12\" in message_arg\ndef test_notify_size_threshold(configured_notifier):",
        "detail": "tests.unit.notifiers.test_slack_notifier",
        "documentation": {}
    },
    {
        "label": "test_notify_size_threshold",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_slack_notifier",
        "description": "tests.unit.notifiers.test_slack_notifier",
        "peekOfCode": "def test_notify_size_threshold(configured_notifier):\n    \"\"\"Test notify_size_threshold formats message correctly.\"\"\"\n    configured_notifier.send_notification = MagicMock(return_value=True)\n    mock_time.strftime.return_value = \"11:30:00\"\n    configured_notifier.notify_size_threshold(1024, 1500.75)\n    title_arg, message_arg, color_arg = configured_notifier.send_notification.call_args[0]\n    assert title_arg == \"Download Size Alert: 1024 MB Reached\"\n    assert color_arg == \"warning\"\n    assert \"*Threshold:* 1024 MB\" in message_arg\n    assert \"*Total Downloaded Today:* 1500.75 MB\" in message_arg",
        "detail": "tests.unit.notifiers.test_slack_notifier",
        "documentation": {}
    },
    {
        "label": "mock_requests",
        "kind": 5,
        "importPath": "tests.unit.notifiers.test_slack_notifier",
        "description": "tests.unit.notifiers.test_slack_notifier",
        "peekOfCode": "mock_requests = MagicMock()\nmock_time = MagicMock()\nwith patch.dict('sys.modules', {'requests': mock_requests, 'time': mock_time}):\n    from notifiers.slack_notifier import SlackNotifier\n# --- Fixtures ---\n@pytest.fixture\ndef mock_slack_response():\n    \"\"\"Mock a successful HTTP response from Slack.\"\"\"\n    response = MagicMock()\n    response.status_code = 200",
        "detail": "tests.unit.notifiers.test_slack_notifier",
        "documentation": {}
    },
    {
        "label": "mock_time",
        "kind": 5,
        "importPath": "tests.unit.notifiers.test_slack_notifier",
        "description": "tests.unit.notifiers.test_slack_notifier",
        "peekOfCode": "mock_time = MagicMock()\nwith patch.dict('sys.modules', {'requests': mock_requests, 'time': mock_time}):\n    from notifiers.slack_notifier import SlackNotifier\n# --- Fixtures ---\n@pytest.fixture\ndef mock_slack_response():\n    \"\"\"Mock a successful HTTP response from Slack.\"\"\"\n    response = MagicMock()\n    response.status_code = 200\n    return response",
        "detail": "tests.unit.notifiers.test_slack_notifier",
        "documentation": {}
    },
    {
        "label": "mock_smtp_server",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_smtp_notifier",
        "description": "tests.unit.notifiers.test_smtp_notifier",
        "peekOfCode": "def mock_smtp_server():\n    \"\"\"Mock the smtplib.SMTP class and instance.\"\"\"\n    mock_server_instance = MagicMock(spec=smtplib.SMTP)\n    mock_smtplib.SMTP.return_value = mock_server_instance\n    return mock_server_instance\n@pytest.fixture\ndef valid_smtp_config():\n    \"\"\"Valid configuration dictionary for SMTPNotifier.\"\"\"\n    return {\n        'host': 'smtp.mock.com',",
        "detail": "tests.unit.notifiers.test_smtp_notifier",
        "documentation": {}
    },
    {
        "label": "valid_smtp_config",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_smtp_notifier",
        "description": "tests.unit.notifiers.test_smtp_notifier",
        "peekOfCode": "def valid_smtp_config():\n    \"\"\"Valid configuration dictionary for SMTPNotifier.\"\"\"\n    return {\n        'host': 'smtp.mock.com',\n        'port': 587,\n        'user': 'test_user',\n        'password': 'test_password',\n        'sender_email': 'sender@mock.com',\n        'recipient_email': 'recipient@mock.com',\n        'use_tls': True",
        "detail": "tests.unit.notifiers.test_smtp_notifier",
        "documentation": {}
    },
    {
        "label": "configured_notifier",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_smtp_notifier",
        "description": "tests.unit.notifiers.test_smtp_notifier",
        "peekOfCode": "def configured_notifier(valid_smtp_config):\n    \"\"\"SMTPNotifier configured with valid credentials.\"\"\"\n    return SMTPNotifier(smtp_config=valid_smtp_config)\n@pytest.fixture\ndef unconfigured_notifier():\n    \"\"\"SMTPNotifier with missing essential credentials.\"\"\"\n    return SMTPNotifier(smtp_config={'host': 'h', 'port': 25})\n# --- General Tests ---\ndef test_is_configured(configured_notifier, unconfigured_notifier):\n    \"\"\"Test is_configured returns correctly based on config completeness.\"\"\"",
        "detail": "tests.unit.notifiers.test_smtp_notifier",
        "documentation": {}
    },
    {
        "label": "unconfigured_notifier",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_smtp_notifier",
        "description": "tests.unit.notifiers.test_smtp_notifier",
        "peekOfCode": "def unconfigured_notifier():\n    \"\"\"SMTPNotifier with missing essential credentials.\"\"\"\n    return SMTPNotifier(smtp_config={'host': 'h', 'port': 25})\n# --- General Tests ---\ndef test_is_configured(configured_notifier, unconfigured_notifier):\n    \"\"\"Test is_configured returns correctly based on config completeness.\"\"\"\n    assert configured_notifier.is_configured() is True\n    assert unconfigured_notifier.is_configured() is False\n# --- send_notification Tests ---\ndef test_send_notification_unconfigured(unconfigured_notifier):",
        "detail": "tests.unit.notifiers.test_smtp_notifier",
        "documentation": {}
    },
    {
        "label": "test_is_configured",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_smtp_notifier",
        "description": "tests.unit.notifiers.test_smtp_notifier",
        "peekOfCode": "def test_is_configured(configured_notifier, unconfigured_notifier):\n    \"\"\"Test is_configured returns correctly based on config completeness.\"\"\"\n    assert configured_notifier.is_configured() is True\n    assert unconfigured_notifier.is_configured() is False\n# --- send_notification Tests ---\ndef test_send_notification_unconfigured(unconfigured_notifier):\n    \"\"\"Unconfigured notifier should return False and not attempt connection.\"\"\"\n    assert unconfigured_notifier.send_notification(\"T\", \"M\") is False\n    mock_smtplib.SMTP.assert_not_called()\n@patch('email.mime.text.MIMEText')",
        "detail": "tests.unit.notifiers.test_smtp_notifier",
        "documentation": {}
    },
    {
        "label": "test_send_notification_unconfigured",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_smtp_notifier",
        "description": "tests.unit.notifiers.test_smtp_notifier",
        "peekOfCode": "def test_send_notification_unconfigured(unconfigured_notifier):\n    \"\"\"Unconfigured notifier should return False and not attempt connection.\"\"\"\n    assert unconfigured_notifier.send_notification(\"T\", \"M\") is False\n    mock_smtplib.SMTP.assert_not_called()\n@patch('email.mime.text.MIMEText')\ndef test_send_notification_success(mock_mime_text_class, mock_smtp_server, configured_notifier, valid_smtp_config):\n    \"\"\"Test successful email sending process.\"\"\"\n    mock_message_object = MagicMock()\n    mock_mime_text_class.return_value = mock_message_object\n    result = configured_notifier.send_notification(\"Alert Title\", \"Email Body\")",
        "detail": "tests.unit.notifiers.test_smtp_notifier",
        "documentation": {}
    },
    {
        "label": "test_send_notification_success",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_smtp_notifier",
        "description": "tests.unit.notifiers.test_smtp_notifier",
        "peekOfCode": "def test_send_notification_success(mock_mime_text_class, mock_smtp_server, configured_notifier, valid_smtp_config):\n    \"\"\"Test successful email sending process.\"\"\"\n    mock_message_object = MagicMock()\n    mock_mime_text_class.return_value = mock_message_object\n    result = configured_notifier.send_notification(\"Alert Title\", \"Email Body\")\n    assert result is True\n    # 1. Verify SMTP connection\n    mock_smtplib.SMTP.assert_called_once_with(valid_smtp_config['host'], valid_smtp_config['port'], timeout=10)\n    # 2. Verify TLS and login\n    mock_smtp_server.starttls.assert_called_once()",
        "detail": "tests.unit.notifiers.test_smtp_notifier",
        "documentation": {}
    },
    {
        "label": "test_send_notification_exception",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_smtp_notifier",
        "description": "tests.unit.notifiers.test_smtp_notifier",
        "peekOfCode": "def test_send_notification_exception(mock_smtp_server, configured_notifier):\n    \"\"\"Test handling of SMTP exception during connection or sending.\"\"\"\n    mock_smtp_server.starttls.side_effect = smtplib.SMTPException(\"Auth failed\")\n    with patch('notifiers.smtp_notifier.console') as mock_console:\n        result = configured_notifier.send_notification(\"T\", \"M\")\n    assert result is False\n    mock_console.print.assert_called()\n# --- Specific Notifier Methods Tests (check title/message formatting) ---\ndef test_notify_queue_completed_success(configured_notifier):\n    \"\"\"Test notify_queue_completed (success) calls send_notification correctly.\"\"\"",
        "detail": "tests.unit.notifiers.test_smtp_notifier",
        "documentation": {}
    },
    {
        "label": "test_notify_queue_completed_success",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_smtp_notifier",
        "description": "tests.unit.notifiers.test_smtp_notifier",
        "peekOfCode": "def test_notify_queue_completed_success(configured_notifier):\n    \"\"\"Test notify_queue_completed (success) calls send_notification correctly.\"\"\"\n    configured_notifier.send_notification = MagicMock(return_value=True)\n    mock_time.strftime.return_value = \"2025-11-11 10:00:00\"\n    configured_notifier.notify_queue_completed(\"List X\", 10, 0, 10, \"5h\")\n    title_arg, message_arg, _ = configured_notifier.send_notification.call_args[0]\n    assert title_arg == \"Queue Completed successfully: List X\"\n    assert \"Status: Completed successfully\" in message_arg\n    assert \"Downloaded: 10/10\" in message_arg\n    assert \"Time: 2025-11-11 10:00:00\" in message_arg",
        "detail": "tests.unit.notifiers.test_smtp_notifier",
        "documentation": {}
    },
    {
        "label": "test_notify_queue_completed_with_errors",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_smtp_notifier",
        "description": "tests.unit.notifiers.test_smtp_notifier",
        "peekOfCode": "def test_notify_queue_completed_with_errors(configured_notifier):\n    \"\"\"Test notify_queue_completed (with errors) calls send_notification correctly.\"\"\"\n    configured_notifier.send_notification = MagicMock(return_value=True)\n    configured_notifier.notify_queue_completed(\"List Y\", 8, 2, 10, \"1h\")\n    title_arg, message_arg, _ = configured_notifier.send_notification.call_args[0]\n    assert title_arg == \"Queue Completed with errors: List Y\"\n    assert \"Status: Completed with errors\" in message_arg\n    assert \"Failed: 2\" in message_arg\ndef test_notify_queue_failed(configured_notifier):\n    \"\"\"Test notify_queue_failed calls send_notification correctly.\"\"\"",
        "detail": "tests.unit.notifiers.test_smtp_notifier",
        "documentation": {}
    },
    {
        "label": "test_notify_queue_failed",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_smtp_notifier",
        "description": "tests.unit.notifiers.test_smtp_notifier",
        "peekOfCode": "def test_notify_queue_failed(configured_notifier):\n    \"\"\"Test notify_queue_failed calls send_notification correctly.\"\"\"\n    configured_notifier.send_notification = MagicMock(return_value=True)\n    configured_notifier.notify_queue_failed(\"List Z\", \"Connection Reset\")\n    title_arg, message_arg, _ = configured_notifier.send_notification.call_args[0]\n    assert title_arg == \"Queue Failed: List Z\"\n    assert \"Error: Connection Reset\" in message_arg\ndef test_notify_size_threshold(configured_notifier):\n    \"\"\"Test notify_size_threshold calls send_notification correctly.\"\"\"\n    configured_notifier.send_notification = MagicMock(return_value=True)",
        "detail": "tests.unit.notifiers.test_smtp_notifier",
        "documentation": {}
    },
    {
        "label": "test_notify_size_threshold",
        "kind": 2,
        "importPath": "tests.unit.notifiers.test_smtp_notifier",
        "description": "tests.unit.notifiers.test_smtp_notifier",
        "peekOfCode": "def test_notify_size_threshold(configured_notifier):\n    \"\"\"Test notify_size_threshold calls send_notification correctly.\"\"\"\n    configured_notifier.send_notification = MagicMock(return_value=True)\n    configured_notifier.notify_size_threshold(5000, 5001.234)\n    title_arg, message_arg, _ = configured_notifier.send_notification.call_args[0]\n    assert title_arg == \"Download Size Alert: 5000 MB Reached\"\n    assert \"Threshold: 5000 MB\" in message_arg\n    assert \"Total Downloaded Today: 5001.23 MB\" in message_arg",
        "detail": "tests.unit.notifiers.test_smtp_notifier",
        "documentation": {}
    },
    {
        "label": "mock_smtplib",
        "kind": 5,
        "importPath": "tests.unit.notifiers.test_smtp_notifier",
        "description": "tests.unit.notifiers.test_smtp_notifier",
        "peekOfCode": "mock_smtplib = MagicMock()\nmock_time = MagicMock()\nwith patch.dict('sys.modules', {'smtplib': mock_smtplib, 'time': mock_time}):\n    from notifiers.smtp_notifier import SMTPNotifier\n# --- Fixtures ---\n@pytest.fixture\ndef mock_smtp_server():\n    \"\"\"Mock the smtplib.SMTP class and instance.\"\"\"\n    mock_server_instance = MagicMock(spec=smtplib.SMTP)\n    mock_smtplib.SMTP.return_value = mock_server_instance",
        "detail": "tests.unit.notifiers.test_smtp_notifier",
        "documentation": {}
    },
    {
        "label": "mock_time",
        "kind": 5,
        "importPath": "tests.unit.notifiers.test_smtp_notifier",
        "description": "tests.unit.notifiers.test_smtp_notifier",
        "peekOfCode": "mock_time = MagicMock()\nwith patch.dict('sys.modules', {'smtplib': mock_smtplib, 'time': mock_time}):\n    from notifiers.smtp_notifier import SMTPNotifier\n# --- Fixtures ---\n@pytest.fixture\ndef mock_smtp_server():\n    \"\"\"Mock the smtplib.SMTP class and instance.\"\"\"\n    mock_server_instance = MagicMock(spec=smtplib.SMTP)\n    mock_smtplib.SMTP.return_value = mock_server_instance\n    return mock_server_instance",
        "detail": "tests.unit.notifiers.test_smtp_notifier",
        "documentation": {}
    },
    {
        "label": "mock_progress_class",
        "kind": 2,
        "importPath": "tests.unit.ui.progress_display",
        "description": "tests.unit.ui.progress_display",
        "peekOfCode": "def mock_progress_class():\n    \"\"\"Mocks the rich.progress.Progress class.\"\"\"\n    mock_progress_instance = MagicMock()\n    # Mock methods of the instance\n    mock_progress_instance.start = MagicMock()\n    mock_progress_instance.stop = MagicMock()\n    mock_progress_instance.add_task = MagicMock(return_value=1) # Mock task ID\n    mock_progress_instance.update = MagicMock()\n    with patch(\"progress_display.Progress\", return_value=mock_progress_instance) as mock_class:\n        yield mock_progress_instance, mock_class",
        "detail": "tests.unit.ui.progress_display",
        "documentation": {}
    },
    {
        "label": "progress_display_instance",
        "kind": 2,
        "importPath": "tests.unit.ui.progress_display",
        "description": "tests.unit.ui.progress_display",
        "peekOfCode": "def progress_display_instance():\n    \"\"\"Returns a fresh ProgressDisplay instance.\"\"\"\n    # Note: We need to ensure the Progress class mock is in place when this is instantiated\n    return ProgressDisplay()\n# --- Test Initialization and State Management ---\ndef test_init_sets_initial_state(progress_display_instance):\n    \"\"\"Test that __init__ correctly sets up initial state.\"\"\"\n    assert progress_display_instance.progress is None\n    assert progress_display_instance.task_id is None\ndef test_create_simple_progress_sets_state(progress_display_instance, mock_progress_class):",
        "detail": "tests.unit.ui.progress_display",
        "documentation": {}
    },
    {
        "label": "test_init_sets_initial_state",
        "kind": 2,
        "importPath": "tests.unit.ui.progress_display",
        "description": "tests.unit.ui.progress_display",
        "peekOfCode": "def test_init_sets_initial_state(progress_display_instance):\n    \"\"\"Test that __init__ correctly sets up initial state.\"\"\"\n    assert progress_display_instance.progress is None\n    assert progress_display_instance.task_id is None\ndef test_create_simple_progress_sets_state(progress_display_instance, mock_progress_class):\n    \"\"\"Test that creating a progress bar starts the progress and sets task_id.\"\"\"\n    mock_instance, mock_class = mock_progress_class\n    progress_display_instance.create_simple_progress(\"Test Task\", total=200)\n    # Assert state is set\n    assert progress_display_instance.progress == mock_instance",
        "detail": "tests.unit.ui.progress_display",
        "documentation": {}
    },
    {
        "label": "test_create_simple_progress_sets_state",
        "kind": 2,
        "importPath": "tests.unit.ui.progress_display",
        "description": "tests.unit.ui.progress_display",
        "peekOfCode": "def test_create_simple_progress_sets_state(progress_display_instance, mock_progress_class):\n    \"\"\"Test that creating a progress bar starts the progress and sets task_id.\"\"\"\n    mock_instance, mock_class = mock_progress_class\n    progress_display_instance.create_simple_progress(\"Test Task\", total=200)\n    # Assert state is set\n    assert progress_display_instance.progress == mock_instance\n    assert progress_display_instance.task_id == 1\n    # Assert rich methods were called\n    mock_instance.start.assert_called_once()\n    mock_instance.add_task.assert_called_once()",
        "detail": "tests.unit.ui.progress_display",
        "documentation": {}
    },
    {
        "label": "test_update_progress_updates_correctly",
        "kind": 2,
        "importPath": "tests.unit.ui.progress_display",
        "description": "tests.unit.ui.progress_display",
        "peekOfCode": "def test_update_progress_updates_correctly(progress_display_instance, mock_progress_class):\n    \"\"\"Test that update_progress calls the mock rich update method.\"\"\"\n    mock_instance, _ = mock_progress_class\n    progress_display_instance.create_simple_progress(\"Test Task\", total=100)\n    progress_display_instance.update_progress(50)\n    mock_instance.update.assert_called_with(1, completed=50)\ndef test_complete_progress_stops_progress_and_clears_state(progress_display_instance, mock_progress_class):\n    \"\"\"Test that completing the progress bar stops the rich object and resets state.\"\"\"\n    mock_instance, _ = mock_progress_class\n    progress_display_instance.create_simple_progress(\"Test Task\", total=100)",
        "detail": "tests.unit.ui.progress_display",
        "documentation": {}
    },
    {
        "label": "test_complete_progress_stops_progress_and_clears_state",
        "kind": 2,
        "importPath": "tests.unit.ui.progress_display",
        "description": "tests.unit.ui.progress_display",
        "peekOfCode": "def test_complete_progress_stops_progress_and_clears_state(progress_display_instance, mock_progress_class):\n    \"\"\"Test that completing the progress bar stops the rich object and resets state.\"\"\"\n    mock_instance, _ = mock_progress_class\n    progress_display_instance.create_simple_progress(\"Test Task\", total=100)\n    progress_display_instance.complete_progress()\n    mock_instance.stop.assert_called_once()\n    assert progress_display_instance.progress is None\n    assert progress_display_instance.task_id is None\n# --- Test yt-dlp Progress Hook ---\ndef test_yt_dlp_hook_updates_on_downloading_status(progress_display_instance, mock_progress_class):",
        "detail": "tests.unit.ui.progress_display",
        "documentation": {}
    },
    {
        "label": "test_yt_dlp_hook_updates_on_downloading_status",
        "kind": 2,
        "importPath": "tests.unit.ui.progress_display",
        "description": "tests.unit.ui.progress_display",
        "peekOfCode": "def test_yt_dlp_hook_updates_on_downloading_status(progress_display_instance, mock_progress_class):\n    \"\"\"Test that the hook calculates and updates percentage correctly.\"\"\"\n    mock_instance, _ = mock_progress_class\n    progress_display_instance.create_simple_progress(\"Test Download\", total=100) # Total is arbitrary here, actual total is from hook data\n    hook = progress_display_instance.get_yt_dlp_progress_hook()\n    # Simulate a mid-download state\n    download_info = {\n        'status': 'downloading',\n        'downloaded_bytes': 50 * 1024 * 1024, # 50 MB\n        'total_bytes': 100 * 1024 * 1024,     # 100 MB",
        "detail": "tests.unit.ui.progress_display",
        "documentation": {}
    },
    {
        "label": "test_yt_dlp_hook_updates_on_total_bytes_estimate",
        "kind": 2,
        "importPath": "tests.unit.ui.progress_display",
        "description": "tests.unit.ui.progress_display",
        "peekOfCode": "def test_yt_dlp_hook_updates_on_total_bytes_estimate(progress_display_instance, mock_progress_class):\n    \"\"\"Test that the hook uses total_bytes_estimate if total_bytes is missing.\"\"\"\n    mock_instance, _ = mock_progress_class\n    progress_display_instance.create_simple_progress(\"Test Download\", total=100)\n    hook = progress_display_instance.get_yt_dlp_progress_hook()\n    download_info = {\n        'status': 'downloading',\n        'downloaded_bytes': 20 * 1024,\n        'total_bytes_estimate': 80 * 1024,\n        'filename': 'video.mp4'",
        "detail": "tests.unit.ui.progress_display",
        "documentation": {}
    },
    {
        "label": "test_yt_dlp_hook_updates_to_100_on_finished_status",
        "kind": 2,
        "importPath": "tests.unit.ui.progress_display",
        "description": "tests.unit.ui.progress_display",
        "peekOfCode": "def test_yt_dlp_hook_updates_to_100_on_finished_status(progress_display_instance, mock_progress_class):\n    \"\"\"Test that the hook sets completed to 100% on 'finished' status.\"\"\"\n    mock_instance, _ = mock_progress_class\n    progress_display_instance.create_simple_progress(\"Test Download\", total=100)\n    hook = progress_display_instance.get_yt_dlp_progress_hook()\n    # Simulate finished state\n    download_info = {\n        'status': 'finished',\n        'downloaded_bytes': 1000,\n        'total_bytes': 1000,",
        "detail": "tests.unit.ui.progress_display",
        "documentation": {}
    },
    {
        "label": "test_yt_dlp_hook_does_nothing_if_progress_is_none",
        "kind": 2,
        "importPath": "tests.unit.ui.progress_display",
        "description": "tests.unit.ui.progress_display",
        "peekOfCode": "def test_yt_dlp_hook_does_nothing_if_progress_is_none(progress_display_instance, mock_progress_class):\n    \"\"\"Test that the hook is safe to call even if progress bar is not active.\"\"\"\n    mock_instance, _ = mock_progress_class\n    # Do NOT call create_simple_progress\n    hook = progress_display_instance.get_yt_dlp_progress_hook()\n    download_info = {'status': 'downloading', 'downloaded_bytes': 50, 'total_bytes': 100}\n    hook(download_info)\n    mock_instance.update.assert_not_called()",
        "detail": "tests.unit.ui.progress_display",
        "documentation": {}
    },
    {
        "label": "mock_rich_output",
        "kind": 2,
        "importPath": "tests.unit.ui.test_menu",
        "description": "tests.unit.ui.test_menu",
        "peekOfCode": "def mock_rich_output():\n    \"\"\"Fixture to mock rich.console.Console.print for silencing/checking output.\"\"\"\n    with patch(\"menu.console.print\") as mock_print:\n        yield mock_print\ndef test_display_main_menu_returns_user_choice(mock_rich_output):\n    \"\"\"Test that the method returns the value provided by Prompt.ask.\"\"\"\n    # Mock the rich.prompt.Prompt.ask method to simulate a user selecting '4'\n    expected_choice = \"4\"\n    with patch.object(Prompt, 'ask', return_value=expected_choice) as mock_ask:\n        choice = Menu.display_main_menu()",
        "detail": "tests.unit.ui.test_menu",
        "documentation": {}
    },
    {
        "label": "test_display_main_menu_returns_user_choice",
        "kind": 2,
        "importPath": "tests.unit.ui.test_menu",
        "description": "tests.unit.ui.test_menu",
        "peekOfCode": "def test_display_main_menu_returns_user_choice(mock_rich_output):\n    \"\"\"Test that the method returns the value provided by Prompt.ask.\"\"\"\n    # Mock the rich.prompt.Prompt.ask method to simulate a user selecting '4'\n    expected_choice = \"4\"\n    with patch.object(Prompt, 'ask', return_value=expected_choice) as mock_ask:\n        choice = Menu.display_main_menu()\n    # Assert the returned value matches the mocked input\n    assert choice == expected_choice\n    # Assert Prompt.ask was called\n    mock_ask.assert_called_once()",
        "detail": "tests.unit.ui.test_menu",
        "documentation": {}
    },
    {
        "label": "test_display_main_menu_uses_correct_prompt_parameters",
        "kind": 2,
        "importPath": "tests.unit.ui.test_menu",
        "description": "tests.unit.ui.test_menu",
        "peekOfCode": "def test_display_main_menu_uses_correct_prompt_parameters(mock_rich_output):\n    \"\"\"Test that Prompt.ask is called with the expected choices and default.\"\"\"\n    with patch.object(Prompt, 'ask', return_value=\"1\") as mock_ask:\n        Menu.display_main_menu()\n    # Check the arguments passed to Prompt.ask\n    mock_ask.assert_called_once()\n    # The first argument is the prompt message\n    prompt_message = mock_ask.call_args[0][0]\n    assert \"Select an option\" in prompt_message\n    # The 'choices' and 'default' keyword arguments should match expectations",
        "detail": "tests.unit.ui.test_menu",
        "documentation": {}
    },
    {
        "label": "test_display_main_menu_prints_menu_ui",
        "kind": 2,
        "importPath": "tests.unit.ui.test_menu",
        "description": "tests.unit.ui.test_menu",
        "peekOfCode": "def test_display_main_menu_prints_menu_ui(mock_rich_output):\n    \"\"\"Test that the method attempts to render the menu using console.print.\"\"\"\n    with patch.object(Prompt, 'ask', return_value=\"1\"):\n        Menu.display_main_menu()\n    # The menu should print at least the title panel and the main menu panel.\n    # The minimum number of calls to print to the console is 3:\n    # 1. Newline (console.print(\"\\n\"))\n    # 2. Title Panel (console.print(title))\n    # 3. Menu Panel (console.print(menu_panel))\n    assert mock_rich_output.call_count >= 3",
        "detail": "tests.unit.ui.test_menu",
        "documentation": {}
    },
    {
        "label": "EXPECTED_CHOICES",
        "kind": 5,
        "importPath": "tests.unit.ui.test_menu",
        "description": "tests.unit.ui.test_menu",
        "peekOfCode": "EXPECTED_CHOICES = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"]\n@pytest.fixture\ndef mock_rich_output():\n    \"\"\"Fixture to mock rich.console.Console.print for silencing/checking output.\"\"\"\n    with patch(\"menu.console.print\") as mock_print:\n        yield mock_print\ndef test_display_main_menu_returns_user_choice(mock_rich_output):\n    \"\"\"Test that the method returns the value provided by Prompt.ask.\"\"\"\n    # Mock the rich.prompt.Prompt.ask method to simulate a user selecting '4'\n    expected_choice = \"4\"",
        "detail": "tests.unit.ui.test_menu",
        "documentation": {}
    },
    {
        "label": "mock_managers",
        "kind": 2,
        "importPath": "tests.unit.ui.test_monitoring_menu",
        "description": "tests.unit.ui.test_monitoring_menu",
        "peekOfCode": "def mock_managers():\n    \"\"\"Mock required manager dependencies.\"\"\"\n    mock_monitor_manager = MagicMock()\n    mock_downloader = MagicMock()\n    mock_queue_manager = MagicMock()\n    mock_config_manager = MagicMock()\n    mock_slack_notifier = MagicMock()\n    # Default monitored channels list\n    mock_channel_monitored = Channel(\n        id=1, url=\"http://channel1.com\", title=\"Monitored Channel 1\", is_monitored=True,",
        "detail": "tests.unit.ui.test_monitoring_menu",
        "documentation": {}
    },
    {
        "label": "mock_rich_io",
        "kind": 2,
        "importPath": "tests.unit.ui.test_monitoring_menu",
        "description": "tests.unit.ui.test_monitoring_menu",
        "peekOfCode": "def mock_rich_io(monkeypatch):\n    \"\"\"Mocks all rich console printing and user input methods.\"\"\"\n    mock_console_print = MagicMock()\n    mock_prompt_ask = MagicMock()\n    mock_confirm_ask = MagicMock()\n    mock_intprompt_ask = MagicMock()\n    monkeypatch.setattr(\"monitoring_menu.console.print\", mock_console_print)\n    monkeypatch.setattr(\"monitoring_menu.Prompt.ask\", mock_prompt_ask)\n    monkeypatch.setattr(\"monitoring_menu.Confirm.ask\", mock_confirm_ask)\n    monkeypatch.setattr(\"monitoring_menu.IntPrompt.ask\", mock_intprompt_ask)",
        "detail": "tests.unit.ui.test_monitoring_menu",
        "documentation": {}
    },
    {
        "label": "test_display_monitoring_menu_returns_user_choice",
        "kind": 2,
        "importPath": "tests.unit.ui.test_monitoring_menu",
        "description": "tests.unit.ui.test_monitoring_menu",
        "peekOfCode": "def test_display_monitoring_menu_returns_user_choice(mock_rich_io, mock_managers):\n    \"\"\"Test that the menu returns the selected option.\"\"\"\n    expected_choice = \"3\"  # Start monitoring\n    mock_rich_io[\"prompt\"].return_value = expected_choice\n    choice = MonitoringMenu.display_monitoring_menu(**mock_managers)\n    assert choice == expected_choice\ndef test_display_monitoring_menu_shows_running_status(mock_rich_io, mock_managers):\n    \"\"\"Test that the status panel correctly reflects running state.\"\"\"\n    mock_managers[\"monitor\"].is_running = True\n    MonitoringMenu.display_monitoring_menu(**mock_managers)",
        "detail": "tests.unit.ui.test_monitoring_menu",
        "documentation": {}
    },
    {
        "label": "test_display_monitoring_menu_shows_running_status",
        "kind": 2,
        "importPath": "tests.unit.ui.test_monitoring_menu",
        "description": "tests.unit.ui.test_monitoring_menu",
        "peekOfCode": "def test_display_monitoring_menu_shows_running_status(mock_rich_io, mock_managers):\n    \"\"\"Test that the status panel correctly reflects running state.\"\"\"\n    mock_managers[\"monitor\"].is_running = True\n    MonitoringMenu.display_monitoring_menu(**mock_managers)\n    # Check that 'Running' status text is generated\n    assert \"Running\" in str(mock_rich_io[\"print\"].call_args_list[1]) # Status panel content\ndef test_display_monitoring_menu_lists_monitored_channels(mock_rich_io, mock_managers):\n    \"\"\"Test that the monitored channels table is printed.\"\"\"\n    MonitoringMenu.display_monitoring_menu(**mock_managers)\n    # The console.print calls for the Table object should contain the channel title",
        "detail": "tests.unit.ui.test_monitoring_menu",
        "documentation": {}
    },
    {
        "label": "test_display_monitoring_menu_lists_monitored_channels",
        "kind": 2,
        "importPath": "tests.unit.ui.test_monitoring_menu",
        "description": "tests.unit.ui.test_monitoring_menu",
        "peekOfCode": "def test_display_monitoring_menu_lists_monitored_channels(mock_rich_io, mock_managers):\n    \"\"\"Test that the monitored channels table is printed.\"\"\"\n    MonitoringMenu.display_monitoring_menu(**mock_managers)\n    # The console.print calls for the Table object should contain the channel title\n    table_content = [str(call) for call in mock_rich_io[\"print\"].call_args_list if \"Monitored Channel 1\" in str(call)]\n    assert len(table_content) > 0\n# --- Test add_channel_to_monitoring (New Channel) ---\n@patch(\"monitoring_menu.Path.mkdir\")\n@patch(\"monitoring_menu.Path.exists\", return_value=True) # Mock Path.exists for simplicity\ndef test_add_channel_inserts_new_channel(mock_exists, mock_mkdir, mock_rich_io, mock_managers):",
        "detail": "tests.unit.ui.test_monitoring_menu",
        "documentation": {}
    },
    {
        "label": "test_add_channel_inserts_new_channel",
        "kind": 2,
        "importPath": "tests.unit.ui.test_monitoring_menu",
        "description": "tests.unit.ui.test_monitoring_menu",
        "peekOfCode": "def test_add_channel_inserts_new_channel(mock_exists, mock_mkdir, mock_rich_io, mock_managers):\n    \"\"\"Test adding a completely new channel to monitoring.\"\"\"\n    # 1. Mock downloader.get_playlist_info result\n    mock_managers[\"downloader\"].get_playlist_info.return_value = {\n        'title': 'New Test Playlist',\n        'channel_url': 'http://channel_new.com',\n        'uploader': 'New Uploader',\n    }\n    # 2. Mock user input for quality, directory, interval, template, and order\n    mock_rich_io[\"prompt\"].side_effect = [",
        "detail": "tests.unit.ui.test_monitoring_menu",
        "documentation": {}
    },
    {
        "label": "test_add_channel_updates_existing_channel",
        "kind": 2,
        "importPath": "tests.unit.ui.test_monitoring_menu",
        "description": "tests.unit.ui.test_monitoring_menu",
        "peekOfCode": "def test_add_channel_updates_existing_channel(mock_mkdir, mock_rich_io, mock_managers):\n    \"\"\"Test updating an existing channel to turn on monitoring.\"\"\"\n    # Set up mock existing channel\n    existing_channel = Channel(\n        id=99, url=\"http://existing.com\", title=\"Old Title\", is_monitored=False,\n        quality=\"480p\", format_type=\"audio\"\n    )\n    mock_managers[\"monitor\"].get_channel_by_url.return_value = existing_channel\n    # Mock playlist info that matches the existing channel's URL (channel_url)\n    mock_managers[\"downloader\"].get_playlist_info.return_value = {",
        "detail": "tests.unit.ui.test_monitoring_menu",
        "documentation": {}
    },
    {
        "label": "test_remove_channel_updates_monitoring_status",
        "kind": 2,
        "importPath": "tests.unit.ui.test_monitoring_menu",
        "description": "tests.unit.ui.test_monitoring_menu",
        "peekOfCode": "def test_remove_channel_updates_monitoring_status(mock_rich_io, mock_managers):\n    \"\"\"Test that removing a channel sets its is_monitored flag to False.\"\"\"\n    # Mock user input to select the first monitored channel (index 1)\n    mock_rich_io[\"intprompt\"].return_value = 1\n    # Execution\n    MonitoringMenu.remove_channel_from_monitoring(mock_managers[\"monitor\"])\n    # Assertions\n    mock_channel = mock_managers[\"monitored_channel\"]\n    # The channel object should be updated\n    assert mock_channel.is_monitored is False",
        "detail": "tests.unit.ui.test_monitoring_menu",
        "documentation": {}
    },
    {
        "label": "test_remove_channel_skips_on_no_monitored_channels",
        "kind": 2,
        "importPath": "tests.unit.ui.test_monitoring_menu",
        "description": "tests.unit.ui.test_monitoring_menu",
        "peekOfCode": "def test_remove_channel_skips_on_no_monitored_channels(mock_rich_io, mock_managers):\n    \"\"\"Test that removal is skipped gracefully if no channels are monitored.\"\"\"\n    # Set all channels to unmonitored\n    mock_managers[\"monitor\"].get_all_channels.return_value = [\n        Channel(id=1, url=\"u1\", title=\"C1\", is_monitored=False)\n    ]\n    # Execution\n    MonitoringMenu.remove_channel_from_monitoring(mock_managers[\"monitor\"])\n    # Assertions\n    mock_managers[\"monitor\"].update_channel.assert_not_called()",
        "detail": "tests.unit.ui.test_monitoring_menu",
        "documentation": {}
    },
    {
        "label": "test_get_quality_choice_returns_audio_default",
        "kind": 2,
        "importPath": "tests.unit.ui.test_monitoring_menu",
        "description": "tests.unit.ui.test_monitoring_menu",
        "peekOfCode": "def test_get_quality_choice_returns_audio_default(mock_rich_io):\n    \"\"\"Test that audio format returns '192' immediately.\"\"\"\n    result = MonitoringMenu._get_quality_choice(DownloadFormat.AUDIO.value)\n    assert result == \"192\"\n    assert mock_rich_io[\"prompt\"].call_count == 0\ndef test_get_quality_choice_returns_video_choice(mock_rich_io):\n    \"\"\"Test that video format prompts the user and returns the correct quality string.\"\"\"\n    # User selects option 4 (480p)\n    mock_rich_io[\"prompt\"].return_value = \"4\"\n    result = MonitoringMenu._get_quality_choice(DownloadFormat.VIDEO.value)",
        "detail": "tests.unit.ui.test_monitoring_menu",
        "documentation": {}
    },
    {
        "label": "test_get_quality_choice_returns_video_choice",
        "kind": 2,
        "importPath": "tests.unit.ui.test_monitoring_menu",
        "description": "tests.unit.ui.test_monitoring_menu",
        "peekOfCode": "def test_get_quality_choice_returns_video_choice(mock_rich_io):\n    \"\"\"Test that video format prompts the user and returns the correct quality string.\"\"\"\n    # User selects option 4 (480p)\n    mock_rich_io[\"prompt\"].return_value = \"4\"\n    result = MonitoringMenu._get_quality_choice(DownloadFormat.VIDEO.value)\n    assert result == \"480p\"\n    mock_rich_io[\"prompt\"].assert_called_once()\n# --- Test _get_download_order ---\ndef test_get_download_order_returns_correct_choice(mock_rich_io):\n    \"\"\"Test that download order prompt returns the correct value.\"\"\"",
        "detail": "tests.unit.ui.test_monitoring_menu",
        "documentation": {}
    },
    {
        "label": "test_get_download_order_returns_correct_choice",
        "kind": 2,
        "importPath": "tests.unit.ui.test_monitoring_menu",
        "description": "tests.unit.ui.test_monitoring_menu",
        "peekOfCode": "def test_get_download_order_returns_correct_choice(mock_rich_io):\n    \"\"\"Test that download order prompt returns the correct value.\"\"\"\n    # User selects option 3 (newest_first)\n    mock_rich_io[\"prompt\"].return_value = \"3\"\n    result = MonitoringMenu._get_download_order()\n    assert result == \"newest_first\"\n    mock_rich_io[\"prompt\"].assert_called_once()",
        "detail": "tests.unit.ui.test_monitoring_menu",
        "documentation": {}
    },
    {
        "label": "mock_config_manager",
        "kind": 2,
        "importPath": "tests.unit.ui.test_settings_menu",
        "description": "tests.unit.ui.test_settings_menu",
        "peekOfCode": "def mock_config_manager():\n    \"\"\"Mock ConfigManager object with config attribute.\"\"\"\n    mock_config = MagicMock()\n    mock_config.config = MagicMock()\n    mock_config.config.cookies_file = \"/path/to/cookies.txt\"\n    mock_config.config.proxies = [\"p1\", \"p2\", \"p3\"]\n    mock_config.config.max_workers = 4\n    mock_config.config.default_filename_template = \"{title} [{video_id}]\"\n    mock_config.config.slack_webhook_url = \"http://slack.webhook\"\n    mock_config.config.download_timeout_minutes = 180",
        "detail": "tests.unit.ui.test_settings_menu",
        "documentation": {}
    },
    {
        "label": "mock_rich_io",
        "kind": 2,
        "importPath": "tests.unit.ui.test_settings_menu",
        "description": "tests.unit.ui.test_settings_menu",
        "peekOfCode": "def mock_rich_io(monkeypatch):\n    \"\"\"Mocks all rich console printing and user input methods.\"\"\"\n    mock_console_print = MagicMock()\n    mock_prompt_ask = MagicMock()\n    monkeypatch.setattr(\"settings_menu.console.print\", mock_console_print)\n    monkeypatch.setattr(\"settings_menu.Prompt.ask\", mock_prompt_ask)\n    return {\n        \"print\": mock_console_print,\n        \"prompt\": mock_prompt_ask,\n    }",
        "detail": "tests.unit.ui.test_settings_menu",
        "documentation": {}
    },
    {
        "label": "test_display_settings_menu_returns_user_choice",
        "kind": 2,
        "importPath": "tests.unit.ui.test_settings_menu",
        "description": "tests.unit.ui.test_settings_menu",
        "peekOfCode": "def test_display_settings_menu_returns_user_choice(mock_rich_io, mock_config_manager):\n    \"\"\"Test that the method correctly captures and returns the user's menu choice.\"\"\"\n    expected_choice = \"10\"  # Configure live streams\n    mock_rich_io[\"prompt\"].return_value = expected_choice\n    choice = SettingsMenu.display_settings_menu(mock_config_manager)\n    # Assert the return value matches the mocked input\n    assert choice == expected_choice\n    # Assert Prompt.ask was called with expected choice range\n    mock_rich_io[\"prompt\"].assert_called_once()\n    # Expected choices are 1 through 15",
        "detail": "tests.unit.ui.test_settings_menu",
        "documentation": {}
    },
    {
        "label": "test_display_settings_menu_displays_correct_enabled_statuses",
        "kind": 2,
        "importPath": "tests.unit.ui.test_settings_menu",
        "description": "tests.unit.ui.test_settings_menu",
        "peekOfCode": "def test_display_settings_menu_displays_correct_enabled_statuses(mock_rich_io, mock_config_manager):\n    \"\"\"Test that the menu table correctly reflects enabled settings.\"\"\"\n    # Ensure display uses correct values from mock_config_manager\n    SettingsMenu.display_settings_menu(mock_config_manager)\n    # The console print calls include the content of the rich Table and Panel.\n    # We check if the expected formatted strings (Value column) are present in the mock calls.\n    # Authentication check\n    assert \"Enabled\" in str(mock_config_manager.config.cookies_file)\n    # Proxies check (len(proxies))\n    assert \"3 proxies\" in str(mock_config_manager.config.proxies)",
        "detail": "tests.unit.ui.test_settings_menu",
        "documentation": {}
    },
    {
        "label": "test_display_settings_menu_displays_correct_disabled_statuses",
        "kind": 2,
        "importPath": "tests.unit.ui.test_settings_menu",
        "description": "tests.unit.ui.test_settings_menu",
        "peekOfCode": "def test_display_settings_menu_displays_correct_disabled_statuses(mock_rich_io):\n    \"\"\"Test that the menu table correctly reflects disabled/default settings.\"\"\"\n    # Create a clean config manager with defaults/disabled features\n    mock_config = MagicMock()\n    mock_config.config = MagicMock()\n    mock_config.config.cookies_file = None  # Disabled\n    mock_config.config.proxies = []  # Disabled\n    mock_config.config.max_workers = 3\n    mock_config.config.default_filename_template = \"{index:03d} - {title}\"\n    mock_config.config.slack_webhook_url = None  # Disabled",
        "detail": "tests.unit.ui.test_settings_menu",
        "documentation": {}
    },
    {
        "label": "mock_rich_io",
        "kind": 2,
        "importPath": "tests.unit.ui.test_setup_wizard",
        "description": "tests.unit.ui.test_setup_wizard",
        "peekOfCode": "def mock_rich_io(monkeypatch):\n    \"\"\"Mocks all rich console printing and user input methods.\"\"\"\n    mock_console_print = MagicMock()\n    mock_confirm_ask = MagicMock()\n    mock_prompt_ask = MagicMock()\n    mock_intprompt_ask = MagicMock()\n    monkeypatch.setattr(\"setup_wizard.console.print\", mock_console_print)\n    monkeypatch.setattr(\"setup_wizard.Confirm.ask\", mock_confirm_ask)\n    monkeypatch.setattr(\"setup_wizard.Prompt.ask\", mock_prompt_ask)\n    monkeypatch.setattr(\"setup_wizard.IntPrompt.ask\", mock_intprompt_ask)",
        "detail": "tests.unit.ui.test_setup_wizard",
        "documentation": {}
    },
    {
        "label": "mock_path_exists",
        "kind": 2,
        "importPath": "tests.unit.ui.test_setup_wizard",
        "description": "tests.unit.ui.test_setup_wizard",
        "peekOfCode": "def mock_path_exists(monkeypatch):\n    mock_exists = MagicMock(return_value=True)\n    monkeypatch.setattr(\"pathlib.Path.exists\", mock_exists)\n    return mock_exists\n@pytest.fixture\ndef mock_config_manager():\n    \"\"\"Mock ConfigManager with a real AppConfig instance for state tracking.\"\"\"\n    mock_cm = MagicMock()\n    # Ensure config object is a real AppConfig so attribute changes are tracked\n    mock_cm.config = AppConfig()",
        "detail": "tests.unit.ui.test_setup_wizard",
        "documentation": {}
    },
    {
        "label": "mock_config_manager",
        "kind": 2,
        "importPath": "tests.unit.ui.test_setup_wizard",
        "description": "tests.unit.ui.test_setup_wizard",
        "peekOfCode": "def mock_config_manager():\n    \"\"\"Mock ConfigManager with a real AppConfig instance for state tracking.\"\"\"\n    mock_cm = MagicMock()\n    # Ensure config object is a real AppConfig so attribute changes are tracked\n    mock_cm.config = AppConfig()\n    mock_cm.config.setup_completed = False\n    mock_cm.config.default_filename_template = \"{index:03d} - {title}\"\n    # Mock storage_providers property access\n    mock_cm.config.storage_providers = {}\n    return mock_cm",
        "detail": "tests.unit.ui.test_setup_wizard",
        "documentation": {}
    },
    {
        "label": "test_run_wizard_skips_if_user_confirms_skip",
        "kind": 2,
        "importPath": "tests.unit.ui.test_setup_wizard",
        "description": "tests.unit.ui.test_setup_wizard",
        "peekOfCode": "def test_run_wizard_skips_if_user_confirms_skip(mock_rich_io, mock_config_manager):\n    \"\"\"Test that the wizard exits early if the user selects 'No' to run setup.\"\"\"\n    mock_rich_io[\"confirm\"].return_value = False  # Skip setup\n    SetupWizard.run(mock_config_manager)\n    # Assert setup_completed is set to True\n    assert mock_config_manager.config.setup_completed is True\n    # Assert save_config was called immediately\n    mock_config_manager.save_config.assert_called_once()\n    # Assert no other setup steps were called\n    assert mock_rich_io[\"prompt\"].call_count == 1 # Only the first Confirm.ask is called implicitly",
        "detail": "tests.unit.ui.test_setup_wizard",
        "documentation": {}
    },
    {
        "label": "test_run_wizard_calls_all_setup_steps",
        "kind": 2,
        "importPath": "tests.unit.ui.test_setup_wizard",
        "description": "tests.unit.ui.test_setup_wizard",
        "peekOfCode": "def test_run_wizard_calls_all_setup_steps(mock_auth, mock_quality, mock_workers, mock_rate, mock_storage, mock_notify, mock_summary, mock_rich_io, mock_config_manager):\n    \"\"\"Test that all internal setup methods are called in sequence.\"\"\"\n    mock_rich_io[\"confirm\"].return_value = True # Run setup\n    SetupWizard.run(mock_config_manager)\n    mock_auth.assert_called_once()\n    mock_quality.assert_called_once()\n    mock_workers.assert_called_once()\n    mock_rate.assert_called_once()\n    mock_storage.assert_called_once()\n    mock_notify.assert_called_once()",
        "detail": "tests.unit.ui.test_setup_wizard",
        "documentation": {}
    },
    {
        "label": "test_setup_auth_configures_cookies_file_if_valid",
        "kind": 2,
        "importPath": "tests.unit.ui.test_setup_wizard",
        "description": "tests.unit.ui.test_setup_wizard",
        "peekOfCode": "def test_setup_auth_configures_cookies_file_if_valid(mock_rich_io, mock_config_manager, mock_path_exists):\n    \"\"\"Test configuration when user provides a valid file path.\"\"\"\n    mock_rich_io[\"confirm\"].return_value = True  # Confirm setup\n    mock_rich_io[\"prompt\"].return_value = \"/path/to/cookies.txt\"\n    SetupWizard._setup_authentication(mock_config_manager)\n    assert mock_config_manager.config.cookies_file == \"/path/to/cookies.txt\"\n    mock_config_manager.save_config.assert_called_once()\ndef test_setup_auth_skips_if_file_not_found(mock_rich_io, mock_config_manager):\n    \"\"\"Test configuration is skipped if file path is invalid.\"\"\"\n    mock_rich_io[\"confirm\"].return_value = True",
        "detail": "tests.unit.ui.test_setup_wizard",
        "documentation": {}
    },
    {
        "label": "test_setup_auth_skips_if_file_not_found",
        "kind": 2,
        "importPath": "tests.unit.ui.test_setup_wizard",
        "description": "tests.unit.ui.test_setup_wizard",
        "peekOfCode": "def test_setup_auth_skips_if_file_not_found(mock_rich_io, mock_config_manager):\n    \"\"\"Test configuration is skipped if file path is invalid.\"\"\"\n    mock_rich_io[\"confirm\"].return_value = True\n    mock_rich_io[\"prompt\"].return_value = \"/invalid/path.txt\"\n    with patch(\"pathlib.Path.exists\", return_value=False):\n        SetupWizard._setup_authentication(mock_config_manager)\n    assert mock_config_manager.config.cookies_file is None\n# --- Test _setup_quality ---\ndef test_setup_quality_sets_default_quality(mock_rich_io, mock_config_manager):\n    \"\"\"Test setting specific video and audio quality.\"\"\"",
        "detail": "tests.unit.ui.test_setup_wizard",
        "documentation": {}
    },
    {
        "label": "test_setup_quality_sets_default_quality",
        "kind": 2,
        "importPath": "tests.unit.ui.test_setup_wizard",
        "description": "tests.unit.ui.test_setup_wizard",
        "peekOfCode": "def test_setup_quality_sets_default_quality(mock_rich_io, mock_config_manager):\n    \"\"\"Test setting specific video and audio quality.\"\"\"\n    # Video: 2 (1080p), Audio: 3 (128kbps)\n    mock_rich_io[\"prompt\"].side_effect = [\"2\", \"3\"]\n    SetupWizard._setup_quality(mock_config_manager)\n    assert mock_config_manager.config.default_video_quality == \"1080p\"\n    assert mock_config_manager.config.default_audio_quality == \"128\"\n    mock_config_manager.save_config.assert_called_once()\n# --- Test _setup_workers ---\ndef test_setup_workers_sets_valid_workers(mock_rich_io, mock_config_manager):",
        "detail": "tests.unit.ui.test_setup_wizard",
        "documentation": {}
    },
    {
        "label": "test_setup_workers_sets_valid_workers",
        "kind": 2,
        "importPath": "tests.unit.ui.test_setup_wizard",
        "description": "tests.unit.ui.test_setup_wizard",
        "peekOfCode": "def test_setup_workers_sets_valid_workers(mock_rich_io, mock_config_manager):\n    \"\"\"Test setting a valid number of workers (e.g., 5).\"\"\"\n    mock_rich_io[\"intprompt\"].return_value = 5\n    SetupWizard._setup_workers(mock_config_manager)\n    assert mock_config_manager.config.max_workers == 5\n    mock_config_manager.save_config.assert_called_once()\ndef test_setup_workers_clamps_high_value(mock_rich_io, mock_config_manager):\n    \"\"\"Test that max_workers is clamped at the maximum limit (10).\"\"\"\n    mock_rich_io[\"intprompt\"].return_value = 15\n    SetupWizard._setup_workers(mock_config_manager)",
        "detail": "tests.unit.ui.test_setup_wizard",
        "documentation": {}
    },
    {
        "label": "test_setup_workers_clamps_high_value",
        "kind": 2,
        "importPath": "tests.unit.ui.test_setup_wizard",
        "description": "tests.unit.ui.test_setup_wizard",
        "peekOfCode": "def test_setup_workers_clamps_high_value(mock_rich_io, mock_config_manager):\n    \"\"\"Test that max_workers is clamped at the maximum limit (10).\"\"\"\n    mock_rich_io[\"intprompt\"].return_value = 15\n    SetupWizard._setup_workers(mock_config_manager)\n    assert mock_config_manager.config.max_workers == 10\n# --- Test _setup_rate_limiting ---\ndef test_setup_rate_limiting_applies_moderate_preset(mock_rich_io, mock_config_manager):\n    \"\"\"Test setting the moderate preset (option 2).\"\"\"\n    mock_rich_io[\"prompt\"].return_value = \"2\"\n    SetupWizard._setup_rate_limiting(mock_config_manager)",
        "detail": "tests.unit.ui.test_setup_wizard",
        "documentation": {}
    },
    {
        "label": "test_setup_rate_limiting_applies_moderate_preset",
        "kind": 2,
        "importPath": "tests.unit.ui.test_setup_wizard",
        "description": "tests.unit.ui.test_setup_wizard",
        "peekOfCode": "def test_setup_rate_limiting_applies_moderate_preset(mock_rich_io, mock_config_manager):\n    \"\"\"Test setting the moderate preset (option 2).\"\"\"\n    mock_rich_io[\"prompt\"].return_value = \"2\"\n    SetupWizard._setup_rate_limiting(mock_config_manager)\n    assert mock_config_manager.config.max_downloads_per_hour == 50\n    assert mock_config_manager.config.min_delay_seconds == 2.0\n    assert mock_config_manager.config.max_delay_seconds == 5.0\ndef test_setup_rate_limiting_applies_custom_preset(mock_rich_io, mock_config_manager):\n    \"\"\"Test setting the custom preset (option 4).\"\"\"\n    mock_rich_io[\"prompt\"].side_effect = [\"4\", \"120\", \"0.5\", \"1.5\"]",
        "detail": "tests.unit.ui.test_setup_wizard",
        "documentation": {}
    },
    {
        "label": "test_setup_rate_limiting_applies_custom_preset",
        "kind": 2,
        "importPath": "tests.unit.ui.test_setup_wizard",
        "description": "tests.unit.ui.test_setup_wizard",
        "peekOfCode": "def test_setup_rate_limiting_applies_custom_preset(mock_rich_io, mock_config_manager):\n    \"\"\"Test setting the custom preset (option 4).\"\"\"\n    mock_rich_io[\"prompt\"].side_effect = [\"4\", \"120\", \"0.5\", \"1.5\"]\n    mock_rich_io[\"intprompt\"].return_value = 120 # max_per_hour\n    SetupWizard._setup_rate_limiting(mock_config_manager)\n    assert mock_config_manager.config.max_downloads_per_hour == 120\n    assert mock_config_manager.config.min_delay_seconds == 0.5\n    assert mock_config_manager.config.max_delay_seconds == 1.5\n# --- Test _setup_storage ---\n# Mock StorageMenu dependency to avoid recursive imports",
        "detail": "tests.unit.ui.test_setup_wizard",
        "documentation": {}
    },
    {
        "label": "test_setup_storage_selects_local_and_skips",
        "kind": 2,
        "importPath": "tests.unit.ui.test_setup_wizard",
        "description": "tests.unit.ui.test_setup_wizard",
        "peekOfCode": "def test_setup_storage_selects_local_and_skips(mock_rich_io, mock_config_manager):\n    \"\"\"Test selecting local storage (option 1) and skipping remote setup.\"\"\"\n    mock_rich_io[\"prompt\"].return_value = \"1\"\n    SetupWizard._setup_storage(mock_config_manager)\n    # Assert StorageMenu.add_... methods were NOT called\n    assert SetupWizard.StorageMenu.add_ftp_storage.call_count == 0\n@patch('setup_wizard.StorageMenu', MagicMock())\ndef test_setup_storage_calls_ftp_method(mock_rich_io, mock_config_manager):\n    \"\"\"Test selecting remote (2) and then FTP (1).\"\"\"\n    mock_rich_io[\"prompt\"].side_effect = [\"2\", \"1\"]",
        "detail": "tests.unit.ui.test_setup_wizard",
        "documentation": {}
    },
    {
        "label": "test_setup_storage_calls_ftp_method",
        "kind": 2,
        "importPath": "tests.unit.ui.test_setup_wizard",
        "description": "tests.unit.ui.test_setup_wizard",
        "peekOfCode": "def test_setup_storage_calls_ftp_method(mock_rich_io, mock_config_manager):\n    \"\"\"Test selecting remote (2) and then FTP (1).\"\"\"\n    mock_rich_io[\"prompt\"].side_effect = [\"2\", \"1\"]\n    SetupWizard._setup_storage(mock_config_manager)\n    # Assert the correct storage method was called\n    SetupWizard.StorageMenu.add_ftp_storage.assert_called_once_with(mock_config_manager)\n    # Assert other storage methods were NOT called\n    assert SetupWizard.StorageMenu.add_sftp_storage.call_count == 0\n# --- Test _setup_notifications ---\ndef test_setup_notifications_enables_slack(mock_rich_io, mock_config_manager):",
        "detail": "tests.unit.ui.test_setup_wizard",
        "documentation": {}
    },
    {
        "label": "test_setup_notifications_enables_slack",
        "kind": 2,
        "importPath": "tests.unit.ui.test_setup_wizard",
        "description": "tests.unit.ui.test_setup_wizard",
        "peekOfCode": "def test_setup_notifications_enables_slack(mock_rich_io, mock_config_manager):\n    \"\"\"Test configuring Slack notifications.\"\"\"\n    mock_rich_io[\"confirm\"].return_value = True  # Confirm setup\n    mock_rich_io[\"prompt\"].return_value = \"https://webhook.slack.com/test\"\n    SetupWizard._setup_notifications(mock_config_manager)\n    assert mock_config_manager.config.slack_webhook_url == \"https://webhook.slack.com/test\"\ndef test_setup_notifications_skips_slack(mock_rich_io, mock_config_manager):\n    \"\"\"Test skipping Slack notifications.\"\"\"\n    mock_rich_io[\"confirm\"].return_value = False # Decline setup\n    mock_config_manager.config.slack_webhook_url = None",
        "detail": "tests.unit.ui.test_setup_wizard",
        "documentation": {}
    },
    {
        "label": "test_setup_notifications_skips_slack",
        "kind": 2,
        "importPath": "tests.unit.ui.test_setup_wizard",
        "description": "tests.unit.ui.test_setup_wizard",
        "peekOfCode": "def test_setup_notifications_skips_slack(mock_rich_io, mock_config_manager):\n    \"\"\"Test skipping Slack notifications.\"\"\"\n    mock_rich_io[\"confirm\"].return_value = False # Decline setup\n    mock_config_manager.config.slack_webhook_url = None\n    SetupWizard._setup_notifications(mock_config_manager)\n    assert mock_config_manager.config.slack_webhook_url is None",
        "detail": "tests.unit.ui.test_setup_wizard",
        "documentation": {}
    },
    {
        "label": "mock_managers",
        "kind": 2,
        "importPath": "tests.unit.ui.test_stats_display",
        "description": "tests.unit.ui.test_stats_display",
        "peekOfCode": "def mock_managers():\n    \"\"\"Mock required manager dependencies for testing data retrieval.\"\"\"\n    mock_stats_manager = MagicMock()\n    mock_queue_manager = MagicMock()\n    mock_monitor_manager = MagicMock()\n    # Mock return values for display_statistics\n    mock_stats_manager.get_summary.side_effect = [\n        # summary_7 (Last 7 Days)\n        {\n            'total_downloaded': 50,",
        "detail": "tests.unit.ui.test_stats_display",
        "documentation": {}
    },
    {
        "label": "mock_rich_print",
        "kind": 2,
        "importPath": "tests.unit.ui.test_stats_display",
        "description": "tests.unit.ui.test_stats_display",
        "peekOfCode": "def mock_rich_print(monkeypatch):\n    \"\"\"Mocks rich.console.Console.print for silencing/checking output.\"\"\"\n    mock_print = MagicMock()\n    monkeypatch.setattr(\"stats_display.console.print\", mock_print)\n    return mock_print\n# --- Test Utility Methods ---\ndef test_format_duration():\n    \"\"\"Test _format_duration conversion.\"\"\"\n    assert StatsDisplay._format_duration(30) == \"30.0s\"\n    assert StatsDisplay._format_duration(90) == \"1m 30s\"",
        "detail": "tests.unit.ui.test_stats_display",
        "documentation": {}
    },
    {
        "label": "test_format_duration",
        "kind": 2,
        "importPath": "tests.unit.ui.test_stats_display",
        "description": "tests.unit.ui.test_stats_display",
        "peekOfCode": "def test_format_duration():\n    \"\"\"Test _format_duration conversion.\"\"\"\n    assert StatsDisplay._format_duration(30) == \"30.0s\"\n    assert StatsDisplay._format_duration(90) == \"1m 30s\"\n    assert StatsDisplay._format_duration(3661) == \"1h 1m\"\n    assert StatsDisplay._format_duration(None) == \"N/A\"\n    assert StatsDisplay._format_duration(0) == \"N/A\"\ndef test_format_size():\n    \"\"\"Test _format_size conversion.\"\"\"\n    assert StatsDisplay._format_size(500) == \"500.0 B\"",
        "detail": "tests.unit.ui.test_stats_display",
        "documentation": {}
    },
    {
        "label": "test_format_size",
        "kind": 2,
        "importPath": "tests.unit.ui.test_stats_display",
        "description": "tests.unit.ui.test_stats_display",
        "peekOfCode": "def test_format_size():\n    \"\"\"Test _format_size conversion.\"\"\"\n    assert StatsDisplay._format_size(500) == \"500.0 B\"\n    assert StatsDisplay._format_size(1536) == \"1.5 KB\"\n    assert StatsDisplay._format_size(1048576 * 2.5) == \"2.5 MB\"\n    assert StatsDisplay._format_size(1024**3 * 4) == \"4.0 GB\"\n    assert StatsDisplay._format_size(None) == \"N/A\"\n    assert StatsDisplay._format_size(0) == \"N/A\"\n# --- Test display_statistics ---\ndef test_display_statistics_calls_managers_and_prints_tables(mock_rich_print, mock_managers):",
        "detail": "tests.unit.ui.test_stats_display",
        "documentation": {}
    },
    {
        "label": "test_display_statistics_calls_managers_and_prints_tables",
        "kind": 2,
        "importPath": "tests.unit.ui.test_stats_display",
        "description": "tests.unit.ui.test_stats_display",
        "peekOfCode": "def test_display_statistics_calls_managers_and_prints_tables(mock_rich_print, mock_managers):\n    \"\"\"Verify that manager data retrieval methods are called and tables are printed.\"\"\"\n    StatsDisplay.display_statistics(mock_managers[\"stats_manager\"], mock_managers[\"queue_manager\"])\n    # Assert data retrieval\n    mock_managers[\"stats_manager\"].get_summary.assert_any_call(7)\n    mock_managers[\"stats_manager\"].get_summary.assert_any_call(30)\n    mock_managers[\"stats_manager\"].get_date_range_stats.assert_called_once_with(14)\n    # Assert printing the two tables (Summary and Daily)\n    assert mock_rich_print.call_count >= 5 # 2 newlines + 2 tables + 1 header newline\n    # Verify formatting of key data points in the output",
        "detail": "tests.unit.ui.test_stats_display",
        "documentation": {}
    },
    {
        "label": "test_display_dashboard_calls_managers_and_creates_layout",
        "kind": 2,
        "importPath": "tests.unit.ui.test_stats_display",
        "description": "tests.unit.ui.test_stats_display",
        "peekOfCode": "def test_display_dashboard_calls_managers_and_creates_layout(mock_layout_class, mock_managers):\n    \"\"\"Verify data retrieval for the dashboard panels and layout structure.\"\"\"\n    StatsDisplay.display_dashboard(\n        mock_managers[\"queue_manager\"],\n        mock_managers[\"monitor_manager\"],\n        mock_managers[\"stats_manager\"]\n    )\n    # Assert data retrieval\n    mock_managers[\"queue_manager\"].get_statistics.assert_called_once()\n    mock_managers[\"stats_manager\"].get_summary.assert_called_once_with(7)",
        "detail": "tests.unit.ui.test_stats_display",
        "documentation": {}
    },
    {
        "label": "mock_managers",
        "kind": 2,
        "importPath": "tests.unit.ui.test_storage_menu",
        "description": "tests.unit.ui.test_storage_menu",
        "peekOfCode": "def mock_managers():\n    \"\"\"Mock required manager dependencies.\"\"\"\n    mock_config_manager = MagicMock()\n    mock_storage_manager = MagicMock()\n    # Mock config data\n    mock_config_manager.config = MagicMock()\n    mock_config_manager.config.default_storage = \"local\"\n    mock_config_manager.config.storage_providers = {\n        \"ftp_backup\": StorageConfig(enabled=True, provider_type=\"ftp\", host=\"ftp.example.com\").to_dict(),\n        \"gdrive_archive\": StorageConfig(enabled=False, provider_type=\"gdrive\").to_dict()",
        "detail": "tests.unit.ui.test_storage_menu",
        "documentation": {}
    },
    {
        "label": "mock_rich_io",
        "kind": 2,
        "importPath": "tests.unit.ui.test_storage_menu",
        "description": "tests.unit.ui.test_storage_menu",
        "peekOfCode": "def mock_rich_io(monkeypatch):\n    \"\"\"Mocks all rich console printing and user input methods.\"\"\"\n    mock_console_print = MagicMock()\n    mock_prompt_ask = MagicMock()\n    mock_confirm_ask = MagicMock()\n    mock_intprompt_ask = MagicMock()\n    monkeypatch.setattr(\"storage_menu.console.print\", mock_console_print)\n    monkeypatch.setattr(\"storage_menu.Prompt.ask\", mock_prompt_ask)\n    monkeypatch.setattr(\"storage_menu.Confirm.ask\", mock_confirm_ask)\n    monkeypatch.setattr(\"storage_menu.IntPrompt.ask\", mock_intprompt_ask)",
        "detail": "tests.unit.ui.test_storage_menu",
        "documentation": {}
    },
    {
        "label": "mock_storage_utils",
        "kind": 2,
        "importPath": "tests.unit.ui.test_storage_menu",
        "description": "tests.unit.ui.test_storage_menu",
        "peekOfCode": "def mock_storage_utils(monkeypatch):\n    \"\"\"Mocks the external storage provider classes.\"\"\"\n    mock_provider = MagicMock()\n    mock_provider.connect.return_value = True\n    mock_provider.disconnect.return_value = None\n    mock_ftp = MagicMock(return_value=mock_provider)\n    mock_sftp = MagicMock(return_value=mock_provider)\n    mock_gdrive = MagicMock(return_value=mock_provider)\n    mock_dropbox = MagicMock(return_value=mock_provider)\n    mock_onedrive = MagicMock(return_value=mock_provider)",
        "detail": "tests.unit.ui.test_storage_menu",
        "documentation": {}
    },
    {
        "label": "test_display_storage_menu_returns_user_choice",
        "kind": 2,
        "importPath": "tests.unit.ui.test_storage_menu",
        "description": "tests.unit.ui.test_storage_menu",
        "peekOfCode": "def test_display_storage_menu_returns_user_choice(mock_rich_io, mock_managers):\n    \"\"\"Test that the menu returns the selected option.\"\"\"\n    expected_choice = \"6\"  # Configure storage provider\n    mock_rich_io[\"prompt\"].return_value = expected_choice\n    choice = StorageMenu.display_storage_menu(**mock_managers)\n    assert choice == expected_choice\ndef test_display_storage_menu_shows_current_state(mock_rich_io, mock_managers):\n    \"\"\"Test that the display reflects the default storage and provider count.\"\"\"\n    StorageMenu.display_storage_menu(**mock_managers)\n    # Verify the status panel content is printed",
        "detail": "tests.unit.ui.test_storage_menu",
        "documentation": {}
    },
    {
        "label": "test_display_storage_menu_shows_current_state",
        "kind": 2,
        "importPath": "tests.unit.ui.test_storage_menu",
        "description": "tests.unit.ui.test_storage_menu",
        "peekOfCode": "def test_display_storage_menu_shows_current_state(mock_rich_io, mock_managers):\n    \"\"\"Test that the display reflects the default storage and provider count.\"\"\"\n    StorageMenu.display_storage_menu(**mock_managers)\n    # Verify the status panel content is printed\n    output = str(mock_rich_io[\"print\"].call_args_list[1])\n    assert \"Default Storage: local\" in output\n    assert \"Configured Providers: 2\" in output\n# --- Test add_ftp_storage ---\ndef test_add_ftp_storage_collects_input_and_calls_add(mock_rich_io, mock_managers):\n    \"\"\"Test gathering input for FTP and calling add_storage_provider.\"\"\"",
        "detail": "tests.unit.ui.test_storage_menu",
        "documentation": {}
    },
    {
        "label": "test_add_ftp_storage_collects_input_and_calls_add",
        "kind": 2,
        "importPath": "tests.unit.ui.test_storage_menu",
        "description": "tests.unit.ui.test_storage_menu",
        "peekOfCode": "def test_add_ftp_storage_collects_input_and_calls_add(mock_rich_io, mock_managers):\n    \"\"\"Test gathering input for FTP and calling add_storage_provider.\"\"\"\n    # Simulate user input\n    mock_rich_io[\"prompt\"].side_effect = [\n        \"home_ftp\",        # name\n        \"ftp.myhost.com\",  # host\n        \"user1\",           # username\n        \"mypass\",          # password\n        \"/data\",           # base_path\n        \"\",                # video_quality (default)",
        "detail": "tests.unit.ui.test_storage_menu",
        "documentation": {}
    },
    {
        "label": "test_add_sftp_storage_key_auth",
        "kind": 2,
        "importPath": "tests.unit.ui.test_storage_menu",
        "description": "tests.unit.ui.test_storage_menu",
        "peekOfCode": "def test_add_sftp_storage_key_auth(mock_rich_io, mock_managers):\n    \"\"\"Test adding SFTP using key authentication.\"\"\"\n    # Simulate user input\n    mock_rich_io[\"prompt\"].side_effect = [\n        \"sftp_repo\",\n        \"sftp.myhost.com\",\n        \"ssh_user\",\n        \"/home/user/.ssh/id_rsa\", # key_filename\n        \"/backup\",\n        \"720p\",",
        "detail": "tests.unit.ui.test_storage_menu",
        "documentation": {}
    },
    {
        "label": "test_add_gdrive_storage",
        "kind": 2,
        "importPath": "tests.unit.ui.test_storage_menu",
        "description": "tests.unit.ui.test_storage_menu",
        "peekOfCode": "def test_add_gdrive_storage(mock_exists, mock_rich_io, mock_managers):\n    \"\"\"Test adding Google Drive storage.\"\"\"\n    mock_rich_io[\"prompt\"].side_effect = [\n        \"gdrive_main\",\n        \"/path/to/creds.json\", # credentials_file\n        \"folder_id_xyz\",\n        \"\", # video_quality\n        \"320\", # audio_quality\n    ]\n    StorageMenu.add_google_drive_storage(mock_managers[\"config_manager\"])",
        "detail": "tests.unit.ui.test_storage_menu",
        "documentation": {}
    },
    {
        "label": "test_configure_storage_provider_updates_quality_and_status",
        "kind": 2,
        "importPath": "tests.unit.ui.test_storage_menu",
        "description": "tests.unit.ui.test_storage_menu",
        "peekOfCode": "def test_configure_storage_provider_updates_quality_and_status(mock_rich_io, mock_managers):\n    \"\"\"Test updating existing provider settings (enabled status and quality).\"\"\"\n    # 1. User input: Select 'ftp_backup' (1)\n    mock_rich_io[\"intprompt\"].return_value = 1\n    # 2. User input: Disable storage and change quality\n    mock_rich_io[\"confirm\"].return_value = False # Disable\n    mock_rich_io[\"prompt\"].side_effect = [\n        \"360p\", # new video quality\n        \"\",     # skip audio quality change (keep existing)\n    ]",
        "detail": "tests.unit.ui.test_storage_menu",
        "documentation": {}
    },
    {
        "label": "test_remove_storage_provider_confirms_and_removes",
        "kind": 2,
        "importPath": "tests.unit.ui.test_storage_menu",
        "description": "tests.unit.ui.test_storage_menu",
        "peekOfCode": "def test_remove_storage_provider_confirms_and_removes(mock_rich_io, mock_managers):\n    \"\"\"Test selecting and confirming removal of a provider.\"\"\"\n    # 1. User input: Select 'gdrive_archive' (2)\n    mock_rich_io[\"intprompt\"].return_value = 2\n    # 2. User input: Confirm removal\n    mock_rich_io[\"confirm\"].return_value = True\n    # Execution\n    StorageMenu.remove_storage_provider(mock_managers[\"config_manager\"])\n    # Assertions\n    mock_managers[\"config_manager\"].remove_storage_provider.assert_called_once_with(\"gdrive_archive\")",
        "detail": "tests.unit.ui.test_storage_menu",
        "documentation": {}
    },
    {
        "label": "test_set_default_storage",
        "kind": 2,
        "importPath": "tests.unit.ui.test_storage_menu",
        "description": "tests.unit.ui.test_storage_menu",
        "peekOfCode": "def test_set_default_storage(mock_rich_io, mock_managers):\n    \"\"\"Test setting a configured provider as the new default.\"\"\"\n    # Providers list is [\"local\", \"ftp_backup\", \"gdrive_archive\"]\n    # 1. User input: Select 'ftp_backup' (2)\n    mock_rich_io[\"intprompt\"].return_value = 2\n    # Execution\n    StorageMenu.set_default_storage(mock_managers[\"config_manager\"])\n    # Assertions\n    mock_managers[\"config_manager\"].set_default_storage.assert_called_once_with(\"ftp_backup\")\n# --- Test test_storage_connections ---",
        "detail": "tests.unit.ui.test_storage_menu",
        "documentation": {}
    },
    {
        "label": "test_test_storage_connections_success",
        "kind": 2,
        "importPath": "tests.unit.ui.test_storage_menu",
        "description": "tests.unit.ui.test_storage_menu",
        "peekOfCode": "def test_test_storage_connections_success(mock_rich_io, mock_managers, mock_storage_utils):\n    \"\"\"Test that connections are attempted and reported as successful.\"\"\"\n    # Execution\n    StorageMenu.test_storage_connections(**mock_managers)\n    # Assert connection was attempted for ftp_backup (which is enabled)\n    mock_storage_utils.connect.assert_called_once()\n    # Assert ftp_backup was marked as Connected\n    output = str(mock_rich_io[\"print\"].call_args_list[-1])\n    assert \"ftp_backup\" in output\n    assert \"Connected\" in output",
        "detail": "tests.unit.ui.test_storage_menu",
        "documentation": {}
    },
    {
        "label": "test_test_storage_connections_failure",
        "kind": 2,
        "importPath": "tests.unit.ui.test_storage_menu",
        "description": "tests.unit.ui.test_storage_menu",
        "peekOfCode": "def test_test_storage_connections_failure(mock_rich_io, mock_managers, mock_storage_utils):\n    \"\"\"Test that failed connections are correctly reported.\"\"\"\n    # Configure the mock provider to fail connection\n    mock_storage_utils.connect.return_value = False\n    # Execution\n    StorageMenu.test_storage_connections(**mock_managers)\n    # Assert failure status is reported\n    output = str(mock_rich_io[\"print\"].call_args_list[-1])\n    assert \"ftp_backup\" in output\n    assert \"Failed\" in output",
        "detail": "tests.unit.ui.test_storage_menu",
        "documentation": {}
    },
    {
        "label": "test_normalize_title",
        "kind": 2,
        "importPath": "tests.unit.utils.test_file_renamer",
        "description": "tests.unit.utils.test_file_renamer",
        "peekOfCode": "def test_normalize_title(title, expected, case_sensitive):\n    \"\"\"Test various aspects of title normalization and case handling.\"\"\"\n    result = FileRenamer.normalize_title(title, sentence_case=case_sensitive)\n    assert result == expected\n# --- Test sanitize_filename ---\n@pytest.mark.parametrize(\"filename, normalize, expected\", [\n    # Basic sanitation (with normalization)\n    (\"Test <file> / path: name.mp4\", True, \"Test file path name\"),\n    # Invalid characters removal (without normalization)\n    (\"File/Path*?|<>:\", False, \"FilePath\"),",
        "detail": "tests.unit.utils.test_file_renamer",
        "documentation": {}
    },
    {
        "label": "test_sanitize_filename",
        "kind": 2,
        "importPath": "tests.unit.utils.test_file_renamer",
        "description": "tests.unit.utils.test_file_renamer",
        "peekOfCode": "def test_sanitize_filename(filename, normalize, expected):\n    \"\"\"Test removing invalid filesystem characters and handling normalization flag.\"\"\"\n    result = FileRenamer.sanitize_filename(filename, normalize=normalize)\n    assert result == expected\n# --- Test apply_template ---\n@pytest.mark.parametrize(\"template, title, uploader, index, playlist, normalize, expected_output\", [\n    # Basic template application\n    (\"{index} - {title}\", \"My Video\", \"Uploader\", 10, \"\", True, \"10 - My Video\"),\n    # Template with format specifier\n    (\"{index:03d} - {title}\", \"My Video\", \"Uploader\", 5, \"\", True, \"005 - My Video\"),",
        "detail": "tests.unit.utils.test_file_renamer",
        "documentation": {}
    },
    {
        "label": "test_apply_template",
        "kind": 2,
        "importPath": "tests.unit.utils.test_file_renamer",
        "description": "tests.unit.utils.test_file_renamer",
        "peekOfCode": "def test_apply_template(template, title, uploader, index, playlist, normalize, expected_output):\n    \"\"\"Test applying templates, including format specifiers and final sanitization.\"\"\"\n    # Note: We rely on sanitize_filename's mock for testing normalize=False on final output\n    # but the internal recursive calls to sanitize_filename for placeholders use the 'normalize' flag.\n    result = FileRenamer.apply_template(\n        template=template,\n        title=title,\n        uploader=uploader,\n        upload_date=\"Unknown\",\n        index=index,",
        "detail": "tests.unit.utils.test_file_renamer",
        "documentation": {}
    },
    {
        "label": "project_root",
        "kind": 5,
        "importPath": "tests.unit.utils.test_file_renamer",
        "description": "tests.unit.utils.test_file_renamer",
        "peekOfCode": "project_root = Path(__file__).resolve().parent\nif str(project_root) not in sys.path:\n    sys.path.insert(0, str(project_root))\n# -------------------------------\nfrom ...utils.file_renamer import FileRenamer\n# --- Test normalize_title ---\n@pytest.mark.parametrize(\"title, expected, case_sensitive\", [\n    # Basic cleaning and whitespace\n    (\" My Cool Video \", \"My cool video\", True),\n    (\"Title with    lots of space\", \"Title with lots of space\", True),",
        "detail": "tests.unit.utils.test_file_renamer",
        "documentation": {}
    },
    {
        "label": "mock_mutagen",
        "kind": 2,
        "importPath": "tests.unit.utils.test_metadata_handler",
        "description": "tests.unit.utils.test_metadata_handler",
        "peekOfCode": "def mock_mutagen(monkeypatch):\n    \"\"\"Mocks mutagen imports for safe execution.\"\"\"\n    mock_mutagen_module = MagicMock()\n    # Mock specific classes used in the source file\n    mock_mutagen_module.mp4.MP4 = MagicMock()\n    mock_mutagen_module.mp4.MP4Cover = MagicMock()\n    mock_mutagen_module.id3.ID3 = MagicMock()\n    mock_mutagen_module.mp3.MP3 = MagicMock()\n    # Apply the mock to the module's imports\n    monkeypatch.setattr('utils.metadata_handler.mutagen', mock_mutagen_module, raising=False)",
        "detail": "tests.unit.utils.test_metadata_handler",
        "documentation": {}
    },
    {
        "label": "test_set_video_metadata_dispatches_mp4",
        "kind": 2,
        "importPath": "tests.unit.utils.test_metadata_handler",
        "description": "tests.unit.utils.test_metadata_handler",
        "peekOfCode": "def test_set_video_metadata_dispatches_mp4(mock_suffix, mock_mp3, mock_mp4, mock_mutagen):\n    \"\"\"Test that .mp4 files are routed to _set_mp4_metadata.\"\"\"\n    MetadataHandler.set_video_metadata(\"test.mp4\", {})\n    mock_mp4.assert_called_once()\n    mock_mp3.assert_not_called()\n@patch.object(MetadataHandler, '_set_mp4_metadata')\n@patch.object(MetadataHandler, '_set_mp3_metadata')\n@patch.object(Path, 'suffix', new_callable=lambda: MagicMock(return_value='.mp3'))\ndef test_set_video_metadata_dispatches_mp3(mock_suffix, mock_mp3, mock_mp4, mock_mutagen):\n    \"\"\"Test that .mp3 files are routed to _set_mp3_metadata.\"\"\"",
        "detail": "tests.unit.utils.test_metadata_handler",
        "documentation": {}
    },
    {
        "label": "test_set_video_metadata_dispatches_mp3",
        "kind": 2,
        "importPath": "tests.unit.utils.test_metadata_handler",
        "description": "tests.unit.utils.test_metadata_handler",
        "peekOfCode": "def test_set_video_metadata_dispatches_mp3(mock_suffix, mock_mp3, mock_mp4, mock_mutagen):\n    \"\"\"Test that .mp3 files are routed to _set_mp3_metadata.\"\"\"\n    MetadataHandler.set_video_metadata(\"test.mp3\", {})\n    mock_mp3.assert_called_once()\n    mock_mp4.assert_not_called()\n@patch.object(MetadataHandler, '_set_mp4_metadata')\n@patch.object(Path, 'suffix', new_callable=lambda: MagicMock(return_value='.avi'))\ndef test_set_video_metadata_unsupported_format(mock_suffix, mock_mp4, mock_mutagen, capsys):\n    \"\"\"Test handling of unsupported file types.\"\"\"\n    MetadataHandler.set_video_metadata(\"test.avi\", {})",
        "detail": "tests.unit.utils.test_metadata_handler",
        "documentation": {}
    },
    {
        "label": "test_set_video_metadata_unsupported_format",
        "kind": 2,
        "importPath": "tests.unit.utils.test_metadata_handler",
        "description": "tests.unit.utils.test_metadata_handler",
        "peekOfCode": "def test_set_video_metadata_unsupported_format(mock_suffix, mock_mp4, mock_mutagen, capsys):\n    \"\"\"Test handling of unsupported file types.\"\"\"\n    MetadataHandler.set_video_metadata(\"test.avi\", {})\n    mock_mp4.assert_not_called()\n    assert \"Metadata not supported for .avi files\" in capsys.readouterr().out\n@patch.object(MetadataHandler, '_set_mp4_metadata')\n@patch.dict('sys.modules', {'mutagen': None})\ndef test_set_video_metadata_mutagen_not_installed(mock_mp4, capsys):\n    \"\"\"Test handling when mutagen is not importable (ImportError).\"\"\"\n    # Need to remove the mock and replace it with None to simulate failure",
        "detail": "tests.unit.utils.test_metadata_handler",
        "documentation": {}
    },
    {
        "label": "test_set_video_metadata_mutagen_not_installed",
        "kind": 2,
        "importPath": "tests.unit.utils.test_metadata_handler",
        "description": "tests.unit.utils.test_metadata_handler",
        "peekOfCode": "def test_set_video_metadata_mutagen_not_installed(mock_mp4, capsys):\n    \"\"\"Test handling when mutagen is not importable (ImportError).\"\"\"\n    # Need to remove the mock and replace it with None to simulate failure\n    with pytest.raises(TypeError): # Mutagen will be None, triggering an early TypeError in the source\n        MetadataHandler.set_video_metadata(\"test.mp4\", {})\n    # We must patch the initial try block logic to check for the console output\n    with patch('utils.metadata_handler.console') as mock_console:\n        try:\n            from mutagen.mp4 import MP4\n        except ImportError:",
        "detail": "tests.unit.utils.test_metadata_handler",
        "documentation": {}
    },
    {
        "label": "test_extract_metadata_full_mapping",
        "kind": 2,
        "importPath": "tests.unit.utils.test_metadata_handler",
        "description": "tests.unit.utils.test_metadata_handler",
        "peekOfCode": "def test_extract_metadata_full_mapping(video_info, index, playlist_title, expected_fields):\n    \"\"\"Test that metadata is extracted correctly according to rules.\"\"\"\n    metadata = MetadataHandler.extract_metadata(video_info, index, playlist_title)\n    # Check that all expected fields are present and correct\n    for key, value in expected_fields.items():\n        assert metadata.get(key) == value\n    # Check that no unexpected fields are present (e.g., 'channel' shouldn't be present)\n    assert 'channel' not in metadata\ndef test_extract_metadata_uploader_priority():\n    \"\"\"Test that 'uploader' takes priority over 'channel' for the 'artist' field.\"\"\"",
        "detail": "tests.unit.utils.test_metadata_handler",
        "documentation": {}
    },
    {
        "label": "test_extract_metadata_uploader_priority",
        "kind": 2,
        "importPath": "tests.unit.utils.test_metadata_handler",
        "description": "tests.unit.utils.test_metadata_handler",
        "peekOfCode": "def test_extract_metadata_uploader_priority():\n    \"\"\"Test that 'uploader' takes priority over 'channel' for the 'artist' field.\"\"\"\n    video_info = {\n        'uploader': 'Primary Uploader',\n        'channel': 'Secondary Channel'\n    }\n    metadata = MetadataHandler.extract_metadata(video_info)\n    assert metadata.get('artist') == 'Primary Uploader'\ndef test_extract_metadata_playlist_title_priority():\n    \"\"\"Test that playlist_title argument takes priority over 'playlist' key in video_info.\"\"\"",
        "detail": "tests.unit.utils.test_metadata_handler",
        "documentation": {}
    },
    {
        "label": "test_extract_metadata_playlist_title_priority",
        "kind": 2,
        "importPath": "tests.unit.utils.test_metadata_handler",
        "description": "tests.unit.utils.test_metadata_handler",
        "peekOfCode": "def test_extract_metadata_playlist_title_priority():\n    \"\"\"Test that playlist_title argument takes priority over 'playlist' key in video_info.\"\"\"\n    video_info = {\n        'playlist': 'Video Info Playlist Name'\n    }\n    metadata = MetadataHandler.extract_metadata(video_info, playlist_title=\"External Playlist Name\")\n    assert metadata.get('album') == 'External Playlist Name'",
        "detail": "tests.unit.utils.test_metadata_handler",
        "documentation": {}
    },
    {
        "label": "project_root",
        "kind": 5,
        "importPath": "tests.unit.utils.test_metadata_handler",
        "description": "tests.unit.utils.test_metadata_handler",
        "peekOfCode": "project_root = Path(__file__).resolve().parent\nif str(project_root) not in sys.path:\n    sys.path.insert(0, str(project_root))\n# -------------------------------\nfrom utils.metadata_handler import MetadataHandler\n# Mock mutagen to prevent ImportErrors when running tests\n@pytest.fixture(autouse=True)\ndef mock_mutagen(monkeypatch):\n    \"\"\"Mocks mutagen imports for safe execution.\"\"\"\n    mock_mutagen_module = MagicMock()",
        "detail": "tests.unit.utils.test_metadata_handler",
        "documentation": {}
    },
    {
        "label": "mock_datetime_now",
        "kind": 2,
        "importPath": "tests.unit.utils.test_oauth_handler",
        "description": "tests.unit.utils.test_oauth_handler",
        "peekOfCode": "def mock_datetime_now():\n    \"\"\"Patches datetime.now() for deterministic time control.\"\"\"\n    test_now = datetime(2025, 1, 1, 12, 0, 0)\n    with patch('utils.oauth_handler.datetime') as mock_dt:\n        mock_dt.now.return_value = test_now\n        # Ensure we can still access timedelta\n        mock_dt.timedelta = timedelta\n        # Mock fromisoformat to be callable\n        mock_dt.fromisoformat = datetime.fromisoformat\n        yield mock_dt",
        "detail": "tests.unit.utils.test_oauth_handler",
        "documentation": {}
    },
    {
        "label": "test_is_authenticated_no_token",
        "kind": 2,
        "importPath": "tests.unit.utils.test_oauth_handler",
        "description": "tests.unit.utils.test_oauth_handler",
        "peekOfCode": "def test_is_authenticated_no_token():\n    \"\"\"Should return False if oauth_token is None.\"\"\"\n    handler = OAuthHandler(oauth_token=None)\n    assert handler.is_authenticated() is False\ndef test_is_authenticated_token_valid(mock_datetime_now):\n    \"\"\"Should return True if token exists and expiry is in the future.\"\"\"\n    expiry_future = (mock_datetime_now.now() + timedelta(hours=1)).isoformat()\n    handler = OAuthHandler(oauth_token=\"valid_token_xyz\", oauth_expiry=expiry_future)\n    assert handler.is_authenticated() is True\n@patch.object(OAuthHandler, 'refresh_token', return_value=True)",
        "detail": "tests.unit.utils.test_oauth_handler",
        "documentation": {}
    },
    {
        "label": "test_is_authenticated_token_valid",
        "kind": 2,
        "importPath": "tests.unit.utils.test_oauth_handler",
        "description": "tests.unit.utils.test_oauth_handler",
        "peekOfCode": "def test_is_authenticated_token_valid(mock_datetime_now):\n    \"\"\"Should return True if token exists and expiry is in the future.\"\"\"\n    expiry_future = (mock_datetime_now.now() + timedelta(hours=1)).isoformat()\n    handler = OAuthHandler(oauth_token=\"valid_token_xyz\", oauth_expiry=expiry_future)\n    assert handler.is_authenticated() is True\n@patch.object(OAuthHandler, 'refresh_token', return_value=True)\ndef test_is_authenticated_token_expired_refresh_success(mock_refresh, mock_datetime_now):\n    \"\"\"Should attempt refresh if token is expired, and return result of refresh.\"\"\"\n    expiry_past = (mock_datetime_now.now() - timedelta(minutes=1)).isoformat()\n    handler = OAuthHandler(oauth_token=\"expired_token\", oauth_expiry=expiry_past)",
        "detail": "tests.unit.utils.test_oauth_handler",
        "documentation": {}
    },
    {
        "label": "test_is_authenticated_token_expired_refresh_success",
        "kind": 2,
        "importPath": "tests.unit.utils.test_oauth_handler",
        "description": "tests.unit.utils.test_oauth_handler",
        "peekOfCode": "def test_is_authenticated_token_expired_refresh_success(mock_refresh, mock_datetime_now):\n    \"\"\"Should attempt refresh if token is expired, and return result of refresh.\"\"\"\n    expiry_past = (mock_datetime_now.now() - timedelta(minutes=1)).isoformat()\n    handler = OAuthHandler(oauth_token=\"expired_token\", oauth_expiry=expiry_past)\n    result = handler.is_authenticated()\n    mock_refresh.assert_called_once()\n    assert result is True\n@patch.object(OAuthHandler, 'refresh_token', return_value=False)\ndef test_is_authenticated_token_expired_refresh_failure(mock_refresh, mock_datetime_now):\n    \"\"\"If refresh fails, authentication should fail.\"\"\"",
        "detail": "tests.unit.utils.test_oauth_handler",
        "documentation": {}
    },
    {
        "label": "test_is_authenticated_token_expired_refresh_failure",
        "kind": 2,
        "importPath": "tests.unit.utils.test_oauth_handler",
        "description": "tests.unit.utils.test_oauth_handler",
        "peekOfCode": "def test_is_authenticated_token_expired_refresh_failure(mock_refresh, mock_datetime_now):\n    \"\"\"If refresh fails, authentication should fail.\"\"\"\n    expiry_past = (mock_datetime_now.now() - timedelta(minutes=1)).isoformat()\n    handler = OAuthHandler(oauth_token=\"expired_token\", oauth_expiry=expiry_past)\n    result = handler.is_authenticated()\n    mock_refresh.assert_called_once()\n    assert result is False\ndef test_is_authenticated_invalid_expiry_format():\n    \"\"\"Should return False if oauth_expiry is not a valid ISO format string.\"\"\"\n    handler = OAuthHandler(oauth_token=\"token\", oauth_expiry=\"not_a_date\")",
        "detail": "tests.unit.utils.test_oauth_handler",
        "documentation": {}
    },
    {
        "label": "test_is_authenticated_invalid_expiry_format",
        "kind": 2,
        "importPath": "tests.unit.utils.test_oauth_handler",
        "description": "tests.unit.utils.test_oauth_handler",
        "peekOfCode": "def test_is_authenticated_invalid_expiry_format():\n    \"\"\"Should return False if oauth_expiry is not a valid ISO format string.\"\"\"\n    handler = OAuthHandler(oauth_token=\"token\", oauth_expiry=\"not_a_date\")\n    assert handler.is_authenticated() is False\ndef test_is_authenticated_no_expiry_set():\n    \"\"\"If token exists but no expiry is set, assume it is valid (default safe mode).\"\"\"\n    handler = OAuthHandler(oauth_token=\"perma_token\", oauth_expiry=None)\n    assert handler.is_authenticated() is True\n# --- Test get_auth_header() ---\n@patch.object(OAuthHandler, 'is_authenticated', return_value=True)",
        "detail": "tests.unit.utils.test_oauth_handler",
        "documentation": {}
    },
    {
        "label": "test_is_authenticated_no_expiry_set",
        "kind": 2,
        "importPath": "tests.unit.utils.test_oauth_handler",
        "description": "tests.unit.utils.test_oauth_handler",
        "peekOfCode": "def test_is_authenticated_no_expiry_set():\n    \"\"\"If token exists but no expiry is set, assume it is valid (default safe mode).\"\"\"\n    handler = OAuthHandler(oauth_token=\"perma_token\", oauth_expiry=None)\n    assert handler.is_authenticated() is True\n# --- Test get_auth_header() ---\n@patch.object(OAuthHandler, 'is_authenticated', return_value=True)\ndef test_get_auth_header_authenticated(mock_auth):\n    \"\"\"Should return the correct Authorization header if authenticated.\"\"\"\n    token = \"final_token_123\"\n    handler = OAuthHandler(oauth_token=token)",
        "detail": "tests.unit.utils.test_oauth_handler",
        "documentation": {}
    },
    {
        "label": "test_get_auth_header_authenticated",
        "kind": 2,
        "importPath": "tests.unit.utils.test_oauth_handler",
        "description": "tests.unit.utils.test_oauth_handler",
        "peekOfCode": "def test_get_auth_header_authenticated(mock_auth):\n    \"\"\"Should return the correct Authorization header if authenticated.\"\"\"\n    token = \"final_token_123\"\n    handler = OAuthHandler(oauth_token=token)\n    header = handler.get_auth_header()\n    assert header == {\"Authorization\": f\"Bearer {token}\"}\n    mock_auth.assert_called_once()\n@patch.object(OAuthHandler, 'is_authenticated', return_value=False)\ndef test_get_auth_header_not_authenticated(mock_auth):\n    \"\"\"Should return None if not authenticated.\"\"\"",
        "detail": "tests.unit.utils.test_oauth_handler",
        "documentation": {}
    },
    {
        "label": "test_get_auth_header_not_authenticated",
        "kind": 2,
        "importPath": "tests.unit.utils.test_oauth_handler",
        "description": "tests.unit.utils.test_oauth_handler",
        "peekOfCode": "def test_get_auth_header_not_authenticated(mock_auth):\n    \"\"\"Should return None if not authenticated.\"\"\"\n    handler = OAuthHandler(oauth_token=\"token\")\n    header = handler.get_auth_header()\n    assert header is None\n    mock_auth.assert_called_once()\n# --- Test Placeholder Methods ---\ndef test_authenticate_placeholder():\n    \"\"\"Placeholder method should return False.\"\"\"\n    handler = OAuthHandler()",
        "detail": "tests.unit.utils.test_oauth_handler",
        "documentation": {}
    },
    {
        "label": "test_authenticate_placeholder",
        "kind": 2,
        "importPath": "tests.unit.utils.test_oauth_handler",
        "description": "tests.unit.utils.test_oauth_handler",
        "peekOfCode": "def test_authenticate_placeholder():\n    \"\"\"Placeholder method should return False.\"\"\"\n    handler = OAuthHandler()\n    assert handler.authenticate() is False\ndef test_refresh_token_placeholder():\n    \"\"\"Placeholder method should return False.\"\"\"\n    handler = OAuthHandler()\n    assert handler.refresh_token() is False",
        "detail": "tests.unit.utils.test_oauth_handler",
        "documentation": {}
    },
    {
        "label": "test_refresh_token_placeholder",
        "kind": 2,
        "importPath": "tests.unit.utils.test_oauth_handler",
        "description": "tests.unit.utils.test_oauth_handler",
        "peekOfCode": "def test_refresh_token_placeholder():\n    \"\"\"Placeholder method should return False.\"\"\"\n    handler = OAuthHandler()\n    assert handler.refresh_token() is False",
        "detail": "tests.unit.utils.test_oauth_handler",
        "documentation": {}
    },
    {
        "label": "MockConsole",
        "kind": 6,
        "importPath": "tests.unit.utils.test_storage_providers",
        "description": "tests.unit.utils.test_storage_providers",
        "peekOfCode": "class MockConsole:\n    def print(self, *args, **kwargs):\n        pass\n@pytest.fixture(scope=\"module\", autouse=True)\ndef mock_rich_console():\n    \"\"\"Patches the rich console globally to prevent test output.\"\"\"\n    with patch('utils.storage_providers.console', MockConsole()):\n        yield\n# --- Test StorageProvider Base Class ---\ndef test_storage_provider_is_abstract():",
        "detail": "tests.unit.utils.test_storage_providers",
        "documentation": {}
    },
    {
        "label": "mock_rich_console",
        "kind": 2,
        "importPath": "tests.unit.utils.test_storage_providers",
        "description": "tests.unit.utils.test_storage_providers",
        "peekOfCode": "def mock_rich_console():\n    \"\"\"Patches the rich console globally to prevent test output.\"\"\"\n    with patch('utils.storage_providers.console', MockConsole()):\n        yield\n# --- Test StorageProvider Base Class ---\ndef test_storage_provider_is_abstract():\n    \"\"\"Verify that StorageProvider cannot be instantiated directly.\"\"\"\n    with pytest.raises(TypeError) as excinfo:\n        StorageProvider()\n    assert \"Can't instantiate abstract class StorageProvider\" in str(excinfo.value)",
        "detail": "tests.unit.utils.test_storage_providers",
        "documentation": {}
    },
    {
        "label": "test_storage_provider_is_abstract",
        "kind": 2,
        "importPath": "tests.unit.utils.test_storage_providers",
        "description": "tests.unit.utils.test_storage_providers",
        "peekOfCode": "def test_storage_provider_is_abstract():\n    \"\"\"Verify that StorageProvider cannot be instantiated directly.\"\"\"\n    with pytest.raises(TypeError) as excinfo:\n        StorageProvider()\n    assert \"Can't instantiate abstract class StorageProvider\" in str(excinfo.value)\n# --- Test StorageManager ---\n@pytest.fixture\ndef mock_concrete_provider():\n    \"\"\"Mock a concrete implementation of StorageProvider.\"\"\"\n    provider = MagicMock(spec=StorageProvider)",
        "detail": "tests.unit.utils.test_storage_providers",
        "documentation": {}
    },
    {
        "label": "mock_concrete_provider",
        "kind": 2,
        "importPath": "tests.unit.utils.test_storage_providers",
        "description": "tests.unit.utils.test_storage_providers",
        "peekOfCode": "def mock_concrete_provider():\n    \"\"\"Mock a concrete implementation of StorageProvider.\"\"\"\n    provider = MagicMock(spec=StorageProvider)\n    provider.is_connected.return_value = False\n    provider.connect.return_value = True\n    provider.upload_file.return_value = True\n    return provider\n@pytest.fixture\ndef storage_manager_instance(mock_concrete_provider):\n    \"\"\"Provides an initialized StorageManager.\"\"\"",
        "detail": "tests.unit.utils.test_storage_providers",
        "documentation": {}
    },
    {
        "label": "storage_manager_instance",
        "kind": 2,
        "importPath": "tests.unit.utils.test_storage_providers",
        "description": "tests.unit.utils.test_storage_providers",
        "peekOfCode": "def storage_manager_instance(mock_concrete_provider):\n    \"\"\"Provides an initialized StorageManager.\"\"\"\n    manager = StorageManager()\n    manager.add_provider(\"test_ftp\", mock_concrete_provider)\n    manager.add_provider(\"test_sftp\", mock_concrete_provider)\n    manager.set_active_provider(\"test_ftp\")\n    return manager\ndef test_storage_manager_add_and_get_active(storage_manager_instance, mock_concrete_provider):\n    \"\"\"Test adding a provider and setting it as active.\"\"\"\n    assert storage_manager_instance.get_active_provider() == mock_concrete_provider",
        "detail": "tests.unit.utils.test_storage_providers",
        "documentation": {}
    },
    {
        "label": "test_storage_manager_add_and_get_active",
        "kind": 2,
        "importPath": "tests.unit.utils.test_storage_providers",
        "description": "tests.unit.utils.test_storage_providers",
        "peekOfCode": "def test_storage_manager_add_and_get_active(storage_manager_instance, mock_concrete_provider):\n    \"\"\"Test adding a provider and setting it as active.\"\"\"\n    assert storage_manager_instance.get_active_provider() == mock_concrete_provider\ndef test_storage_manager_set_active_provider_missing(storage_manager_instance):\n    \"\"\"Test setting an active provider that hasn't been added.\"\"\"\n    assert storage_manager_instance.set_active_provider(\"missing\") is False\n    assert storage_manager_instance.active_provider == \"test_ftp\" # Unchanged\ndef test_storage_manager_get_active_provider_none():\n    \"\"\"Test getting active provider when none is set.\"\"\"\n    manager = StorageManager()",
        "detail": "tests.unit.utils.test_storage_providers",
        "documentation": {}
    },
    {
        "label": "test_storage_manager_set_active_provider_missing",
        "kind": 2,
        "importPath": "tests.unit.utils.test_storage_providers",
        "description": "tests.unit.utils.test_storage_providers",
        "peekOfCode": "def test_storage_manager_set_active_provider_missing(storage_manager_instance):\n    \"\"\"Test setting an active provider that hasn't been added.\"\"\"\n    assert storage_manager_instance.set_active_provider(\"missing\") is False\n    assert storage_manager_instance.active_provider == \"test_ftp\" # Unchanged\ndef test_storage_manager_get_active_provider_none():\n    \"\"\"Test getting active provider when none is set.\"\"\"\n    manager = StorageManager()\n    assert manager.get_active_provider() is None\ndef test_storage_manager_upload_success(storage_manager_instance, mock_concrete_provider):\n    \"\"\"Test successful upload, including connecting first.\"\"\"",
        "detail": "tests.unit.utils.test_storage_providers",
        "documentation": {}
    },
    {
        "label": "test_storage_manager_get_active_provider_none",
        "kind": 2,
        "importPath": "tests.unit.utils.test_storage_providers",
        "description": "tests.unit.utils.test_storage_providers",
        "peekOfCode": "def test_storage_manager_get_active_provider_none():\n    \"\"\"Test getting active provider when none is set.\"\"\"\n    manager = StorageManager()\n    assert manager.get_active_provider() is None\ndef test_storage_manager_upload_success(storage_manager_instance, mock_concrete_provider):\n    \"\"\"Test successful upload, including connecting first.\"\"\"\n    result = storage_manager_instance.upload_file(\"local.txt\", \"remote/path.txt\")\n    mock_concrete_provider.is_connected.assert_called_once()\n    mock_concrete_provider.connect.assert_called_once()\n    mock_concrete_provider.upload_file.assert_called_once_with(\"local.txt\", \"remote/path.txt\")",
        "detail": "tests.unit.utils.test_storage_providers",
        "documentation": {}
    },
    {
        "label": "test_storage_manager_upload_success",
        "kind": 2,
        "importPath": "tests.unit.utils.test_storage_providers",
        "description": "tests.unit.utils.test_storage_providers",
        "peekOfCode": "def test_storage_manager_upload_success(storage_manager_instance, mock_concrete_provider):\n    \"\"\"Test successful upload, including connecting first.\"\"\"\n    result = storage_manager_instance.upload_file(\"local.txt\", \"remote/path.txt\")\n    mock_concrete_provider.is_connected.assert_called_once()\n    mock_concrete_provider.connect.assert_called_once()\n    mock_concrete_provider.upload_file.assert_called_once_with(\"local.txt\", \"remote/path.txt\")\n    assert result is True\ndef test_storage_manager_upload_already_connected(storage_manager_instance, mock_concrete_provider):\n    \"\"\"Test successful upload when already connected.\"\"\"\n    mock_concrete_provider.is_connected.return_value = True",
        "detail": "tests.unit.utils.test_storage_providers",
        "documentation": {}
    },
    {
        "label": "test_storage_manager_upload_already_connected",
        "kind": 2,
        "importPath": "tests.unit.utils.test_storage_providers",
        "description": "tests.unit.utils.test_storage_providers",
        "peekOfCode": "def test_storage_manager_upload_already_connected(storage_manager_instance, mock_concrete_provider):\n    \"\"\"Test successful upload when already connected.\"\"\"\n    mock_concrete_provider.is_connected.return_value = True\n    mock_concrete_provider.upload_file.return_value = True\n    result = storage_manager_instance.upload_file(\"local.txt\", \"remote/path.txt\")\n    mock_concrete_provider.connect.assert_not_called()\n    assert result is True\ndef test_storage_manager_upload_connect_failure(storage_manager_instance, mock_concrete_provider):\n    \"\"\"Test failure when provider fails to connect.\"\"\"\n    mock_concrete_provider.connect.return_value = False",
        "detail": "tests.unit.utils.test_storage_providers",
        "documentation": {}
    },
    {
        "label": "test_storage_manager_upload_connect_failure",
        "kind": 2,
        "importPath": "tests.unit.utils.test_storage_providers",
        "description": "tests.unit.utils.test_storage_providers",
        "peekOfCode": "def test_storage_manager_upload_connect_failure(storage_manager_instance, mock_concrete_provider):\n    \"\"\"Test failure when provider fails to connect.\"\"\"\n    mock_concrete_provider.connect.return_value = False\n    result = storage_manager_instance.upload_file(\"local.txt\", \"remote/path.txt\")\n    mock_concrete_provider.connect.assert_called_once()\n    mock_concrete_provider.upload_file.assert_not_called()\n    assert result is False\ndef test_storage_manager_upload_no_active_provider():\n    \"\"\"Test upload fails if no provider is active.\"\"\"\n    manager = StorageManager()",
        "detail": "tests.unit.utils.test_storage_providers",
        "documentation": {}
    },
    {
        "label": "test_storage_manager_upload_no_active_provider",
        "kind": 2,
        "importPath": "tests.unit.utils.test_storage_providers",
        "description": "tests.unit.utils.test_storage_providers",
        "peekOfCode": "def test_storage_manager_upload_no_active_provider():\n    \"\"\"Test upload fails if no provider is active.\"\"\"\n    manager = StorageManager()\n    assert manager.upload_file(\"local.txt\", \"remote.txt\") is False\n# --- Test Individual Provider Connection Logic (using Mocks for external libs) ---\n# FTP Storage Mocks\n@patch('utils.storage_providers.FTP')\ndef test_ftp_storage_connect_success_anonymous(mock_ftp_class):\n    \"\"\"Test successful anonymous FTP connection.\"\"\"\n    mock_ftp_instance = mock_ftp_class.return_value",
        "detail": "tests.unit.utils.test_storage_providers",
        "documentation": {}
    },
    {
        "label": "test_ftp_storage_connect_success_anonymous",
        "kind": 2,
        "importPath": "tests.unit.utils.test_storage_providers",
        "description": "tests.unit.utils.test_storage_providers",
        "peekOfCode": "def test_ftp_storage_connect_success_anonymous(mock_ftp_class):\n    \"\"\"Test successful anonymous FTP connection.\"\"\"\n    mock_ftp_instance = mock_ftp_class.return_value\n    storage = FTPStorage(host=\"ftp.anon.com\")\n    assert storage.connect() is True\n    mock_ftp_instance.connect.assert_called_once_with(\"ftp.anon.com\", 21, timeout=30)\n    mock_ftp_instance.login.assert_called_once_with()\n    mock_ftp_instance.cwd.assert_not_called()\n@patch('utils.storage_providers.FTP')\ndef test_ftp_storage_connect_success_authenticated_with_path(mock_ftp_class):",
        "detail": "tests.unit.utils.test_storage_providers",
        "documentation": {}
    },
    {
        "label": "test_ftp_storage_connect_success_authenticated_with_path",
        "kind": 2,
        "importPath": "tests.unit.utils.test_storage_providers",
        "description": "tests.unit.utils.test_storage_providers",
        "peekOfCode": "def test_ftp_storage_connect_success_authenticated_with_path(mock_ftp_class):\n    \"\"\"Test successful authenticated FTP connection and CWD.\"\"\"\n    mock_ftp_instance = mock_ftp_class.return_value\n    storage = FTPStorage(host=\"ftp.auth.com\", username=\"u\", password=\"p\", base_path=\"/remote/data\")\n    assert storage.connect() is True\n    mock_ftp_instance.login.assert_called_once_with(\"u\", \"p\")\n    mock_ftp_instance.cwd.assert_called_once_with(\"/remote/data\")\n@patch('utils.storage_providers.FTP', side_effect=Exception(\"FTP error\"))\ndef test_ftp_storage_connect_failure(mock_ftp_class):\n    \"\"\"Test failed FTP connection.\"\"\"",
        "detail": "tests.unit.utils.test_storage_providers",
        "documentation": {}
    },
    {
        "label": "test_ftp_storage_connect_failure",
        "kind": 2,
        "importPath": "tests.unit.utils.test_storage_providers",
        "description": "tests.unit.utils.test_storage_providers",
        "peekOfCode": "def test_ftp_storage_connect_failure(mock_ftp_class):\n    \"\"\"Test failed FTP connection.\"\"\"\n    storage = FTPStorage(host=\"ftp.fail.com\")\n    assert storage.connect() is False\n    assert storage.ftp is None\n@patch('utils.storage_providers.FTP')\ndef test_ftp_storage_disconnect(mock_ftp_class):\n    \"\"\"Test FTP disconnection.\"\"\"\n    mock_ftp_instance = mock_ftp_class.return_value\n    storage = FTPStorage(host=\"h\")",
        "detail": "tests.unit.utils.test_storage_providers",
        "documentation": {}
    },
    {
        "label": "test_ftp_storage_disconnect",
        "kind": 2,
        "importPath": "tests.unit.utils.test_storage_providers",
        "description": "tests.unit.utils.test_storage_providers",
        "peekOfCode": "def test_ftp_storage_disconnect(mock_ftp_class):\n    \"\"\"Test FTP disconnection.\"\"\"\n    mock_ftp_instance = mock_ftp_class.return_value\n    storage = FTPStorage(host=\"h\")\n    storage.ftp = mock_ftp_instance # Simulate being connected\n    storage.disconnect()\n    mock_ftp_instance.quit.assert_called_once()\n@patch('utils.storage_providers.FTP')\ndef test_ftp_storage_is_connected(mock_ftp_class):\n    \"\"\"Test FTP connection check (NOOP command).\"\"\"",
        "detail": "tests.unit.utils.test_storage_providers",
        "documentation": {}
    },
    {
        "label": "test_ftp_storage_is_connected",
        "kind": 2,
        "importPath": "tests.unit.utils.test_storage_providers",
        "description": "tests.unit.utils.test_storage_providers",
        "peekOfCode": "def test_ftp_storage_is_connected(mock_ftp_class):\n    \"\"\"Test FTP connection check (NOOP command).\"\"\"\n    mock_ftp_instance = mock_ftp_class.return_value\n    storage = FTPStorage(host=\"h\")\n    storage.ftp = mock_ftp_instance\n    # Connected\n    mock_ftp_instance.voidcmd.return_value = '200 OK'\n    assert storage.is_connected() is True\n    # Disconnected\n    mock_ftp_instance.voidcmd.side_effect = Exception",
        "detail": "tests.unit.utils.test_storage_providers",
        "documentation": {}
    },
    {
        "label": "test_sftp_storage_connect_password_success",
        "kind": 2,
        "importPath": "tests.unit.utils.test_storage_providers",
        "description": "tests.unit.utils.test_storage_providers",
        "peekOfCode": "def test_sftp_storage_connect_password_success(mock_paramiko, mock_path_exists):\n    \"\"\"Test successful SFTP connection using password.\"\"\"\n    mock_transport = mock_paramiko.Transport.return_value\n    storage = SFTPStorage(host=\"sftp.com\", username=\"u\", password=\"p\", port=22)\n    assert storage.connect() is True\n    mock_transport.connect.assert_called_once_with(username=\"u\", password=\"p\")\n    mock_paramiko.SFTPClient.from_transport.assert_called_once_with(mock_transport)\n    assert storage.sftp is not None\n@patch('utils.storage_providers.Path.exists', return_value=True) # Key file exists\n@patch('utils.storage_providers.paramiko')",
        "detail": "tests.unit.utils.test_storage_providers",
        "documentation": {}
    },
    {
        "label": "test_sftp_storage_connect_key_success",
        "kind": 2,
        "importPath": "tests.unit.utils.test_storage_providers",
        "description": "tests.unit.utils.test_storage_providers",
        "peekOfCode": "def test_sftp_storage_connect_key_success(mock_paramiko, mock_path_exists):\n    \"\"\"Test successful SFTP connection using key file.\"\"\"\n    mock_transport = mock_paramiko.Transport.return_value\n    mock_rsa_key = mock_paramiko.RSAKey.from_private_key_file.return_value\n    storage = SFTPStorage(host=\"sftp.com\", username=\"u\", key_filename=\"/id_rsa\")\n    assert storage.connect() is True\n    mock_paramiko.RSAKey.from_private_key_file.assert_called_once_with(\"/id_rsa\")\n    mock_transport.connect.assert_called_once_with(username=\"u\", pkey=mock_rsa_key)\n    assert storage.sftp is not None",
        "detail": "tests.unit.utils.test_storage_providers",
        "documentation": {}
    },
    {
        "label": "project_root",
        "kind": 5,
        "importPath": "tests.unit.utils.test_storage_providers",
        "description": "tests.unit.utils.test_storage_providers",
        "peekOfCode": "project_root = Path(__file__).resolve().parent\nif str(project_root) not in sys.path:\n    sys.path.insert(0, str(project_root))\n# -------------------------------\nfrom ...utils.storage_providers import (\n    StorageProvider, StorageManager,\n    FTPStorage, SFTPStorage, GoogleDriveStorage, DropboxStorage, OneDriveStorage\n)\n# Mock the rich console for all tests\nclass MockConsole:",
        "detail": "tests.unit.utils.test_storage_providers",
        "documentation": {}
    },
    {
        "label": "setup_environment",
        "kind": 2,
        "importPath": "tests.run",
        "description": "tests.run",
        "peekOfCode": "def setup_environment():\n    \"\"\"Ensure log directory exists.\"\"\"\n    LOG_DIR.mkdir(parents=True, exist_ok=True)\n    if not Path(\"pytest.ini\").exists():\n        console.print(\"[yellow]Warning: 'pytest.ini' not found. Using default pytest configuration.[/yellow]\")\ndef get_log_filepath():\n    \"\"\"Generates a timestamped log file path.\"\"\"\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    return LOG_DIR / f\"{timestamp}.log\"\ndef run_pytest(command: list, log_file: Path):",
        "detail": "tests.run",
        "documentation": {}
    },
    {
        "label": "get_log_filepath",
        "kind": 2,
        "importPath": "tests.run",
        "description": "tests.run",
        "peekOfCode": "def get_log_filepath():\n    \"\"\"Generates a timestamped log file path.\"\"\"\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    return LOG_DIR / f\"{timestamp}.log\"\ndef run_pytest(command: list, log_file: Path):\n    \"\"\"Executes pytest and streams output to console and log file.\"\"\"\n    full_command = [sys.executable, '-m', 'pytest'] + command\n    # Run the test command, capturing stdout/stderr\n    with open(log_file, \"w\") as log:\n        console.print(f\"[dim]Running command: {' '.join(full_command)}[/dim]\")",
        "detail": "tests.run",
        "documentation": {}
    },
    {
        "label": "run_pytest",
        "kind": 2,
        "importPath": "tests.run",
        "description": "tests.run",
        "peekOfCode": "def run_pytest(command: list, log_file: Path):\n    \"\"\"Executes pytest and streams output to console and log file.\"\"\"\n    full_command = [sys.executable, '-m', 'pytest'] + command\n    # Run the test command, capturing stdout/stderr\n    with open(log_file, \"w\") as log:\n        console.print(f\"[dim]Running command: {' '.join(full_command)}[/dim]\")\n        # We use Popen to stream output in real-time while also capturing it\n        process = subprocess.Popen(\n            full_command,\n            stdout=subprocess.PIPE,",
        "detail": "tests.run",
        "documentation": {}
    },
    {
        "label": "display_menu",
        "kind": 2,
        "importPath": "tests.run",
        "description": "tests.run",
        "peekOfCode": "def display_menu():\n    \"\"\"Display the test runner menu and get user choice.\"\"\"\n    console.print(\"\\n\")\n    title = Panel.fit(\n        \"[bold magenta]Playlist Downloader Testing Suite[/bold magenta]\",\n        border_style=\"magenta\",\n        padding=(1, 2)\n    )\n    console.print(title)\n    options = [",
        "detail": "tests.run",
        "documentation": {}
    },
    {
        "label": "handle_choice",
        "kind": 2,
        "importPath": "tests.run",
        "description": "tests.run",
        "peekOfCode": "def handle_choice(choice: str, log_file: Path):\n    \"\"\"Maps menu choice to pytest command arguments.\"\"\"\n    # Base command args\n    args = []\n    if choice == \"1\":\n        # Run all tests (excluding 'live')\n        args = ['-m', 'not live']\n        title = \"ALL UNIT TESTS\"\n    elif choice == \"2\":\n        # Run all tests (excluding 'live') with coverage report",
        "detail": "tests.run",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "tests.run",
        "description": "tests.run",
        "peekOfCode": "def main():\n    \"\"\"Main execution loop for the test runner.\"\"\"\n    setup_environment()\n    while True:\n        log_file = get_log_filepath()\n        choice = display_menu()\n        if choice == \"7\":\n            console.print(\"\\n[bold magenta]Exiting Test Runner. Goodbye![/bold magenta]\")\n            break\n        handle_choice(choice, log_file)",
        "detail": "tests.run",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "tests.run",
        "description": "tests.run",
        "peekOfCode": "console = Console()\n# --- Configuration ---\nLOG_DIR = Path(\"logs/tests\")\nLIVE_TEST_PROXY = \"http://localhost:8080\" # Placeholder for live proxy/server address\n# --- Setup Functions ---\ndef setup_environment():\n    \"\"\"Ensure log directory exists.\"\"\"\n    LOG_DIR.mkdir(parents=True, exist_ok=True)\n    if not Path(\"pytest.ini\").exists():\n        console.print(\"[yellow]Warning: 'pytest.ini' not found. Using default pytest configuration.[/yellow]\")",
        "detail": "tests.run",
        "documentation": {}
    },
    {
        "label": "LOG_DIR",
        "kind": 5,
        "importPath": "tests.run",
        "description": "tests.run",
        "peekOfCode": "LOG_DIR = Path(\"logs/tests\")\nLIVE_TEST_PROXY = \"http://localhost:8080\" # Placeholder for live proxy/server address\n# --- Setup Functions ---\ndef setup_environment():\n    \"\"\"Ensure log directory exists.\"\"\"\n    LOG_DIR.mkdir(parents=True, exist_ok=True)\n    if not Path(\"pytest.ini\").exists():\n        console.print(\"[yellow]Warning: 'pytest.ini' not found. Using default pytest configuration.[/yellow]\")\ndef get_log_filepath():\n    \"\"\"Generates a timestamped log file path.\"\"\"",
        "detail": "tests.run",
        "documentation": {}
    },
    {
        "label": "LIVE_TEST_PROXY",
        "kind": 5,
        "importPath": "tests.run",
        "description": "tests.run",
        "peekOfCode": "LIVE_TEST_PROXY = \"http://localhost:8080\" # Placeholder for live proxy/server address\n# --- Setup Functions ---\ndef setup_environment():\n    \"\"\"Ensure log directory exists.\"\"\"\n    LOG_DIR.mkdir(parents=True, exist_ok=True)\n    if not Path(\"pytest.ini\").exists():\n        console.print(\"[yellow]Warning: 'pytest.ini' not found. Using default pytest configuration.[/yellow]\")\ndef get_log_filepath():\n    \"\"\"Generates a timestamped log file path.\"\"\"\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")",
        "detail": "tests.run",
        "documentation": {}
    },
    {
        "label": "DownloadProgressDisplay",
        "kind": 6,
        "importPath": "ui.download_progress",
        "description": "ui.download_progress",
        "peekOfCode": "class DownloadProgressDisplay:\n    \"\"\"Enhanced progress display for downloads with overall stats\"\"\"\n    def __init__(self, total_items: int):\n        self.total_items = total_items\n        self.completed = 0\n        self.failed = 0\n        self.downloading = 0\n        self.items: Dict[int, Dict] = {}  # item_id -> {title, status, index}\n        self.current_item_index = 0\n        self.live = None",
        "detail": "ui.download_progress",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "ui.download_progress",
        "description": "ui.download_progress",
        "peekOfCode": "console = Console()\nclass DownloadProgressDisplay:\n    \"\"\"Enhanced progress display for downloads with overall stats\"\"\"\n    def __init__(self, total_items: int):\n        self.total_items = total_items\n        self.completed = 0\n        self.failed = 0\n        self.downloading = 0\n        self.items: Dict[int, Dict] = {}  # item_id -> {title, status, index}\n        self.current_item_index = 0",
        "detail": "ui.download_progress",
        "documentation": {}
    },
    {
        "label": "DownloadSettingsMenu",
        "kind": 6,
        "importPath": "ui.download_settings_menu",
        "description": "ui.download_settings_menu",
        "peekOfCode": "class DownloadSettingsMenu:\n    \"\"\"Download configuration submenu\"\"\"\n    def __init__(self):\n        self.config_manager = ConfigManager()\n    def show(self):\n        \"\"\"Show download settings menu\"\"\"\n        while True:\n            console.clear()\n            header = Panel(\n                \"[bold cyan]Download Settings[/bold cyan]\",",
        "detail": "ui.download_settings_menu",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "ui.download_settings_menu",
        "description": "ui.download_settings_menu",
        "peekOfCode": "console = Console()\nclass DownloadSettingsMenu:\n    \"\"\"Download configuration submenu\"\"\"\n    def __init__(self):\n        self.config_manager = ConfigManager()\n    def show(self):\n        \"\"\"Show download settings menu\"\"\"\n        while True:\n            console.clear()\n            header = Panel(",
        "detail": "ui.download_settings_menu",
        "documentation": {}
    },
    {
        "label": "Menu",
        "kind": 6,
        "importPath": "ui.menu",
        "description": "ui.menu",
        "peekOfCode": "class Menu:\n    \"\"\"Main application menu\"\"\"\n    def __init__(self):\n        # Get all managers internally\n        self.config_manager = ConfigManager()\n        self.queue_manager = QueueManager()\n        self.stats_manager = StatsManager()\n        self.monitor_manager = MonitorManager()\n        self.storage_manager = StorageManager()\n        self.downloader = PlaylistDownloader()",
        "detail": "ui.menu",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "ui.menu",
        "description": "ui.menu",
        "peekOfCode": "console = Console()\nclass Menu:\n    \"\"\"Main application menu\"\"\"\n    def __init__(self):\n        # Get all managers internally\n        self.config_manager = ConfigManager()\n        self.queue_manager = QueueManager()\n        self.stats_manager = StatsManager()\n        self.monitor_manager = MonitorManager()\n        self.storage_manager = StorageManager()",
        "detail": "ui.menu",
        "documentation": {}
    },
    {
        "label": "MonitoringMenu",
        "kind": 6,
        "importPath": "ui.monitoring_menu",
        "description": "ui.monitoring_menu",
        "peekOfCode": "class MonitoringMenu:\n    \"\"\"Channel monitoring menu\"\"\"\n    def __init__(self):\n        self.monitor_manager = MonitorManager()\n    def show(self):\n        \"\"\"Show monitoring menu\"\"\"\n        while True:\n            console.clear()\n            header = Panel(\n                \"[bold cyan]Channel Monitoring[/bold cyan]\\n\"",
        "detail": "ui.monitoring_menu",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "ui.monitoring_menu",
        "description": "ui.monitoring_menu",
        "peekOfCode": "console = Console()\nclass MonitoringMenu:\n    \"\"\"Channel monitoring menu\"\"\"\n    def __init__(self):\n        self.monitor_manager = MonitorManager()\n    def show(self):\n        \"\"\"Show monitoring menu\"\"\"\n        while True:\n            console.clear()\n            header = Panel(",
        "detail": "ui.monitoring_menu",
        "documentation": {}
    },
    {
        "label": "NetworkSettingsMenu",
        "kind": 6,
        "importPath": "ui.network_settings_menu",
        "description": "ui.network_settings_menu",
        "peekOfCode": "class NetworkSettingsMenu:\n    \"\"\"Network & proxy configuration submenu\"\"\"\n    def __init__(self, config_manager: ConfigManager = None):\n        self.config_manager = config_manager or ConfigManager()\n    def show(self):\n        \"\"\"Show network settings menu\"\"\"\n        while True:\n            console.clear()\n            header = Panel(\n                \"[bold cyan]Network & Proxy Settings[/bold cyan]\",",
        "detail": "ui.network_settings_menu",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "ui.network_settings_menu",
        "description": "ui.network_settings_menu",
        "peekOfCode": "console = Console()\nclass NetworkSettingsMenu:\n    \"\"\"Network & proxy configuration submenu\"\"\"\n    def __init__(self, config_manager: ConfigManager = None):\n        self.config_manager = config_manager or ConfigManager()\n    def show(self):\n        \"\"\"Show network settings menu\"\"\"\n        while True:\n            console.clear()\n            header = Panel(",
        "detail": "ui.network_settings_menu",
        "documentation": {}
    },
    {
        "label": "NotificationSettingsMenu",
        "kind": 6,
        "importPath": "ui.notification_settings_menu",
        "description": "ui.notification_settings_menu",
        "peekOfCode": "class NotificationSettingsMenu:\n    \"\"\"Notification configuration submenu\"\"\"\n    def __init__(self):\n        self.config_manager = ConfigManager()\n    def show(self):\n        \"\"\"Show notification settings menu\"\"\"\n        while True:\n            console.clear()\n            header = Panel(\n                \"[bold cyan]Notification Settings[/bold cyan]\",",
        "detail": "ui.notification_settings_menu",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "ui.notification_settings_menu",
        "description": "ui.notification_settings_menu",
        "peekOfCode": "console = Console()\nclass NotificationSettingsMenu:\n    \"\"\"Notification configuration submenu\"\"\"\n    def __init__(self):\n        self.config_manager = ConfigManager()\n    def show(self):\n        \"\"\"Show notification settings menu\"\"\"\n        while True:\n            console.clear()\n            header = Panel(",
        "detail": "ui.notification_settings_menu",
        "documentation": {}
    },
    {
        "label": "ProgressDisplay",
        "kind": 6,
        "importPath": "ui.progress_display",
        "description": "ui.progress_display",
        "peekOfCode": "class ProgressDisplay:\n    \"\"\"Handles clean progress display for downloads\"\"\"\n    def __init__(self):\n        self.console = Console()\n        self.progress = None\n        self.task_id = None\n    def create_simple_progress(self, description: str, total: int = 100):\n        \"\"\"Create a simple progress bar\"\"\"\n        self.progress = Progress(\n            TextColumn(\"[bold blue]{task.description}\"),",
        "detail": "ui.progress_display",
        "documentation": {}
    },
    {
        "label": "QueueBuilder",
        "kind": 6,
        "importPath": "ui.queue_builder",
        "description": "ui.queue_builder",
        "peekOfCode": "class QueueBuilder:\n    \"\"\"Build download queues interactively\"\"\"\n    def __init__(self):\n        self.config_manager = ConfigManager()\n        self.queue_manager = QueueManager()\n        self.downloader = PlaylistDownloader()\n    def build_queue(self):\n        \"\"\"Build a new download queue\"\"\"\n        console.clear()\n        header = Panel(",
        "detail": "ui.queue_builder",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "ui.queue_builder",
        "description": "ui.queue_builder",
        "peekOfCode": "console = Console()\nclass QueueBuilder:\n    \"\"\"Build download queues interactively\"\"\"\n    def __init__(self):\n        self.config_manager = ConfigManager()\n        self.queue_manager = QueueManager()\n        self.downloader = PlaylistDownloader()\n    def build_queue(self):\n        \"\"\"Build a new download queue\"\"\"\n        console.clear()",
        "detail": "ui.queue_builder",
        "documentation": {}
    },
    {
        "label": "QueueViewer",
        "kind": 6,
        "importPath": "ui.queue_viewer",
        "description": "ui.queue_viewer",
        "peekOfCode": "class QueueViewer:\n    \"\"\"View and manage download queues\"\"\"\n    def __init__(self):\n        self.queue_manager = QueueManager()\n        self.downloader = PlaylistDownloader()\n    def show(self):\n        \"\"\"Show queue viewer\"\"\"\n        while True:\n            console.clear()\n            header = Panel(",
        "detail": "ui.queue_viewer",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "ui.queue_viewer",
        "description": "ui.queue_viewer",
        "peekOfCode": "console = Console()\nclass QueueViewer:\n    \"\"\"View and manage download queues\"\"\"\n    def __init__(self):\n        self.queue_manager = QueueManager()\n        self.downloader = PlaylistDownloader()\n    def show(self):\n        \"\"\"Show queue viewer\"\"\"\n        while True:\n            console.clear()",
        "detail": "ui.queue_viewer",
        "documentation": {}
    },
    {
        "label": "SettingsMenu",
        "kind": 6,
        "importPath": "ui.settings_menu",
        "description": "ui.settings_menu",
        "peekOfCode": "class SettingsMenu:\n    \"\"\"Settings configuration menu\"\"\"\n    def __init__(self):\n        self.config_manager = ConfigManager()\n    def show(self):\n        \"\"\"Show settings menu\"\"\"\n        while True:\n            console.clear()\n            from rich.panel import Panel\n            header = Panel(",
        "detail": "ui.settings_menu",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "ui.settings_menu",
        "description": "ui.settings_menu",
        "peekOfCode": "console = Console()\nclass SettingsMenu:\n    \"\"\"Settings configuration menu\"\"\"\n    def __init__(self):\n        self.config_manager = ConfigManager()\n    def show(self):\n        \"\"\"Show settings menu\"\"\"\n        while True:\n            console.clear()\n            from rich.panel import Panel",
        "detail": "ui.settings_menu",
        "documentation": {}
    },
    {
        "label": "SetupWizard",
        "kind": 6,
        "importPath": "ui.setup_wizard",
        "description": "ui.setup_wizard",
        "peekOfCode": "class SetupWizard:\n    \"\"\"Interactive setup wizard\"\"\"\n    def __init__(self):\n        self.config_manager = ConfigManager()\n    def run(self) -> bool:\n        \"\"\"Run the setup wizard\"\"\"\n        console.clear()\n        header = Panel(\n            \"[bold cyan]Setup Wizard[/bold cyan]\\n\"\n            \"Quick configuration for YouTube Playlist Downloader\",",
        "detail": "ui.setup_wizard",
        "documentation": {}
    },
    {
        "label": "StatusPage",
        "kind": 6,
        "importPath": "ui.setup_wizard",
        "description": "ui.setup_wizard",
        "peekOfCode": "class StatusPage:\n    \"\"\"Display system status\"\"\"\n    def __init__(self):\n        self.config_manager = ConfigManager()\n    def show(self):\n        \"\"\"Show status page\"\"\"\n        console.clear()\n        header = Panel(\n            \"[bold cyan]System Status[/bold cyan]\",\n            border_style=\"cyan\"",
        "detail": "ui.setup_wizard",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "ui.setup_wizard",
        "description": "ui.setup_wizard",
        "peekOfCode": "console = Console()\nclass SetupWizard:\n    \"\"\"Interactive setup wizard\"\"\"\n    def __init__(self):\n        self.config_manager = ConfigManager()\n    def run(self) -> bool:\n        \"\"\"Run the setup wizard\"\"\"\n        console.clear()\n        header = Panel(\n            \"[bold cyan]Setup Wizard[/bold cyan]\\n\"",
        "detail": "ui.setup_wizard",
        "documentation": {}
    },
    {
        "label": "StatsViewer",
        "kind": 6,
        "importPath": "ui.stats_viewer",
        "description": "ui.stats_viewer",
        "peekOfCode": "class StatsViewer:\n    \"\"\"View download statistics\"\"\"\n    def __init__(self):\n        self.stats_manager = StatsManager()\n    def show(self):\n        \"\"\"Show statistics viewer\"\"\"\n        while True:\n            console.clear()\n            header = Panel(\n                \"[bold cyan]Download Statistics[/bold cyan]\\n\"",
        "detail": "ui.stats_viewer",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "ui.stats_viewer",
        "description": "ui.stats_viewer",
        "peekOfCode": "console = Console()\nclass StatsViewer:\n    \"\"\"View download statistics\"\"\"\n    def __init__(self):\n        self.stats_manager = StatsManager()\n    def show(self):\n        \"\"\"Show statistics viewer\"\"\"\n        while True:\n            console.clear()\n            header = Panel(",
        "detail": "ui.stats_viewer",
        "documentation": {}
    },
    {
        "label": "StorageMenu",
        "kind": 6,
        "importPath": "ui.storage_menu",
        "description": "ui.storage_menu",
        "peekOfCode": "class StorageMenu:\n    \"\"\"Storage provider management menu\"\"\"\n    def __init__(self):\n        from managers.config_manager import ConfigManager\n        from utils.storage_providers import StorageManager\n        self.config_manager = ConfigManager()\n        self.storage_manager = StorageManager()\n    def show(self):\n        \"\"\"Display storage management menu\"\"\"\n        console.print(\"\\n\")",
        "detail": "ui.storage_menu",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "ui.storage_menu",
        "description": "ui.storage_menu",
        "peekOfCode": "console = Console()\nclass StorageMenu:\n    \"\"\"Storage provider management menu\"\"\"\n    def __init__(self):\n        from managers.config_manager import ConfigManager\n        from utils.storage_providers import StorageManager\n        self.config_manager = ConfigManager()\n        self.storage_manager = StorageManager()\n    def show(self):\n        \"\"\"Display storage management menu\"\"\"",
        "detail": "ui.storage_menu",
        "documentation": {}
    },
    {
        "label": "AntiBlockingManager",
        "kind": 6,
        "importPath": "utils.anti_blocking",
        "description": "utils.anti_blocking",
        "peekOfCode": "class AntiBlockingManager:\n    \"\"\"Manage anti-blocking measures\"\"\"\n    def __init__(self, config):\n        self.config = config\n        self.request_history = []\n        self.error_count = 0\n        self.last_error_time = None\n        self.backoff_until = None\n        # User agents to rotate\n        self.user_agents = [",
        "detail": "utils.anti_blocking",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "utils.anti_blocking",
        "description": "utils.anti_blocking",
        "peekOfCode": "console = Console()\nclass AntiBlockingManager:\n    \"\"\"Manage anti-blocking measures\"\"\"\n    def __init__(self, config):\n        self.config = config\n        self.request_history = []\n        self.error_count = 0\n        self.last_error_time = None\n        self.backoff_until = None\n        # User agents to rotate",
        "detail": "utils.anti_blocking",
        "documentation": {}
    },
    {
        "label": "DatabaseSeeder",
        "kind": 6,
        "importPath": "utils.database_seeder",
        "description": "utils.database_seeder",
        "peekOfCode": "class DatabaseSeeder:\n    \"\"\"Handles database seeding from JSON files\"\"\"\n    def __init__(self, seeds_dir: str = \"seeds\"):\n        self.seeds_dir = Path(seeds_dir)\n        self.seeds_dir.mkdir(exist_ok=True)\n    def load_json_seed(self, file_path: str) -> Dict[str, List[Dict]]:\n        \"\"\"\n        Load seed data from JSON file\n        Args:\n            file_path: Path to JSON seed file",
        "detail": "utils.database_seeder",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "utils.database_seeder",
        "description": "utils.database_seeder",
        "peekOfCode": "console = Console()\nclass DatabaseSeeder:\n    \"\"\"Handles database seeding from JSON files\"\"\"\n    def __init__(self, seeds_dir: str = \"seeds\"):\n        self.seeds_dir = Path(seeds_dir)\n        self.seeds_dir.mkdir(exist_ok=True)\n    def load_json_seed(self, file_path: str) -> Dict[str, List[Dict]]:\n        \"\"\"\n        Load seed data from JSON file\n        Args:",
        "detail": "utils.database_seeder",
        "documentation": {}
    },
    {
        "label": "DownloadResume",
        "kind": 6,
        "importPath": "utils.download_resume",
        "description": "utils.download_resume",
        "peekOfCode": "class DownloadResume:\n    \"\"\"Manages resume information for partial downloads\"\"\"\n    def __init__(self, resume_file: str = \"data/resume_info.json\"):\n        self.resume_file = Path(resume_file)\n        self.resume_file.parent.mkdir(parents=True, exist_ok=True)\n        self.resume_data = self._load_resume_data()\n    def _load_resume_data(self) -> Dict[str, Any]:\n        \"\"\"Load resume data from file\"\"\"\n        if self.resume_file.exists():\n            try:",
        "detail": "utils.download_resume",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "utils.download_resume",
        "description": "utils.download_resume",
        "peekOfCode": "console = Console()\nclass DownloadResume:\n    \"\"\"Manages resume information for partial downloads\"\"\"\n    def __init__(self, resume_file: str = \"data/resume_info.json\"):\n        self.resume_file = Path(resume_file)\n        self.resume_file.parent.mkdir(parents=True, exist_ok=True)\n        self.resume_data = self._load_resume_data()\n    def _load_resume_data(self) -> Dict[str, Any]:\n        \"\"\"Load resume data from file\"\"\"\n        if self.resume_file.exists():",
        "detail": "utils.download_resume",
        "documentation": {}
    },
    {
        "label": "FileRenamer",
        "kind": 6,
        "importPath": "utils.file_renamer",
        "description": "utils.file_renamer",
        "peekOfCode": "class FileRenamer:\n    \"\"\"Handles file renaming with template system\"\"\"\n    @staticmethod\n    def normalize_title(title: str, sentence_case: bool = True) -> str:\n        \"\"\"\n        Normalize video title to clean format\n        Args:\n            title: Original title\n            sentence_case: Convert to sentence case (True) or keep original case (False)\n        \"\"\"",
        "detail": "utils.file_renamer",
        "documentation": {}
    },
    {
        "label": "KeyboardHandler",
        "kind": 6,
        "importPath": "utils.keyboard_handler",
        "description": "utils.keyboard_handler",
        "peekOfCode": "class KeyboardHandler:\n    \"\"\"Handles keyboard shortcuts including mobile-friendly single key presses\"\"\"\n    def __init__(self):\n        self.cancel_requested = False\n        self.pause_requested = False\n        self.skip_requested = False\n        self.listener_thread: Optional[threading.Thread] = None\n        self.running = False\n        self.callbacks: Dict[str, Callable] = {}\n        self._last_key_time = 0",
        "detail": "utils.keyboard_handler",
        "documentation": {}
    },
    {
        "label": "demo_keyboard_handler",
        "kind": 2,
        "importPath": "utils.keyboard_handler",
        "description": "utils.keyboard_handler",
        "peekOfCode": "def demo_keyboard_handler():\n    \"\"\"Demo of keyboard handler usage\"\"\"\n    from rich.progress import Progress, SpinnerColumn, TextColumn\n    import time\n    console.print(\"[cyan]Starting demo - try pressing keys![/cyan]\")\n    keyboard_handler.start_listening()\n    try:\n        with Progress(\n            SpinnerColumn(),\n            TextColumn(\"[progress.description]{task.description}\"),",
        "detail": "utils.keyboard_handler",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "utils.keyboard_handler",
        "description": "utils.keyboard_handler",
        "peekOfCode": "console = Console()\nclass KeyboardHandler:\n    \"\"\"Handles keyboard shortcuts including mobile-friendly single key presses\"\"\"\n    def __init__(self):\n        self.cancel_requested = False\n        self.pause_requested = False\n        self.skip_requested = False\n        self.listener_thread: Optional[threading.Thread] = None\n        self.running = False\n        self.callbacks: Dict[str, Callable] = {}",
        "detail": "utils.keyboard_handler",
        "documentation": {}
    },
    {
        "label": "keyboard_handler",
        "kind": 5,
        "importPath": "utils.keyboard_handler",
        "description": "utils.keyboard_handler",
        "peekOfCode": "keyboard_handler = KeyboardHandler()\n# Example usage function\ndef demo_keyboard_handler():\n    \"\"\"Demo of keyboard handler usage\"\"\"\n    from rich.progress import Progress, SpinnerColumn, TextColumn\n    import time\n    console.print(\"[cyan]Starting demo - try pressing keys![/cyan]\")\n    keyboard_handler.start_listening()\n    try:\n        with Progress(",
        "detail": "utils.keyboard_handler",
        "documentation": {}
    },
    {
        "label": "LiveStreamRecorder",
        "kind": 6,
        "importPath": "utils.live_stream_recorder",
        "description": "utils.live_stream_recorder",
        "peekOfCode": "class LiveStreamRecorder:\n    \"\"\"Handles live stream detection and recording\"\"\"\n    def __init__(self):\n        self.default_wait_minutes = 60\n    def is_live_stream(self, info: dict) -> bool:\n        \"\"\"Check if the video is a live stream\"\"\"\n        if not info:\n            return False\n        # Check various indicators of live streams\n        is_live = info.get('is_live', False)",
        "detail": "utils.live_stream_recorder",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "utils.live_stream_recorder",
        "description": "utils.live_stream_recorder",
        "peekOfCode": "console = Console()\nclass LiveStreamRecorder:\n    \"\"\"Handles live stream detection and recording\"\"\"\n    def __init__(self):\n        self.default_wait_minutes = 60\n    def is_live_stream(self, info: dict) -> bool:\n        \"\"\"Check if the video is a live stream\"\"\"\n        if not info:\n            return False\n        # Check various indicators of live streams",
        "detail": "utils.live_stream_recorder",
        "documentation": {}
    },
    {
        "label": "MetadataHandler",
        "kind": 6,
        "importPath": "utils.metadata_handler",
        "description": "utils.metadata_handler",
        "peekOfCode": "class MetadataHandler:\n    \"\"\"Handles file metadata operations\"\"\"\n    @staticmethod\n    def set_video_metadata(file_path: str, metadata: Dict):\n        \"\"\"\n        Set video file metadata\n        Args:\n            file_path: Path to video file\n            metadata: Dictionary containing metadata fields\n        \"\"\"",
        "detail": "utils.metadata_handler",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "utils.metadata_handler",
        "description": "utils.metadata_handler",
        "peekOfCode": "console = Console()\nclass MetadataHandler:\n    \"\"\"Handles file metadata operations\"\"\"\n    @staticmethod\n    def set_video_metadata(file_path: str, metadata: Dict):\n        \"\"\"\n        Set video file metadata\n        Args:\n            file_path: Path to video file\n            metadata: Dictionary containing metadata fields",
        "detail": "utils.metadata_handler",
        "documentation": {}
    },
    {
        "label": "OAuthHandler",
        "kind": 6,
        "importPath": "utils.oauth_handler",
        "description": "utils.oauth_handler",
        "peekOfCode": "class OAuthHandler:\n    \"\"\"Handles OAuth2 authentication for YouTube\"\"\"\n    def __init__(self, oauth_token: Optional[str] = None,\n                 oauth_refresh_token: Optional[str] = None,\n                 oauth_expiry: Optional[str] = None):\n        self.oauth_token = oauth_token\n        self.oauth_refresh_token = oauth_refresh_token\n        self.oauth_expiry = oauth_expiry\n    def is_authenticated(self) -> bool:\n        \"\"\"Check if OAuth token is valid\"\"\"",
        "detail": "utils.oauth_handler",
        "documentation": {}
    },
    {
        "label": "RateLimiter",
        "kind": 6,
        "importPath": "utils.rate_limiter",
        "description": "utils.rate_limiter",
        "peekOfCode": "class RateLimiter:\n    \"\"\"Rate limiter to prevent IP bans\"\"\"\n    def __init__(self, max_downloads_per_hour: int = 50, \n                 min_delay_seconds: float = 2.0, \n                 max_delay_seconds: float = 5.0):\n        self.max_downloads_per_hour = max_downloads_per_hour\n        self.min_delay_seconds = min_delay_seconds\n        self.max_delay_seconds = max_delay_seconds\n        self.download_timestamps: List[datetime] = []\n    def wait_if_needed(self):",
        "detail": "utils.rate_limiter",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "utils.rate_limiter",
        "description": "utils.rate_limiter",
        "peekOfCode": "console = Console()\nclass RateLimiter:\n    \"\"\"Rate limiter to prevent IP bans\"\"\"\n    def __init__(self, max_downloads_per_hour: int = 50, \n                 min_delay_seconds: float = 2.0, \n                 max_delay_seconds: float = 5.0):\n        self.max_downloads_per_hour = max_downloads_per_hour\n        self.min_delay_seconds = min_delay_seconds\n        self.max_delay_seconds = max_delay_seconds\n        self.download_timestamps: List[datetime] = []",
        "detail": "utils.rate_limiter",
        "documentation": {}
    },
    {
        "label": "StorageProvider",
        "kind": 6,
        "importPath": "utils.storage_providers",
        "description": "utils.storage_providers",
        "peekOfCode": "class StorageProvider(ABC):\n    \"\"\"Abstract base class for storage providers\"\"\"\n    @abstractmethod\n    def connect(self) -> bool:\n        \"\"\"Connect to storage provider\"\"\"\n        pass\n    @abstractmethod\n    def disconnect(self):\n        \"\"\"Disconnect from storage provider\"\"\"\n        pass",
        "detail": "utils.storage_providers",
        "documentation": {}
    },
    {
        "label": "FTPStorage",
        "kind": 6,
        "importPath": "utils.storage_providers",
        "description": "utils.storage_providers",
        "peekOfCode": "class FTPStorage(StorageProvider):\n    \"\"\"FTP storage provider\"\"\"\n    def __init__(self, host: str, port: int = 21, username: str = \"\", \n                 password: str = \"\", base_path: str = \"/\"):\n        self.host = host\n        self.port = port\n        self.username = username\n        self.password = password\n        self.base_path = base_path\n        self.ftp = None",
        "detail": "utils.storage_providers",
        "documentation": {}
    },
    {
        "label": "SFTPStorage",
        "kind": 6,
        "importPath": "utils.storage_providers",
        "description": "utils.storage_providers",
        "peekOfCode": "class SFTPStorage(StorageProvider):\n    \"\"\"SFTP storage provider\"\"\"\n    def __init__(self, host: str, port: int = 22, username: str = \"\", \n                 password: str = \"\", key_filename: Optional[str] = None,\n                 base_path: str = \"/\"):\n        self.host = host\n        self.port = port\n        self.username = username\n        self.password = password\n        self.key_filename = key_filename",
        "detail": "utils.storage_providers",
        "documentation": {}
    },
    {
        "label": "GoogleDriveStorage",
        "kind": 6,
        "importPath": "utils.storage_providers",
        "description": "utils.storage_providers",
        "peekOfCode": "class GoogleDriveStorage(StorageProvider):\n    \"\"\"Google Drive storage provider\"\"\"\n    def __init__(self, credentials_file: str, folder_id: Optional[str] = None):\n        self.credentials_file = credentials_file\n        self.folder_id = folder_id\n        self.service = None\n    def connect(self) -> bool:\n        \"\"\"Connect to Google Drive\"\"\"\n        try:\n            from google.oauth2.credentials import Credentials",
        "detail": "utils.storage_providers",
        "documentation": {}
    },
    {
        "label": "DropboxStorage",
        "kind": 6,
        "importPath": "utils.storage_providers",
        "description": "utils.storage_providers",
        "peekOfCode": "class DropboxStorage(StorageProvider):\n    \"\"\"Dropbox storage provider\"\"\"\n    def __init__(self, access_token: str, base_path: str = \"/\"):\n        self.access_token = access_token\n        self.base_path = base_path\n        self.dbx = None\n    def connect(self) -> bool:\n        \"\"\"Connect to Dropbox\"\"\"\n        try:\n            import dropbox",
        "detail": "utils.storage_providers",
        "documentation": {}
    },
    {
        "label": "OneDriveStorage",
        "kind": 6,
        "importPath": "utils.storage_providers",
        "description": "utils.storage_providers",
        "peekOfCode": "class OneDriveStorage(StorageProvider):\n    \"\"\"OneDrive storage provider\"\"\"\n    def __init__(self, client_id: str, client_secret: str, folder_path: str = \"/\"):\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.folder_path = folder_path\n        self.session = None\n    def connect(self) -> bool:\n        \"\"\"Connect to OneDrive\"\"\"\n        try:",
        "detail": "utils.storage_providers",
        "documentation": {}
    },
    {
        "label": "StorageManager",
        "kind": 6,
        "importPath": "utils.storage_providers",
        "description": "utils.storage_providers",
        "peekOfCode": "class StorageManager:\n    \"\"\"Manages storage providers\"\"\"\n    def __init__(self):\n        self.providers: Dict[str, StorageProvider] = {}\n        self.active_provider: Optional[str] = None\n    def add_provider(self, name: str, provider: StorageProvider):\n        \"\"\"Add a storage provider\"\"\"\n        self.providers[name] = provider\n    def set_active_provider(self, name: str) -> bool:\n        \"\"\"Set active storage provider\"\"\"",
        "detail": "utils.storage_providers",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "utils.storage_providers",
        "description": "utils.storage_providers",
        "peekOfCode": "console = Console()\nclass StorageProvider(ABC):\n    \"\"\"Abstract base class for storage providers\"\"\"\n    @abstractmethod\n    def connect(self) -> bool:\n        \"\"\"Connect to storage provider\"\"\"\n        pass\n    @abstractmethod\n    def disconnect(self):\n        \"\"\"Disconnect from storage provider\"\"\"",
        "detail": "utils.storage_providers",
        "documentation": {}
    },
    {
        "label": "is_colab",
        "kind": 2,
        "importPath": "colab_setup",
        "description": "colab_setup",
        "peekOfCode": "def is_colab():\n    \"\"\"Check if running in Google Colab\"\"\"\n    try:\n        import google.colab\n        return True\n    except ImportError:\n        return False\ndef setup_colab_environment():\n    \"\"\"Setup environment for Google Colab\"\"\"\n    if not is_colab():",
        "detail": "colab_setup",
        "documentation": {}
    },
    {
        "label": "setup_colab_environment",
        "kind": 2,
        "importPath": "colab_setup",
        "description": "colab_setup",
        "peekOfCode": "def setup_colab_environment():\n    \"\"\"Setup environment for Google Colab\"\"\"\n    if not is_colab():\n        print(\"  Not running in Google Colab\")\n        return False\n    print(\" Setting up YouTube Playlist Downloader for Google Colab...\")\n    # Mount Google Drive\n    try:\n        from google.colab import drive\n        drive.mount('/content/drive', force_remount=False)",
        "detail": "colab_setup",
        "documentation": {}
    },
    {
        "label": "colab_download_queue",
        "kind": 2,
        "importPath": "colab_setup",
        "description": "colab_setup",
        "peekOfCode": "def colab_download_queue(playlist_url, format_type='audio', file_format='mp3', \n                         quality=None, batch_size=None):\n    \"\"\"\n    Create and prepare a download queue for Colab (no interactive menu)\n    Args:\n        playlist_url: YouTube playlist URL\n        format_type: 'audio' or 'video'\n        file_format: Output format (mp3, mp4, etc.)\n        quality: Quality setting (optional, uses defaults)\n        batch_size: Number of items to download (optional, downloads all)",
        "detail": "colab_setup",
        "documentation": {}
    },
    {
        "label": "colab_start_download",
        "kind": 2,
        "importPath": "colab_setup",
        "description": "colab_setup",
        "peekOfCode": "def colab_start_download(queue):\n    \"\"\"\n    Start downloading a queue (non-interactive)\n    Args:\n        queue: Queue object from colab_download_queue()\n    \"\"\"\n    from managers.queue_manager import QueueManager\n    from downloaders.playlist import PlaylistDownloader\n    if not queue:\n        print(\" No queue provided\")",
        "detail": "colab_setup",
        "documentation": {}
    },
    {
        "label": "colab_list_downloads",
        "kind": 2,
        "importPath": "colab_setup",
        "description": "colab_setup",
        "peekOfCode": "def colab_list_downloads():\n    \"\"\"List all downloaded files\"\"\"\n    import subprocess\n    print(\"\\n Downloaded Files:\")\n    print(\"=\" * 70)\n    result = subprocess.run(\n        ['find', 'downloads/', '-type', 'f', '-not', '-path', '*/.*'],\n        capture_output=True,\n        text=True\n    )",
        "detail": "colab_setup",
        "documentation": {}
    },
    {
        "label": "colab_backup_to_drive",
        "kind": 2,
        "importPath": "colab_setup",
        "description": "colab_setup",
        "peekOfCode": "def colab_backup_to_drive():\n    \"\"\"Backup database to Google Drive\"\"\"\n    import shutil\n    if not is_colab():\n        print(\"  Not running in Colab\")\n        return\n    backup_dir = '/content/drive/MyDrive/YouTube_Downloader_Backups'\n    Path(backup_dir).mkdir(parents=True, exist_ok=True)\n    # Backup database\n    db_file = 'downloads.db'",
        "detail": "colab_setup",
        "documentation": {}
    },
    {
        "label": "colab_quick_download",
        "kind": 2,
        "importPath": "colab_setup",
        "description": "colab_setup",
        "peekOfCode": "def colab_quick_download(playlist_url, format_type='audio', file_format='mp3'):\n    \"\"\"\n    One-command download (creates queue and starts download)\n    Args:\n        playlist_url: YouTube playlist URL\n        format_type: 'audio' or 'video'\n        file_format: Output format (mp3, mp4, etc.)\n    \"\"\"\n    print(\" YouTube Playlist Downloader - Colab Mode\")\n    print(\"=\" * 70)",
        "detail": "colab_setup",
        "documentation": {}
    },
    {
        "label": "colab_help",
        "kind": 2,
        "importPath": "colab_setup",
        "description": "colab_setup",
        "peekOfCode": "def colab_help():\n    \"\"\"Display usage instructions for Colab\"\"\"\n    print(\"\"\"\n\n           YouTube Playlist Downloader - Google Colab Mode                 \n\n Quick Start:\n\n1  Setup environment (run once):\n   >>> from colab_setup import setup_colab_environment",
        "detail": "colab_setup",
        "documentation": {}
    },
    {
        "label": "print_banner",
        "kind": 2,
        "importPath": "db_viewer",
        "description": "db_viewer",
        "peekOfCode": "def print_banner():\n    \"\"\"Print viewer banner\"\"\"\n    print(BANNER)\n    print()\ndef print_section(title):\n    \"\"\"Print a section header\"\"\"\n    print(f\"\\n{'' * 75}\")\n    print(f\"  {title}\")\n    print(f\"{'' * 75}\\n\")\ndef get_database_size(db_path: Path) -> str:",
        "detail": "db_viewer",
        "documentation": {}
    },
    {
        "label": "print_section",
        "kind": 2,
        "importPath": "db_viewer",
        "description": "db_viewer",
        "peekOfCode": "def print_section(title):\n    \"\"\"Print a section header\"\"\"\n    print(f\"\\n{'' * 75}\")\n    print(f\"  {title}\")\n    print(f\"{'' * 75}\\n\")\ndef get_database_size(db_path: Path) -> str:\n    \"\"\"Get database file size\"\"\"\n    if not db_path.exists():\n        return \"N/A\"\n    size_bytes = db_path.stat().st_size",
        "detail": "db_viewer",
        "documentation": {}
    },
    {
        "label": "get_database_size",
        "kind": 2,
        "importPath": "db_viewer",
        "description": "db_viewer",
        "peekOfCode": "def get_database_size(db_path: Path) -> str:\n    \"\"\"Get database file size\"\"\"\n    if not db_path.exists():\n        return \"N/A\"\n    size_bytes = db_path.stat().st_size\n    if size_bytes < 1024:\n        return f\"{size_bytes} B\"\n    elif size_bytes < 1024 * 1024:\n        return f\"{size_bytes / 1024:.2f} KB\"\n    else:",
        "detail": "db_viewer",
        "documentation": {}
    },
    {
        "label": "get_table_info",
        "kind": 2,
        "importPath": "db_viewer",
        "description": "db_viewer",
        "peekOfCode": "def get_table_info(cursor: sqlite3.Cursor, table_name: str) -> Tuple[int, List[str]]:\n    \"\"\"Get row count and column names for a table\"\"\"\n    # Get row count\n    cursor.execute(f\"SELECT COUNT(*) FROM {table_name}\")\n    row_count = cursor.fetchone()[0]\n    # Get column names\n    cursor.execute(f\"PRAGMA table_info({table_name})\")\n    columns = [row[1] for row in cursor.fetchall()]\n    return row_count, columns\ndef format_value(value, max_length: int = 50) -> str:",
        "detail": "db_viewer",
        "documentation": {}
    },
    {
        "label": "format_value",
        "kind": 2,
        "importPath": "db_viewer",
        "description": "db_viewer",
        "peekOfCode": "def format_value(value, max_length: int = 50) -> str:\n    \"\"\"Format a value for display\"\"\"\n    if value is None:\n        return \"NULL\"\n    str_value = str(value)\n    if len(str_value) > max_length:\n        return str_value[:max_length - 3] + \"...\"\n    return str_value\ndef display_table_summary(cursor: sqlite3.Cursor, tables: List[str]):\n    \"\"\"Display summary of all tables\"\"\"",
        "detail": "db_viewer",
        "documentation": {}
    },
    {
        "label": "display_table_summary",
        "kind": 2,
        "importPath": "db_viewer",
        "description": "db_viewer",
        "peekOfCode": "def display_table_summary(cursor: sqlite3.Cursor, tables: List[str]):\n    \"\"\"Display summary of all tables\"\"\"\n    print(\"TABLE SUMMARY\")\n    print(\"\" * 75)\n    print(f\"{'Table Name':<30} {'Row Count':>15} {'Columns':>10}\")\n    print(\"\" * 75)\n    for table_name in tables:\n        row_count, columns = get_table_info(cursor, table_name)\n        print(f\"{table_name:<30} {row_count:>15,} {len(columns):>10}\")\n    print(\"\" * 75)",
        "detail": "db_viewer",
        "documentation": {}
    },
    {
        "label": "display_table_data",
        "kind": 2,
        "importPath": "db_viewer",
        "description": "db_viewer",
        "peekOfCode": "def display_table_data(cursor: sqlite3.Cursor, table_name: str, limit: int = 10):\n    \"\"\"Display last N rows of a table\"\"\"\n    print_section(f\"Table: {table_name}\")\n    # Get table info\n    row_count, columns = get_table_info(cursor, table_name)\n    print(f\"Total rows: {row_count:,}\")\n    print(f\"Columns: {', '.join(columns)}\\n\")\n    if row_count == 0:\n        print(\" Table is empty\\n\")\n        return",
        "detail": "db_viewer",
        "documentation": {}
    },
    {
        "label": "view_database",
        "kind": 2,
        "importPath": "db_viewer",
        "description": "db_viewer",
        "peekOfCode": "def view_database(db_path: str):\n    \"\"\"Main database viewing function\"\"\"\n    db_file = Path(db_path)\n    if not db_file.exists():\n        print(f\" Database file not found: {db_path}\")\n        sys.exit(1)\n    print_banner()\n    print(f\" Database: {db_path}\")\n    print(f\" File Size: {get_database_size(db_file)}\")\n    try:",
        "detail": "db_viewer",
        "documentation": {}
    },
    {
        "label": "list_databases",
        "kind": 2,
        "importPath": "db_viewer",
        "description": "db_viewer",
        "peekOfCode": "def list_databases():\n    \"\"\"List available database files\"\"\"\n    print_banner()\n    print_section(\"Available Databases\")\n    db_files = [\n        \"downloads.db\",\n        \"stats.db\"\n    ]\n    found_dbs = []\n    for db_file in db_files:",
        "detail": "db_viewer",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "db_viewer",
        "description": "db_viewer",
        "peekOfCode": "def main():\n    \"\"\"Main entry point\"\"\"\n    try:\n        # Check arguments\n        if len(sys.argv) > 1:\n            db_path = sys.argv[1]\n            view_database(db_path)\n        else:\n            # Interactive mode\n            found_dbs = list_databases()",
        "detail": "db_viewer",
        "documentation": {}
    },
    {
        "label": "BANNER",
        "kind": 5,
        "importPath": "db_viewer",
        "description": "db_viewer",
        "peekOfCode": "BANNER = \"\"\"\n\n                                                                           \n                    SQLite Database Viewer                                \n              YouTube Playlist Downloader Database Inspector              \n                                                                           \n\n\"\"\"\ndef print_banner():\n    \"\"\"Print viewer banner\"\"\"",
        "detail": "db_viewer",
        "documentation": {}
    },
    {
        "label": "DownloadStatus",
        "kind": 6,
        "importPath": "enums",
        "description": "enums",
        "peekOfCode": "class DownloadStatus(Enum):\n    \"\"\"Download status enumeration\"\"\"\n    PENDING = \"pending\"\n    DOWNLOADING = \"downloading\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    CANCELLED = \"cancelled\"\nclass QueueStatus(Enum):\n    \"\"\"Queue status enumeration\"\"\"\n    PENDING = \"pending\"",
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "QueueStatus",
        "kind": 6,
        "importPath": "enums",
        "description": "enums",
        "peekOfCode": "class QueueStatus(Enum):\n    \"\"\"Queue status enumeration\"\"\"\n    PENDING = \"pending\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    CANCELLED = \"cancelled\"\nclass FormatType(Enum):\n    \"\"\"Download format type enumeration\"\"\"\n    VIDEO = \"video\"",
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "FormatType",
        "kind": 6,
        "importPath": "enums",
        "description": "enums",
        "peekOfCode": "class FormatType(Enum):\n    \"\"\"Download format type enumeration\"\"\"\n    VIDEO = \"video\"\n    AUDIO = \"audio\"\nclass VideoQuality(Enum):\n    \"\"\"Video quality options\"\"\"\n    BEST = \"best\"\n    Q1080P = \"1080p\"\n    Q720P = \"720p\"\n    Q480P = \"480p\"",
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "VideoQuality",
        "kind": 6,
        "importPath": "enums",
        "description": "enums",
        "peekOfCode": "class VideoQuality(Enum):\n    \"\"\"Video quality options\"\"\"\n    BEST = \"best\"\n    Q1080P = \"1080p\"\n    Q720P = \"720p\"\n    Q480P = \"480p\"\n    Q360P = \"360p\"\nclass AudioQuality(Enum):\n    \"\"\"Audio quality options (kbps)\"\"\"\n    Q320 = \"320\"",
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "AudioQuality",
        "kind": 6,
        "importPath": "enums",
        "description": "enums",
        "peekOfCode": "class AudioQuality(Enum):\n    \"\"\"Audio quality options (kbps)\"\"\"\n    Q320 = \"320\"\n    Q256 = \"256\"\n    Q192 = \"192\"\n    Q128 = \"128\"\nclass StorageProvider(Enum):\n    \"\"\"Storage provider types\"\"\"\n    LOCAL = \"local\"\n    FTP = \"ftp\"",
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "StorageProvider",
        "kind": 6,
        "importPath": "enums",
        "description": "enums",
        "peekOfCode": "class StorageProvider(Enum):\n    \"\"\"Storage provider types\"\"\"\n    LOCAL = \"local\"\n    FTP = \"ftp\"\n    SFTP = \"sftp\"\n    GOOGLE_DRIVE = \"google_drive\"\n    DROPBOX = \"dropbox\"\n    ONEDRIVE = \"onedrive\"\nclass NotificationProvider(Enum):\n    \"\"\"Notification provider types\"\"\"",
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "NotificationProvider",
        "kind": 6,
        "importPath": "enums",
        "description": "enums",
        "peekOfCode": "class NotificationProvider(Enum):\n    \"\"\"Notification provider types\"\"\"\n    EMAIL = \"email\"\n    SLACK = \"slack\"\nclass DownloadOrder(Enum):\n    \"\"\"Download order options\"\"\"\n    NEWEST_FIRST = \"newest_first\"\n    OLDEST_FIRST = \"oldest_first\"\n    AS_LISTED = \"as_listed\"",
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "DownloadOrder",
        "kind": 6,
        "importPath": "enums",
        "description": "enums",
        "peekOfCode": "class DownloadOrder(Enum):\n    \"\"\"Download order options\"\"\"\n    NEWEST_FIRST = \"newest_first\"\n    OLDEST_FIRST = \"oldest_first\"\n    AS_LISTED = \"as_listed\"",
        "detail": "enums",
        "documentation": {}
    },
    {
        "label": "print_banner",
        "kind": 2,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "def print_banner():\n    \"\"\"Print installation banner\"\"\"\n    print(BANNER)\n    print()\ndef print_section(title):\n    \"\"\"Print a section header\"\"\"\n    print(f\"\\n{'' * 75}\")\n    print(f\"  {title}\")\n    print(f\"{'' * 75}\\n\")\ndef check_python_version():",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "print_section",
        "kind": 2,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "def print_section(title):\n    \"\"\"Print a section header\"\"\"\n    print(f\"\\n{'' * 75}\")\n    print(f\"  {title}\")\n    print(f\"{'' * 75}\\n\")\ndef check_python_version():\n    \"\"\"Check if Python version is adequate\"\"\"\n    if sys.version_info < (3, 8):\n        print(\" Python 3.8 or higher is required!\")\n        print(f\"   Current version: {sys.version}\")",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "check_python_version",
        "kind": 2,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "def check_python_version():\n    \"\"\"Check if Python version is adequate\"\"\"\n    if sys.version_info < (3, 8):\n        print(\" Python 3.8 or higher is required!\")\n        print(f\"   Current version: {sys.version}\")\n        sys.exit(1)\n    print(f\" Python version: {sys.version.split()[0]}\")\ndef install_dependencies():\n    \"\"\"Install required packages\"\"\"\n    print_section(\"Installing Required Packages\")",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "install_dependencies",
        "kind": 2,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "def install_dependencies():\n    \"\"\"Install required packages\"\"\"\n    print_section(\"Installing Required Packages\")\n    requirements_file = Path(__file__).parent / \"requirements.txt\"\n    requirements_dev_file = Path(__file__).parent / \"requirements-dev.txt\"\n    if not requirements_file.exists():\n        print(\" requirements.txt not found!\")\n        sys.exit(1)\n    print(\"Installing core dependencies from requirements.txt...\")\n    try:",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "show_settings_summary",
        "kind": 2,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "def show_settings_summary():\n    \"\"\"Show default settings one section at a time\"\"\"\n    from rich.console import Console\n    from rich.table import Table\n    from rich.prompt import Confirm\n    console = Console()\n    print_section(\"Default Configuration\")\n    # Download Settings\n    print(\"\\n DOWNLOAD SETTINGS\\n\")\n    download_table = Table(show_header=True, header_style=\"bold cyan\")",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "initialize_database",
        "kind": 2,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "def initialize_database():\n    \"\"\"Initialize database and test connection\"\"\"\n    print_section(\"Database Initialization\")\n    from database import get_database_connection\n    from managers.database_manager import DatabaseManager\n    print(\"Creating database connection...\")\n    try:\n        db = get_database_connection(db_type=\"sqlite\", db_path=\"downloads.db\")\n        print(\" Database connection established\")\n        print(\"\\nInitializing database schema...\")",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "seed_database",
        "kind": 2,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "def seed_database():\n    \"\"\"Seed database with initial data\"\"\"\n    print_section(\"Database Seeding\")\n    from rich.prompt import Confirm\n    seed_db = Confirm.ask(\"Would you like to seed the database with sample data?\", default=False)\n    if seed_db:\n        try:\n            print(\"\\nSeeding database...\")\n            import seed_database\n            print(\" Database seeded successfully\")",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "create_directories",
        "kind": 2,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "def create_directories():\n    \"\"\"Create necessary directories\"\"\"\n    print_section(\"Creating Directories\")\n    directories = [\n        \"downloads\",\n        \"logs\",\n        \"data\"\n    ]\n    for directory in directories:\n        path = Path(directory)",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "run_setup_wizard",
        "kind": 2,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "def run_setup_wizard():\n    \"\"\"Run the setup wizard for custom configuration\"\"\"\n    print_section(\"Configuration Wizard\")\n    from ui.setup_wizard import SetupWizard\n    print(\"Starting configuration wizard...\\n\")\n    wizard = SetupWizard()\n    wizard.run()\ndef main():\n    \"\"\"Main installation process\"\"\"\n    try:",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "def main():\n    \"\"\"Main installation process\"\"\"\n    try:\n        print_banner()\n        # Check Python version\n        print_section(\"System Requirements Check\")\n        check_python_version()\n        # Check system dependencies\n        check_system_dependencies()\n        # Install dependencies",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "BANNER",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "BANNER = \"\"\"\n\n                                                                           \n              YouTube Playlist Downloader - Installation                  \n                                                                           \n              Advanced download management system                         \n                                                                           \n\n\"\"\"\ndef print_banner():",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def main():\n    IN_COLAB = False\n    \"\"\"Main application loop\"\"\"\n    try:\n        # Check if running in Colab\n        if IN_COLAB:\n            console.print(\"[yellow]  Running in Google Colab detected[/yellow]\")\n            console.print()\n            console.print(\"Interactive menu is not available in Colab.\")\n            console.print(\"Please use the [cyan]colab_setup.py[/cyan] module instead.\")",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "console = Console()\ndef main():\n    IN_COLAB = False\n    \"\"\"Main application loop\"\"\"\n    try:\n        # Check if running in Colab\n        if IN_COLAB:\n            console.print(\"[yellow]  Running in Google Colab detected[/yellow]\")\n            console.print()\n            console.print(\"Interactive menu is not available in Colab.\")",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "seed_channels_callback",
        "kind": 2,
        "importPath": "seed_database",
        "description": "seed_database",
        "peekOfCode": "def seed_channels_callback(record: dict):\n    \"\"\"Callback to insert a channel record\"\"\"\n    monitor_manager = MonitorManager()\n    existing = monitor_manager.get_channel_by_url(record['url'])\n    if existing:\n        return \"skipped\"\n    channel = Channel(\n        id=None,\n        url=record['url'],\n        title=record['title'],",
        "detail": "seed_database",
        "documentation": {}
    },
    {
        "label": "seed_proxies_callback",
        "kind": 2,
        "importPath": "seed_database",
        "description": "seed_database",
        "peekOfCode": "def seed_proxies_callback(record: dict):\n    \"\"\"Callback to insert a proxy record\"\"\"\n    config_manager = ConfigManager()\n    # Format proxy string\n    protocol = record.get('protocol', 'http')\n    ip = record['ip']\n    port = record['port']\n    proxy_string = f\"{protocol}://{ip}:{port}\"\n    # Check if already exists\n    if proxy_string in config_manager.config.proxies:",
        "detail": "seed_database",
        "documentation": {}
    },
    {
        "label": "seed_config_preset_callback",
        "kind": 2,
        "importPath": "seed_database",
        "description": "seed_database",
        "peekOfCode": "def seed_config_preset_callback(record: dict):\n    \"\"\"Callback to apply a config preset\"\"\"\n    config_manager = ConfigManager()\n    console.print(f\"\\n[cyan]Available preset: {record['name']}[/cyan]\")\n    console.print(f\"[dim]{record['description']}[/dim]\")\n    if not Confirm.ask(\"Apply this preset?\", default=False):\n        return \"skipped\"\n    # Apply preset settings\n    if record.get('video_quality'):\n        config_manager.config.default_video_quality = record['video_quality']",
        "detail": "seed_database",
        "documentation": {}
    },
    {
        "label": "list_available_seeds",
        "kind": 2,
        "importPath": "seed_database",
        "description": "seed_database",
        "peekOfCode": "def list_available_seeds():\n    \"\"\"List all available seed files\"\"\"\n    seeder = DatabaseSeeder()\n    seeder.display_seed_files_table()\ndef validate_all_seeds():\n    \"\"\"Validate all seed files\"\"\"\n    console.print(\"\\n[bold cyan]Validating All Seed Files[/bold cyan]\\n\")\n    seeder = DatabaseSeeder()\n    validations = {\n        'channels': ['url', 'title', 'is_monitored', 'check_interval_minutes',",
        "detail": "seed_database",
        "documentation": {}
    },
    {
        "label": "validate_all_seeds",
        "kind": 2,
        "importPath": "seed_database",
        "description": "seed_database",
        "peekOfCode": "def validate_all_seeds():\n    \"\"\"Validate all seed files\"\"\"\n    console.print(\"\\n[bold cyan]Validating All Seed Files[/bold cyan]\\n\")\n    seeder = DatabaseSeeder()\n    validations = {\n        'channels': ['url', 'title', 'is_monitored', 'check_interval_minutes',\n                    'format_type', 'quality', 'output_dir', 'filename_template',\n                    'download_order', 'enabled'],\n        'proxies': ['ip', 'port', 'protocol'],\n        'config_presets': ['name', 'description'],",
        "detail": "seed_database",
        "documentation": {}
    },
    {
        "label": "seed_interactive",
        "kind": 2,
        "importPath": "seed_database",
        "description": "seed_database",
        "peekOfCode": "def seed_interactive():\n    \"\"\"Interactive seeding menu\"\"\"\n    console.clear()\n    header = Panel(\n        \"[bold cyan]Database Seeding Tool[/bold cyan]\\n\"\n        \"Select which data to seed\",\n        border_style=\"cyan\"\n    )\n    console.print(header)\n    options = [",
        "detail": "seed_database",
        "documentation": {}
    },
    {
        "label": "seed_all",
        "kind": 2,
        "importPath": "seed_database",
        "description": "seed_database",
        "peekOfCode": "def seed_all():\n    \"\"\"Seed all available seed files\"\"\"\n    console.print(\"\\n[bold cyan]Seeding All Data[/bold cyan]\\n\")\n    if not Confirm.ask(\"This will seed channels, proxies, and config. Continue?\", default=True):\n        return\n    seeder = DatabaseSeeder()\n    # Seed channels\n    console.print(\"\\n[bold]Seeding Channels...[/bold]\")\n    seeder.seed_from_json('channels', {'channels': seed_channels_callback})\n    # Seed proxies",
        "detail": "seed_database",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "seed_database",
        "description": "seed_database",
        "peekOfCode": "def main():\n    \"\"\"Main entry point\"\"\"\n    parser = argparse.ArgumentParser(description='Database Seeding Tool')\n    parser.add_argument('--interactive', '-i', action='store_true',\n                       help='Interactive mode - choose what to seed')\n    parser.add_argument('--channels', action='store_true',\n                       help='Seed channels only')\n    parser.add_argument('--proxies', action='store_true',\n                       help='Seed proxies only')\n    parser.add_argument('--all', action='store_true',",
        "detail": "seed_database",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "seed_database",
        "description": "seed_database",
        "peekOfCode": "console = Console()\ndef seed_channels_callback(record: dict):\n    \"\"\"Callback to insert a channel record\"\"\"\n    monitor_manager = MonitorManager()\n    existing = monitor_manager.get_channel_by_url(record['url'])\n    if existing:\n        return \"skipped\"\n    channel = Channel(\n        id=None,\n        url=record['url'],",
        "detail": "seed_database",
        "documentation": {}
    },
    {
        "label": "test_rate_limiter",
        "kind": 2,
        "importPath": "test_rate_limiter",
        "description": "test_rate_limiter",
        "peekOfCode": "def test_rate_limiter():\n    \"\"\"Test rate limiter functionality\"\"\"\n    console.print(\"[cyan]Testing Rate Limiter...[/cyan]\\n\")\n    # Create rate limiter with low limits for testing\n    rate_limiter = RateLimiter(\n        max_downloads_per_hour=5,\n        min_delay_seconds=0.5,\n        max_delay_seconds=1.0\n    )\n    console.print(\"[yellow]Testing 10 downloads with 5/hour limit...[/yellow]\\n\")",
        "detail": "test_rate_limiter",
        "documentation": {}
    },
    {
        "label": "test_rate_limiter_stats",
        "kind": 2,
        "importPath": "test_rate_limiter",
        "description": "test_rate_limiter",
        "peekOfCode": "def test_rate_limiter_stats():\n    \"\"\"Test rate limiter statistics\"\"\"\n    console.print(\"\\n[cyan]Testing Rate Limiter Stats...[/cyan]\\n\")\n    rate_limiter = RateLimiter(\n        max_downloads_per_hour=50,\n        min_delay_seconds=2.0,\n        max_delay_seconds=5.0\n    )\n    # Simulate some downloads\n    for i in range(10):",
        "detail": "test_rate_limiter",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "test_rate_limiter",
        "description": "test_rate_limiter",
        "peekOfCode": "console = Console()\ndef test_rate_limiter():\n    \"\"\"Test rate limiter functionality\"\"\"\n    console.print(\"[cyan]Testing Rate Limiter...[/cyan]\\n\")\n    # Create rate limiter with low limits for testing\n    rate_limiter = RateLimiter(\n        max_downloads_per_hour=5,\n        min_delay_seconds=0.5,\n        max_delay_seconds=1.0\n    )",
        "detail": "test_rate_limiter",
        "documentation": {}
    },
    {
        "label": "print_banner",
        "kind": 2,
        "importPath": "uninstall",
        "description": "uninstall",
        "peekOfCode": "def print_banner():\n    \"\"\"Print uninstallation banner\"\"\"\n    print(BANNER)\n    print()\ndef print_section(title):\n    \"\"\"Print a section header\"\"\"\n    print(f\"\\n{'' * 75}\")\n    print(f\"  {title}\")\n    print(f\"{'' * 75}\\n\")\ndef confirm_uninstall():",
        "detail": "uninstall",
        "documentation": {}
    },
    {
        "label": "print_section",
        "kind": 2,
        "importPath": "uninstall",
        "description": "uninstall",
        "peekOfCode": "def print_section(title):\n    \"\"\"Print a section header\"\"\"\n    print(f\"\\n{'' * 75}\")\n    print(f\"  {title}\")\n    print(f\"{'' * 75}\\n\")\ndef confirm_uninstall():\n    \"\"\"Confirm uninstallation with user\"\"\"\n    print(\"  WARNING: This will remove all application data!\\n\")\n    print(\"The following will be deleted:\")\n    print(\"   Configuration files\")",
        "detail": "uninstall",
        "documentation": {}
    },
    {
        "label": "confirm_uninstall",
        "kind": 2,
        "importPath": "uninstall",
        "description": "uninstall",
        "peekOfCode": "def confirm_uninstall():\n    \"\"\"Confirm uninstallation with user\"\"\"\n    print(\"  WARNING: This will remove all application data!\\n\")\n    print(\"The following will be deleted:\")\n    print(\"   Configuration files\")\n    print(\"   Database files (downloads.db, stats.db)\")\n    print(\"   Log files\")\n    print(\"   Virtual environment (if --fresh flag is used)\")\n    print()\n    response = input(\"Are you sure you want to continue? [y/N]: \").strip().lower()",
        "detail": "uninstall",
        "documentation": {}
    },
    {
        "label": "remove_config",
        "kind": 2,
        "importPath": "uninstall",
        "description": "uninstall",
        "peekOfCode": "def remove_config():\n    \"\"\"Remove configuration files\"\"\"\n    print(\"Removing configuration files...\")\n    config_file = Path(\"config.json\")\n    if config_file.exists():\n        config_file.unlink()\n        print(\"   Removed config.json\")\n    else:\n        print(\"   config.json not found\")\ndef remove_databases():",
        "detail": "uninstall",
        "documentation": {}
    },
    {
        "label": "remove_databases",
        "kind": 2,
        "importPath": "uninstall",
        "description": "uninstall",
        "peekOfCode": "def remove_databases():\n    \"\"\"Remove database files\"\"\"\n    print(\"\\nRemoving database files...\")\n    db_files = [\"downloads.db\", \"stats.db\"]\n    for db_file in db_files:\n        path = Path(db_file)\n        if path.exists():\n            path.unlink()\n            print(f\"   Removed {db_file}\")\n        else:",
        "detail": "uninstall",
        "documentation": {}
    },
    {
        "label": "remove_logs",
        "kind": 2,
        "importPath": "uninstall",
        "description": "uninstall",
        "peekOfCode": "def remove_logs():\n    \"\"\"Remove log directory\"\"\"\n    print(\"\\nRemoving log files...\")\n    logs_dir = Path(\"logs\")\n    if logs_dir.exists():\n        shutil.rmtree(logs_dir)\n        print(\"   Removed logs/ directory\")\n    else:\n        print(\"   logs/ directory not found\")\ndef remove_data_directory():",
        "detail": "uninstall",
        "documentation": {}
    },
    {
        "label": "remove_data_directory",
        "kind": 2,
        "importPath": "uninstall",
        "description": "uninstall",
        "peekOfCode": "def remove_data_directory():\n    \"\"\"Remove data directory\"\"\"\n    print(\"\\nRemoving data directory...\")\n    data_dir = Path(\"data\")\n    if data_dir.exists():\n        shutil.rmtree(data_dir)\n        print(\"   Removed data/ directory\")\n    else:\n        print(\"   data/ directory not found\")\ndef remove_downloads():",
        "detail": "uninstall",
        "documentation": {}
    },
    {
        "label": "remove_downloads",
        "kind": 2,
        "importPath": "uninstall",
        "description": "uninstall",
        "peekOfCode": "def remove_downloads():\n    \"\"\"Ask about removing downloads directory\"\"\"\n    print(\"\\nDownloads directory...\")\n    downloads_dir = Path(\"downloads\")\n    if downloads_dir.exists():\n        response = input(\"  Remove downloads/ directory? [y/N]: \").strip().lower()\n        if response in ['y', 'yes']:\n            shutil.rmtree(downloads_dir)\n            print(\"   Removed downloads/ directory\")\n        else:",
        "detail": "uninstall",
        "documentation": {}
    },
    {
        "label": "remove_venv",
        "kind": 2,
        "importPath": "uninstall",
        "description": "uninstall",
        "peekOfCode": "def remove_venv():\n    \"\"\"Remove virtual environment\"\"\"\n    print(\"\\nRemoving virtual environment...\")\n    venv_dir = Path(\"venv\")\n    if venv_dir.exists():\n        shutil.rmtree(venv_dir)\n        print(\"   Removed venv/ directory\")\n    else:\n        print(\"   venv/ directory not found\")\ndef remove_pycache():",
        "detail": "uninstall",
        "documentation": {}
    },
    {
        "label": "remove_pycache",
        "kind": 2,
        "importPath": "uninstall",
        "description": "uninstall",
        "peekOfCode": "def remove_pycache():\n    \"\"\"Remove Python cache directories\"\"\"\n    print(\"\\nRemoving Python cache files...\")\n    count = 0\n    for pycache in Path(\".\").rglob(\"__pycache__\"):\n        shutil.rmtree(pycache)\n        count += 1\n    if count > 0:\n        print(f\"   Removed {count} __pycache__ directories\")\n    else:",
        "detail": "uninstall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "uninstall",
        "description": "uninstall",
        "peekOfCode": "def main():\n    \"\"\"Main uninstallation process\"\"\"\n    try:\n        print_banner()\n        # Check for --fresh flag\n        fresh_install = \"--fresh\" in sys.argv\n        if fresh_install:\n            print(\" Fresh install mode: Will remove data directories\\n\")\n        # Confirm uninstallation\n        if not confirm_uninstall():",
        "detail": "uninstall",
        "documentation": {}
    },
    {
        "label": "BANNER",
        "kind": 5,
        "importPath": "uninstall",
        "description": "uninstall",
        "peekOfCode": "BANNER = \"\"\"\n\n                                                                           \n            YouTube Playlist Downloader - Uninstallation                  \n                                                                           \n\n\"\"\"\ndef print_banner():\n    \"\"\"Print uninstallation banner\"\"\"\n    print(BANNER)",
        "detail": "uninstall",
        "documentation": {}
    }
]